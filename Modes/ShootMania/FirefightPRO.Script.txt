#Extends "Modes/Shootmania/LoadoutsTools.Script.txt"

#Const CompatibleMapTypes	"FirefightArena"
#Const Version				"2014-08-22"
#Const ScriptName			"FirefightPRO.Script.txt"

#Include "MathLib" as MathLib
#Include "TextLib" as TextLib
#Include "Libs/Toss2.Script.txt" as Toss
#Include "Libs/Draft2.Script.txt" as CDraft
//#Include "Libs/Nadeo/Layers2.Script.txt" as Layers
//#Include "Libs/Nadeo/Message.Script.txt" as Message
#Include "Libs/Nadeo/Victory.Script.txt" as Victory
//#Include "Libs/Nadeo/Sound.Script.txt" as Sound
#Include "Libs/Nadeo/CustomUI.Script.txt" as CustomUI
#Include "Libs/Nadeo/ShootMania/SM.Script.txt" as SM
#Include "Libs/Nadeo/ShootMania/Map.Script.txt" as Map
#Include "Libs/Nadeo/ShootMania/Score.Script.txt" as Score
#Include "Libs/Nadeo/ShootMania/SpawnScreen.Script.txt" as SpawnScreen
#Include "Libs/Nadeo/ShootMania/WarmUp2.Script.txt" as WarmUp2

#Setting S_RoundTime			90		as _("Basic round time")
#Setting S_RoundTimeBonus		15		as _("Round time bonus when someone captured the goal")
#Setting S_PoleCaptureDuration	1		as _("Basic duration of the pole capture")
/*#Setting S_MapPointsLimit		5		as _("Number of rounds to make half-time")
#Setting S_ClassSelectionTime	13		as _("Time to choose basic loadout before round")
#Setting S_FinalRoundExceptDraw	True	as _("Use additional round to determine map winner")*/
#Setting S_MapsToWin			1		as _("Number of maps to win a match")
#Setting S_WarmUpDuration		60		as _("Warm up duration (sec.)")
#Setting S_UseCDraft			False	as _("Use Draft mode before match")
#Setting S_CDraftBanNb			2		as _("Number of map to ban during Draft (-1: ban all)")
#Setting S_CDraftPickNb			3		as _("Number of map to pick during Draft")
#Setting S_PlayerArmor 			5 		as _("Number of armors per player")
#Setting S_UseSpawnChoosing		False	as _("Use spawn choosing toss")
#Setting S_ObjectDetector		60. 	as _("Objects markers detection distance (0. to disable)")
#Setting S_ItemSpawnTime		45 		as _("Number of seconds to spawn items after pick-up")
#Setting S_BlueBot 				0 		as _("Number of blue test bots")
#Setting S_RedBot 				0 		as _("Number of red test bots")
// Clublinks settings
#Setting S_UsePlayerClublinks	False	as _("Use players clublinks")	// Use the players clublinks, or otherwise use the default teams
#Setting S_ForceClublinkTeam1	""		as "<hidden>"	// Force the Clublink of team 1 (format: http://www.example.com/MyTeam.Club.xml)
#Setting S_ForceClublinkTeam2	""		as "<hidden>"	// Force the Clublink of team 2 (format: http://www.example.com/MyTeam.Club.xml)

// XML-RPC default layers positions
#Const C_LayerProgressionPosition	<131., 125., 0.>

#Const C_Object [
	"Laser"			=> "Laser",
	"PlasmaGun"		=> "PlasmaGun",
	"Grenades"		=> "Grenades",
	"Nucleus"		=> "Nucleus",
	"Shotgun"		=> "Shotgun",
	"BlowBomb"		=> "BlowBomb"
]

#Const C_SequencePause				0		// Scores table mode warm up after play
#Const C_SequenceWarmUp				1		// Scores table mode warm up
#Const C_SequencePlaying			2		// Scores table mode playing
#Const C_SequencePodium				3		// Scores table mode podium
#Const C_UI_Colors [
	"BG"		=> "113f",
	"Separator"	=> "eeef",
	"Text"		=> "fffc"
]

#Command Command_MatchPointsClan1			(Integer)	as _("Match points for clan 1")
#Command Command_MatchPointsClan2			(Integer)	as _("Match points for clan 2")
#Command Command_CurrentMapPointsClan1		(Integer)	as _("Current map points for clan 1")
#Command Command_CurrentMapPointsClan2		(Integer)	as _("Current map points for clan 2")
#Command Command_ForceCDraftWinner			(Integer)	as _("Force first team in CDraft (1: Left clan, 2: Right clan)")
#Command Command_ForceSpawnWinner			(Integer)	as _("Force first team in spawn selection toss (1: Left clan, 2: Right clan)")
#Command Command_ForceWarmUp				(Boolean)	as _("Set pause")
#Command Command_ForceClublinkReload		(Boolean)	as _("Force clublink reload")

#Const Description  _("RULES:\n- Control 3 zones of goals or eliminate all enemies to win the round.\n- Controlled zone can be stolen by the opposing team.\n- Capture objectives to revive teammates and heal yourself (2 armors).\n- Before round You can pick 1 of 3 secondary weapon.\n- Find weapon items on map to collect primary weapon.")

declare Integer[Integer]			G_ClansMapPoints;		// Number of points cumulated on one map for each clan
declare Ident[]						G_SpawnList1;			// Spawns with tag Spawn1
declare Ident[]						G_SpawnList2;			// Spawns with tag Spawn2
declare CSmMapLandmark[Integer]		G_SpawnList;			// All spawns
declare Integer[Integer]			G_PlayersAlive;			// How many players are alive in specific team
declare Integer[Integer] 			G_ZoneClanList; 		// Which clan control specific zone
declare Integer						G_NbPolesA;				// Number of poles in Zone A
declare Integer						G_NbPolesB;				// Number of poles in Zone B
declare Integer						G_NbPolesC;				// Number of poles in Zone C
declare Integer[Text]				G_SecondaryWeapons;		// Current player secondary weapons
declare Integer[Text]				G_PrimaryWeapons;		// Current player secondary weapons
declare Integer 					G_LastProgressUpdate;	// Time of the last progrresion layer update
declare Integer 					G_LastSettingsUpdate; 	// Time of the last setting layer update
declare Integer 					G_LastTempUpdate;

declare Integer[Integer]			G_TempMapPoints;		// Saved number of points cumulated on one map for each clan
declare Integer						G_ChoosedSpawnClan;
declare Integer[Integer] 			G_SpawnForClan;

// Globals caches the settings
declare Integer 					G_RoundTime;
declare Integer 					G_RoundTimeBonus;
declare Integer 					G_PoleCaptureDuration;
declare Integer 					G_MapPointsLimit;
declare Integer 					G_ClassSelectionTime;
declare Real 						G_ObjectDetector;
declare Integer 					G_BlueBot;
declare Integer 					G_RedBot;
declare Integer 					G_WarmUpDuration;
declare Integer 					G_MapsToWin;
declare Integer 					G_Override_CDraftWinner;
declare Integer						G_Override_SpawnWinner;
declare Boolean 					G_Override_NeedWarmUp;
declare Boolean 					G_Override_ForceClublinkReload;

declare Ident[Text] 				G_ObjectId;				// Ids of the objects
declare Ident 						G_CustomBounceRocket;
declare Ident 						G_CustomGrenades;
declare Ident 						G_CustomPlasmaGun;
declare Ident 						G_CustomElectricPistol;
declare Ident 						G_CustomShotgun;
declare Ident 						G_CustomBlowBomb;

declare Integer[Integer] 			G_PlayerCountA;
declare Integer[Integer] 			G_PlayerCountB;
declare Integer[Integer] 			G_PlayerCountC;

***LogVersion***
***
MB_LogVersion(ScriptName, Version);
MB_LogVersion(SM::GetScriptName(), SM::GetScriptVersion());
MB_LogVersion(Toss::GetScriptName(), Toss::GetScriptVersion());
MB_LogVersion(Map::GetScriptName(), Map::GetScriptVersion());
MB_LogVersion(CustomUI::GetScriptName(), CustomUI::GetScriptVersion());
MB_LogVersion(Score::GetScriptName(), Score::GetScriptVersion());
//MB_LogVersion(Layers::GetScriptName(), Layers::GetScriptVersion());
//MB_LogVersion(Message::GetScriptName(), Message::GetScriptVersion());
MB_LogVersion(SpawnScreen::GetScriptName(), SpawnScreen::GetScriptVersion());
MB_LogVersion(CDraft::GetScriptName(), CDraft::GetScriptVersion());
***

***InitServer***
***
MB_UseSectionRound		= True;
MB_UseSectionTurn		= False;
MB_UsePlayerClublinks	= S_UsePlayerClublinks;
***

***StartServer***
***
UseClans			= True;
UseProtectClanmates	= False;
UseLaserSkewering	= False;
UseAmmoBonusOnHit	= False;
UsePlayerTagging 	= True;

if(S_RoundTime < 20) G_RoundTime = 20;
else G_RoundTime = S_RoundTime;

if(S_RoundTimeBonus < 0) G_RoundTimeBonus = 0;
else G_RoundTimeBonus = S_RoundTimeBonus;

if(S_PoleCaptureDuration < 1) G_PoleCaptureDuration = 1;
else G_PoleCaptureDuration = S_PoleCaptureDuration;

if(S_MapPointsLimit < 1) G_MapPointsLimit = 1;
else G_MapPointsLimit = S_MapPointsLimit;

if(S_MapsToWin < 1) G_MapsToWin = 1;
else G_MapsToWin = S_MapsToWin;

if(S_ClassSelectionTime < 5) G_ClassSelectionTime = 5;
else G_ClassSelectionTime = S_ClassSelectionTime;

if(S_ObjectDetector < 0.) G_ObjectDetector = 0.;
else G_ObjectDetector = S_ObjectDetector;

if(S_BlueBot <= 0) G_BlueBot = 0;
else G_BlueBot = S_BlueBot;

if(S_RedBot < 0) G_RedBot = 0;
else G_RedBot = S_RedBot;

G_WarmUpDuration = S_WarmUpDuration;

InitWarmUp();

declare ModeName = "Firefight #PRO";
declare ModeObjectives = TextLib::Compose(_("$<%11. $>The goal of this mode is to control 3 zones by capturing the poles/checkpoints or eliminating all enemies.\n$<%12. $>A game is divided in rounds.\n$<%13. $>The first team with %2 points wins the match."), "$"^SpawnScreen::GetModeColor(), TextLib::ToText(S_MapPointsLimit+1));
declare ModeConditions = TextLib::Compose(_("$<%11. $>You can carry 2 weapons. Primary weapon you can find on map by collecting weapon item. The secondary you are choosing before round.\n$<%12. $>Objectives are very important. You can revive dead teammates by capturing the zone.\n$<%13. $>Every respawn in-game costs you 1 armor."), "$"^SpawnScreen::GetModeColor());

SpawnScreen::AddSubsection(_("Type"), _("Team versus Team"), 0.);
SpawnScreen::AddSubsection(_("Objectives"), ModeObjectives, 20.);
SpawnScreen::AddSubsection(_("Conditions"), ModeConditions, 60.);
SpawnScreen::CreatePrettyRules(ModeName);
ModeStatusMessage = _("RULES:\n- Control 3 zones of goals or eliminate all enemies to win the round.\n- Controlled zone can be stolen by the opposing team.\n- Capture objectives to revive teammates and heal yourself (2 armors).\n- Before round You can pick 1 of 3 secondary weapon.\n- Find weapon items on map to collect primary weapon.");
SM::SetupDefaultVisibility();

CustomUI::Load();
CustomUI::Add("FireFightPRO_PlayersList_1", <-160., 60.>, <40., 30.>, "top", "left");
CustomUI::Add("FireFightPRO_PlayersList_2", <160., 60.>, <40., 30.>, "top", "right");
CustomUI::Add("FireFight_GaugeCapture", <0., -45.>, <130., 20.>, "center", "center");
CustomUI::Build();
WarmUp2::Load();
CDraft::StartServer();
// Create layers
Layers::Create("ScoresTable", CreateLayerScoresTable());
Layers::Create("Progression"); // Zone Capture progress
Layers::Create("ProgressBar"); // Specific capture progress
Layers::Create("Markers"); // markers layer
Layers::Create("HUD"); // Hud layer when player is spawned
Layers::Create("RulesReminder", UpdateLayerRulesReminder());
Layers::SetType("Markers", CUILayer::EUILayerType::Markers);
Layers::SetType("RulesReminder", CUILayer::EUILayerType::CutScene);
Layers::SetType("ScoresTable", CUILayer::EUILayerType::ScoresTable);
Layers::Attach("RulesReminder");

UIManager.UIAll.ScoreTableOnlyManialink = True;
UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::ForcedHidden;

// Init Actions
ActionList_Begin();
G_CustomBounceRocket 				= ActionList_Add("BRocket.Action.Gbx");
G_CustomPlasmaGun					= ActionList_Add("PlasmaGun.Action.Gbx");
G_CustomGrenades 					= ActionList_Add("Grenades.Action.Gbx");
G_CustomElectricPistol 				= ActionList_Add("ElectricPistol.Action.Gbx");
G_CustomShotgun 					= ActionList_Add("Shotgun.Action.Gbx");
G_CustomBlowBomb 					= ActionList_Add("BlowBomb.Action.Gbx");
ActionList_End();

// Init Items
ItemList_Begin();
G_ObjectId[C_Object["Laser"]]		= ItemList_Add("PickUpFF/Laser.Item.gbx");
G_ObjectId[C_Object["PlasmaGun"]]	= ItemList_Add("PickUpFF/PlasmaGun.Item.gbx");
G_ObjectId[C_Object["Grenades"]]	= ItemList_Add("PickUpFF/Grenades.Item.gbx");
G_ObjectId[C_Object["Nucleus"]]		= ItemList_Add("PickUpFF/Nucleus.Item.gbx");
G_ObjectId[C_Object["Shotgun"]]		= ItemList_Add("PickUpFF/Shotgun.Item.gbx");
G_ObjectId[C_Object["BlowBomb"]]	= ItemList_Add("PickUpFF/BlowBomb.Item.gbx");
ItemList_End();
***	

***InitMatch***
***
declare Integer TossWinner;
***

***StartMatch***
***
// Reset clan scores
ClanScores[1] = 0;
ClanScores[2] = 0;
TossWinner = -1;
G_Override_CDraftWinner = -1;
G_Override_NeedWarmUp = False;
G_ZoneClanList = [1 => 0, 2 => 0, 3 => 0];
G_SpawnForClan = [1 => 0, 2 => 0];
// reset custom scores table data
foreach(Score in Scores)
{
	declare CurrentKills for Score = 0;
	CurrentKills = 0;
	declare CurrentDeaths for Score = 0;
	CurrentDeaths = 0;
	declare CurrentMVP for Score = 0;
	CurrentMVP = 0;
}
declare MapPlayedSinceMatchBeginning = 0;	// Even maps skipped by a vote
if (S_UseCDraft && MB_SectionMapNb == 1) 
{
	Mode::LoadMap();
	
	ClanScores[1] = 0;
	ClanScores[2] = 0;
	
	UIManager.UIAll.MarkersXML = "";
	SpawnScreen::AttachRules();
	Clublink::Attach();
	Clublink::SetSponsorsDisplay(False);
	Layers::Attach("ScoresTable");
	Layers::Update("ScoresTable", CreateLayerScoresTable());
	UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::Normal;
	InitWarmUp();
	InitSpawns();
	Users_SetNbFakeUsers(S_BlueBot, S_RedBot);
	
	MB_CurrentSection = "WarmUp";
	DoWarmUp();
	MB_CurrentSection = "StartMatch";
	
	Layers::Detach("ScoresTable");
	
	declare Order = [1 => WarmUp2::GetGroup("Clan1"), 2 => WarmUp2::GetGroup("Clan2")];
	declare Selected = [1 => Ident[], 2 => Ident[]];
	for (I, 1, 2) {
		foreach (Slot => PlayerId in Order[I]) {
			Selected[I].add(PlayerId);
		}
	}
	CDraft::SetPlayersSelected(Selected);
	if (G_Override_CDraftWinner == 1 || G_Override_CDraftWinner == 2) {
		TossWinner = G_Override_CDraftWinner;
		G_Override_CDraftWinner = -1;
	} else {
		TossWinner = Toss::Toss();
	}
	CDraft::MapSelection(S_CDraftBanNb, S_CDraftPickNb, TossWinner);
	
	declare TmpNextMapIndex = CDraft::GetMapIndex(1);
	if (TmpNextMapIndex >= 0) NextMapIndex = TmpNextMapIndex;
	
	Mode::UnloadMap();
}
***

***InitMap***
***
declare Integer		ClanMapWinner;		// Clan who win the map
declare Integer 	SpawnWinner = -1;
declare SpawnVoteClan = 0;
MB_UseIntro = True;
//assert(MapType::GetVersion() == 2, _("Outdated map! If you are map creator, check rules of the map."));
***

***StartMap***
***
UIManager.UIAll.MarkersXML = "";
UIManager.UIAll.ScreenIn3dHideVersus = False;
UIManager.UIAll.ScreenIn3dHideScoreSummary = False;
G_ClansMapPoints	= [1 => 0, 2 => 0];
G_TempMapPoints		= [1 => 0, 2 => 0];
G_ZoneClanList 		= [1 => 0, 2 => 0, 3 => 0];
G_SecondaryWeapons.clear();
G_PrimaryWeapons.clear();
G_PlayerCountA 		= [1 => 0, 2 => 0];
G_PlayerCountB 		= [1 => 0, 2 => 0];
G_PlayerCountC 		= [1 => 0, 2 => 0];
ClanMapWinner		= 0;
G_NbPolesA			= 0;
G_NbPolesB			= 0;
G_NbPolesC			= 0;
G_SpawnForClan		= [1 => 0, 2 => 0];
G_Override_SpawnWinner = -1;
G_ChoosedSpawnClan = 0; //G_BannedClass
// reset custom scores table data
foreach(Score in Scores)
{
	declare CurrentKills for Score = 0;
	CurrentKills = 0;
	declare CurrentDeaths for Score = 0;
	CurrentDeaths = 0;
	declare CurrentMVP for Score = 0;
	CurrentMVP = 0;
}
InitSpawns();
InitWarmUp();
UpdateHeader();

// Init scores
Score::MatchBegin();
ST2::ClearScores();
Layers::Attach("ScoresTable");
Layers::Update("ScoresTable", CreateLayerScoresTable());
UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::Normal;

MapPlayedSinceMatchBeginning += 1;
if (S_UseCDraft) {
	declare TmpNextMapIndex = CDraft::GetMapIndex(MapPlayedSinceMatchBeginning + 1);
	if (TmpNextMapIndex >= 0) NextMapIndex = TmpNextMapIndex;
}
// Debug
Users_SetNbFakeUsers(S_BlueBot, S_RedBot);

MB_CurrentSection = "WarmUp";
DoWarmUp();
MB_CurrentSection = "StartMap";

// Update the players clublinks
if (S_ForceClublinkTeam1 == "" && S_ForceClublinkTeam2 == "") Clublink::DefineTeamAuto();
else Clublink::DefineTeamFromUrl(S_ForceClublinkTeam1, S_ForceClublinkTeam2);
Clublink::SyncUpdate();

// Init UI
SM::SetupDefaultVisibility();
Message::CleanAllMessages();
Clublink::Attach();
Clublink::SetSponsorsDisplay(False);
UpdateHeader();

// Debug
Users_SetNbFakeUsers(G_BlueBot, G_RedBot);

SM::UnspawnAllPlayers();
***

***InitRound***
***
declare Ident FirstOnGoal; 		// The first player on pole
declare Integer RoundClanWinner;// Team, who win the round
declare Integer TempGoalNb;		// To stop looping
declare Integer BestRoundScore;	// The best RoundPoints score in round
declare CSmPlayer MVP;			// The best player in round
***

***StartRound***
***
FirstOnGoal = NullId;
TempGoalNb = 0;
BestRoundScore = 0;
MVP = Null;
G_LastProgressUpdate = 0;
G_LastSettingsUpdate = 0;
G_LastTempUpdate = 0;
G_SecondaryWeapons.clear();
G_PrimaryWeapons.clear();
Mode::Synchro_DoBarrier();
UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::Normal;
if (WarmUp2::GetPlayersNb("Clan1") < 2 || WarmUp2::GetPlayersNb("Clan2") < 2 || G_Override_NeedWarmUp) 
{
	G_TempMapPoints = G_ClansMapPoints;
	if (RoundClanWinner == 1) G_ClansMapPoints[1] -= 1;
	else if (RoundClanWinner == 2) G_ClansMapPoints[2] -= 1;	
	UpdateHeader();
	MB_CurrentSection = "WarmUp";
	DoWarmUp();
	MB_CurrentSection = "StartRound";
	G_Override_NeedWarmUp = False;
	MB_StopRound = True;
	MB_SectionRoundNb -= 1;
}
G_Override_NeedWarmUp = False;
RoundClanWinner = 0;
Victory::RoundBegin();
Score::RoundBegin();
if(MB_SectionRoundNb < 1)
{
	// reset custom scores table data
	foreach(Score in Scores)
	{
		declare CurrentKills for Score = 0;
		CurrentKills = 0;
		declare CurrentDeaths for Score = 0;
		CurrentDeaths = 0;
		declare CurrentMVP for Score = 0;
		CurrentMVP = 0;
	}
	UpdateLayerScoresTable(C_SequencePlaying);
}
// If this is the first round and turn on the map, launch the players presentation
if (MB_SectionRoundNb == 1) 
{
	UpdateHeader();
	MB_PlayersPresentationSequence(3000);

	// If players want spawn choosing
	if(S_UseSpawnChoosing)
	{
		UIManager.UIAll.UISequence_CanSkipIntroMT = False;
		UIManager.UIAll.UISequence = CUIConfig::EUISequence::RollingBackgroundIntro;
		//Override the toss winner
		if (G_Override_SpawnWinner == 1 || G_Override_SpawnWinner == 2) 
		{
			if (MB_SectionMapNb == 1) 
			{
				if (SpawnWinner == -1) SpawnVoteClan = G_Override_SpawnWinner;
				else 
				{
					SpawnWinner = G_Override_SpawnWinner;
					SpawnVoteClan = 3 - SpawnWinner;
				}
			} 
			else 
			{
				if (MB_SectionMapNb % 2 == 0) SpawnVoteClan = 3 - G_Override_SpawnWinner;
				else SpawnVoteClan = G_Override_SpawnWinner;
			}
			G_Override_SpawnWinner = -1;
		} 
		else 
		{
			// Play the toss
			if (MB_SectionMapNb == 1) 
			{
				if (SpawnWinner == -1) SpawnVoteClan = Toss::Toss();
				else SpawnVoteClan = 3 - SpawnWinner;	// The looser of the map selection toss
			}
		}
		UpdateTossMarker();
		declare Integer SideResult;
		SideResult = Toss::SelectSide(SpawnVoteClan);
		G_SpawnForClan[SpawnVoteClan] = SideResult;
		G_SpawnForClan[3-SpawnVoteClan] = 3-SideResult;
		UIManager.UIAll.UISequence_CanSkipIntroMT = True;	
	}
	else
	{
		G_SpawnForClan[1] = 1;
		G_SpawnForClan[2] = 2;
	}
}
if(LT_IsAfterHalfTime())
{
	if(G_SpawnForClan[1] == 1) G_ZoneClanList = [1 => 2, 2 => 0, 3 => 1];
	else G_ZoneClanList = [1 => 1, 2 => 0, 3 => 2];
}	
else 
{
	if(G_SpawnForClan[1] == 1) G_ZoneClanList = [1 => 1, 2 => 0, 3 => 2];
	else G_ZoneClanList = [1 => 2, 2 => 0, 3 => 1];
}
Message::CleanAllMessages();
UIManager.UIAll.UISequence = CUIConfig::EUISequence::EndRound;
Mode::PlaySound(CUIConfig::EUISound::StartRound, 0);
InitGoals();
InitSpawns();
UpdateHeader();
UpdateBasesColors();
if(ServerShutdownRequested || MatchEndRequested) break;
Layers::Update("Progression", UpdateLayerProgression(1));
UpdateLayerScoresTable(C_SequencePlaying);
UIManager.UIAll.MarkersXML = "";
SelectClasses(G_ClassSelectionTime*1000);
//MB_Log(G_SpawnForClan[1]^" | "^G_SpawnForClan[2]);

// Load Items
ObjectDestroyAll();
foreach (MapLandmark in MapLandmarks_ObjectAnchor) 
{
	declare ObjectSpawned for MapLandmark = False;
	declare ObjectNextSpawn for MapLandmark = Now;
	ObjectSpawned = False;
	ObjectNextSpawn = Now + 3000;
}

// Init players and spawn ticket
foreach (Player in AllPlayers) 
{
	declare SpawnTicket for Player = 0;
	SpawnTicket = 1;
	SetPlayerClan(Player, Player.RequestedClan);
	if(Player.CurrentClan == 1) WarmUp2::SetPlayerGroup(Player, "Clan1");
	else if (Player.CurrentClan == 2) WarmUp2::SetPlayerGroup(Player, "Clan2");
	ActionLoad(Player, CSmMode::EActionSlot::Slot_A, NullId);
	ActionBind(Player, CSmMode::EActionSlot::Slot_A, CSmMode::EActionInput::None);
	declare PrimaryWeapon for Player = 0;
	PrimaryWeapon = 0;
	declare UI <=> UIManager.GetUI(Player);
	if (UI != Null) 
	{ 
		declare netwrite Integer[Text] Net_PrimaryWeapons for UI;
		Net_PrimaryWeapons[Player.Login] = 0;
	}
	declare HasChangedClan for Player = False;
	declare NewSpectator for Player = False;
	SetPlayerClan(Player, Player.RequestedClan);
	if (UI != Null)
	{
		declare SpawnArmor for Player = 100;
		SpawnArmor = S_PlayerArmor * 100;
		Player.ArmorMax = SpawnArmor;	
	}
	HasChangedClan = False;
	NewSpectator = True;
}

WarmUp2::Clean();
WarmUp2::Fill();

foreach (Spectator in Spectators) {
	declare SpawnArmor for Spectator = 100;
	declare NewSpectator for Spectator = False;
	SpawnArmor = 0;
	NewSpectator = False;
}

// Init spectator mode
foreach (Player in AllPlayers) 
{
	declare UI <=> UIManager.GetUI(Player);
	if (UI == Null) continue;
	
	if (Player.RequestsSpectate) 
	{
		declare SpawnTicket for Player = 0;
		SpawnTicket = 0;
		UI.SpectatorForceCameraType = -1;
		UI.SpectatorForcedClan = -1;
	} 
	else 
	{
		UI.SpectatorForceCameraType = 1;
		UI.SpectatorForcedClan = Player.CurrentClan;
	}
}
ForceClublinkReload();
// Update the players clublinks
if (S_ForceClublinkTeam1 == "" && S_ForceClublinkTeam2 == "") Clublink::DefineTeamAuto();
else Clublink::DefineTeamFromUrl(S_ForceClublinkTeam1, S_ForceClublinkTeam2);
Clublink::SyncUpdate();
CustomUI::Attach();
UIManager.UIAll.UISequence = CUIConfig::EUISequence::Playing;
Layers::Update("Progression", UpdateLayerProgression(0));
Layers::Attach("Progression");
Layers::Update("ProgressBar", UpdateLayerProgressBar());
Layers::Attach("ProgressBar");
Layers::Update("ScoresTable", CreateLayerScoresTable());
LT_ShowPlayersLists();
Layers::Attach("Markers");
Layers::Update("HUD", UpdateLayerHUD());
Layers::Attach("HUD");
UpdateMarker();
//CreateMinimap();

// Set the timers
LT_SetRoundTimer(G_RoundTime);

// Save a back up to restore the game to this turn in case of a force warm up
if(MB_SectionRoundNb > 1)
{
	foreach (Score in Scores) 
	{
		declare CurrentKills for Score = 0;
		declare CurrentDeaths for Score = 0;
		declare CurrentMVP for Score = 0;
	
		declare Save_CurrentKills	for Score = CurrentKills;
		declare Save_CurrentDeaths	for Score = CurrentDeaths;
		declare Save_CurrentMVP		for Score = CurrentMVP;
	
		Save_CurrentKills 	= CurrentKills;
		Save_CurrentDeaths	= CurrentDeaths;
		Save_CurrentMVP		= CurrentMVP;
	}
}	
***

***OnNewPlayer***
***
declare UI <=> UIManager.GetUI(Player);
if (UI != Null) 
{
	UI.SpectatorForcedClan		= Player.CurrentClan;
	UI.SpectatorForceCameraType	= 1;
	Layers::Attach("Progression", Player);
	LT_UpdatePlayersLists();
	declare CurrentKills for Player.Score = 0;
	declare CurrentDeaths for Player.Score = 0;
	declare CurrentMVP for Player.Score = 0;
	declare SpawnArmor for Player = 100;
	SpawnArmor = S_PlayerArmor * 100;
	Player.ArmorMax = SpawnArmor;
	declare netwrite Net_PrimaryWeapon for UI = 0;
	Net_PrimaryWeapon = 0;
}
WarmUp2::Clean();
WarmUp2::Fill();
***

***OnNewSpectator***
***
declare UI <=> UIManager.GetUI(Spectator);
if (UI != Null) 
{
	declare CurrentKills for Spectator.Score = 0;
	CurrentKills = 0;
	declare CurrentDeaths for Spectator.Score = 0;
	CurrentDeaths = 0;
	declare CurrentMVP for Spectator.Score = 0;
	CurrentMVP = 0;
	UI.SpectatorForcedClan		= -1;
	UI.SpectatorForceCameraType	= -1;
	Layers::Attach("Progression", Spectator);
	LT_AttachPlayersLists(Spectator);
	Layers::Detach("HUD", Spectator);
}
declare SpawnTicket for Spectator = 100;
SpawnTicket = 0;
***

***Yield***
***
Message::Loop();
Clublink::Update();
foreach (Event in XmlRpc.PendingEvents) 
{
	if (Event.Type == CXmlRpcEvent::EType::CallbackArray) 
	{
		switch (Event.ParamArray1) 
		{
			case "Firefight_SetProgressionLayerPosition": 
			{
				declare netwrite Net_Firefight_ProgressionLayerPosition for Teams[0] = C_LayerProgressionPosition;
				if (Event.ParamArray2.existskey(0)) Net_Firefight_ProgressionLayerPosition.X = TextLib::ToReal(Event.ParamArray2[0]);
				if (Event.ParamArray2.existskey(1)) Net_Firefight_ProgressionLayerPosition.Y = TextLib::ToReal(Event.ParamArray2[1]);
				if (Event.ParamArray2.existskey(2)) Net_Firefight_ProgressionLayerPosition.Z = TextLib::ToReal(Event.ParamArray2[2]);
			}
		}
	}
}
***

***PlayLoop***
***
ManageCommand();
ForceClublinkReload();
declare PlayerCountA = [1 => 0, 2 => 0];
declare PlayerCountB = [1 => 0, 2 => 0];
declare PlayerCountC = [1 => 0, 2 => 0];

if(G_LastTempUpdate + 20 < Now) // There is a loop bug when at the same time, two zones have been captured
{
	G_LastTempUpdate = Now;
	if(TempGoalNb > 0) TempGoalNb = 0;
}
if(G_LastSettingsUpdate + 2000 < Now)
{
	G_LastSettingsUpdate = Now;
	if(S_RoundTime < 20) G_RoundTime = 20;
	else G_RoundTime = S_RoundTime;

	if(S_RoundTimeBonus < 0) G_RoundTimeBonus = 0;
	else G_RoundTimeBonus = S_RoundTimeBonus;

	if(S_PoleCaptureDuration < 1) G_PoleCaptureDuration = 1;
	else G_PoleCaptureDuration = S_PoleCaptureDuration;

	if(S_MapsToWin < 1) G_MapsToWin = 1;
	else G_MapsToWin = S_MapsToWin;

	G_WarmUpDuration = S_WarmUpDuration;

	if(!S_FinalRoundExceptDraw || MB_SectionRoundNb != S_MapPointsLimit*2+1)
	{
		if(S_MapPointsLimit < 1)
		{
			G_MapPointsLimit = 1;
		}	
		else
		{
			G_MapPointsLimit = S_MapPointsLimit;
		}
	}		

	if(S_ClassSelectionTime < 5) G_ClassSelectionTime = 5;
	else G_ClassSelectionTime = S_ClassSelectionTime;
	
	if(S_ObjectDetector < 0.) G_ObjectDetector = 0.;
	else G_ObjectDetector = S_ObjectDetector;
	
	if(S_BlueBot < 0) G_BlueBot = 0;
	else G_BlueBot = S_BlueBot;

	if(S_RedBot < 0) G_RedBot = 0;
	else G_RedBot = S_RedBot;
	
	Users_SetNbFakeUsers(G_BlueBot, G_RedBot);
	
	if(PlayersNbTotal < 2) MB_StopRound = True;
}

// Unspawn and mark players changing clan
foreach (Player in Players) {
	if (!Player.IsFakePlayer && Player.SpawnStatus == CSmPlayer::ESpawnStatus::Spawned) {
		// if the player wants to change clan, then remove him from the current clan
		// it will be added to the correct clan at next respawn.
		if (Player.CurrentClan != 0 && Player.RequestedClan != Player.CurrentClan) {
			UnspawnPlayer(Player);
			declare HasChangedClan for Player = False;
			HasChangedClan = True;
		}
	}
	if(!Player.IsFakePlayer && Player.RequestsSpectate)
	{
		declare NewSpectator for Player = False;
		NewSpectator = True;
		LT_DetachWeaponSelection(Player);
	}
}

// Don't let players going spectate respawn afterward
foreach (Spectator in Spectators) 
{
	declare SpawnArmor for Spectator = 100;
	declare NewSpectator for Spectator = False;
	SpawnArmor = 0;
	if (NewSpectator) NewSpectator = False;
}
// Spawning players
if(RoundClanWinner == 0)
{
	foreach (Player in Players)
	{
		declare HasChangedClan for Player = False;
		declare NewSpectator for Player = True;
		if (Player.SpawnStatus == CSmPlayer::ESpawnStatus::NotSpawned && !HasChangedClan)
		{
			declare SecondaryWeapon for Player = 1;
			declare SpawnTicket for Player = 0;
			if(SpawnTicket <= 0) continue;
			declare SpawnArmor for Player = 100;
			if (SpawnArmor < 100) SpawnArmor = 100;
			if (SpawnArmor > Player.ArmorMax) SpawnArmor = Player.ArmorMax;
			if (Player.CurrentClan != 1 && Player.CurrentClan != 2)
			{
				SetPlayerClan(Player, Player.RequestedClan);
				if(Player.RequestedClan == 1) WarmUp2::SetPlayerGroup(Player, "Clan1");
				else if(Player.RequestedClan == 2) WarmUp2::SetPlayerGroup(Player, "Clan2");
			}	
			if (Player.RequestedClan == 1 && SpawnArmor > 0)
			{
				declare SpawnId = NullId;
				if(LT_IsAfterHalfTime())
				{
					if(G_SpawnForClan[1] == 1) SpawnId = G_SpawnList2[MathLib::Rand(0, G_SpawnList2.count - 1)];
					else SpawnId = G_SpawnList1[MathLib::Rand(0, G_SpawnList1.count - 1)];
				}	
				else 
				{
					if(G_SpawnForClan[1] == 1) SpawnId = G_SpawnList1[MathLib::Rand(0, G_SpawnList1.count - 1)];
					else SpawnId = G_SpawnList2[MathLib::Rand(0, G_SpawnList2.count - 1)];
				}	
				if (SpawnId != NullId)
				{
					SM::SpawnPlayer(Player, Player.CurrentClan, SpawnArmor, MapLandmarks_PlayerSpawn[SpawnId].PlayerSpawn, 3000);
					SpawnTicket = 0;
					declare MSG = "";
					switch(Player.User.Language)
					{
						case "pl": MSG = "$fd0Zdominuj terytorium i wzywaj posiłki przez zdobywanie stref!";
						case "fr": MSG = "$fd0Prends le contrôle du territoire et ranime tes coéquipiers en capturant les poles !";
						case "ru": MSG = "$fd0Контролируйте территорию и возрождайте товарищей по команде путём захвата флагов!";
						case "it": MSG = "$fd0Domina il territorio e chiama i rinforzi attraverso catturare delle zone!";
						case "de": MSG = "$fd0Herrsche über das Gebiet und erlöse teamkameraden durch Erobern der Pfähle!";
						default: MSG = "$fd0Control territory and revive teammates by capturing the poles!";
					} 
					Message::SendStatusMessage(Player, MSG, 4000, 0);
					declare UI <=> UIManager.GetUI(Player);
					if (UI != Null) 
					{
						declare netread Net_SecondaryWeapon for UI = 1;
						switch (Net_SecondaryWeapon) 
						{
							case 1:
							{
								ActionBind(Player, CSmMode::EActionSlot::Slot_B, CSmMode::EActionInput::None);
								SetPlayerWeapon(Player, CSmMode::EWeapon::Rocket, False);
								SetPlayerAmmoMax(Player, CSmMode::EWeapon::Rocket, C_RocketsAmmo);
								Player.StaminaMax = C_StaminaWith1Weapon;
								Player.StaminaGain = C_StaminaWith1Weapon;
								Player.SpeedPower = C_SpeedWith1Weapon;
								Player.AmmoGain = 1.0;
								SecondaryWeapon = 1;
							}
							case 2:
							{
								// Action MAKER
								ActionLoad(Player, CSmMode::EActionSlot::Slot_B, G_CustomBounceRocket);
    							ActionBind(Player, CSmMode::EActionSlot::Slot_B, CSmMode::EActionInput::Weapon);
								Player.StaminaMax = C_StaminaWith1Weapon;
								Player.StaminaGain = C_StaminaWith1Weapon;
								Player.SpeedPower = C_SpeedWith1Weapon;
								SecondaryWeapon = 2;
							}
							case 3:
							{
								// Action MAKER
								ActionLoad(Player, CSmMode::EActionSlot::Slot_B, G_CustomElectricPistol);
    							ActionBind(Player, CSmMode::EActionSlot::Slot_B, CSmMode::EActionInput::Weapon);
								Player.StaminaMax = C_StaminaWith1Weapon;
								Player.StaminaGain = C_StaminaWith1Weapon;
								Player.SpeedPower = C_SpeedWith1Weapon;
								SecondaryWeapon = 3;
							}
							default: //basic
							{
								ActionBind(Player, CSmMode::EActionSlot::Slot_B, CSmMode::EActionInput::None);
								SetPlayerWeapon(Player, CSmMode::EWeapon::Rocket, False);
								SetPlayerAmmoMax(Player, CSmMode::EWeapon::Rocket, C_RocketsAmmo);
								Player.StaminaMax = C_StaminaWith1Weapon;
								Player.StaminaGain = C_StaminaWith1Weapon;
								Player.SpeedPower = C_SpeedWith1Weapon;
								Player.AmmoGain = 1.0;
								SecondaryWeapon = 1;
							}
						}
						G_SecondaryWeapons[Player.Login] = SecondaryWeapon;
						declare netwrite Integer[Text] Net_SecondaryWeapons for UI;
						Net_SecondaryWeapons = G_SecondaryWeapons;
					}
					else
					{
						SetPlayerWeapon(Player, CSmMode::EWeapon::Rocket, False);
						SetPlayerAmmoMax(Player, CSmMode::EWeapon::Rocket, C_RocketsAmmo);
						Player.StaminaMax = C_StaminaWith1Weapon;
						Player.StaminaGain = C_StaminaWith1Weapon;
						Player.SpeedPower = C_SpeedWith1Weapon;
						Player.AmmoGain = 1.0;
						SecondaryWeapon = 1;
					}	
					Player.Armor = SpawnArmor;
					Player.ArmorMax = SpawnArmor;
				}
				else log(Now^">Wrong map, check spawn tags");	
			}
			else if (Player.RequestedClan == 2 && SpawnArmor > 0)
			{
				declare SpawnId = NullId;
				if(LT_IsAfterHalfTime())
				{
					if(G_SpawnForClan[2] == 1) SpawnId = G_SpawnList2[MathLib::Rand(0, G_SpawnList2.count - 1)];
					else SpawnId = G_SpawnList1[MathLib::Rand(0, G_SpawnList1.count - 1)];
				}	
				else 
				{
					if(G_SpawnForClan[2] == 1) SpawnId = G_SpawnList1[MathLib::Rand(0, G_SpawnList1.count - 1)];
					else SpawnId = G_SpawnList2[MathLib::Rand(0, G_SpawnList2.count - 1)];
				}	
				if (SpawnId != NullId) 
				{
					SM::SpawnPlayer(Player, Player.CurrentClan, SpawnArmor, MapLandmarks_PlayerSpawn[SpawnId].PlayerSpawn, 3000);
					SpawnTicket = 0;
					declare MSG = "";
					switch(Player.User.Language)
					{
						case "pl": MSG = "$fd0Zdominuj terytorium i wzywaj posiłki przez zdobywanie stref!";
						case "fr": MSG = "$fd0Prends le contrôle du territoire et ranime tes coéquipiers en capturant les poles !";
						case "ru": MSG = "$fd0Контролируйте территорию и возрождайте товарищей по команде путём захвата флагов!";
						case "it": MSG = "$fd0Domina il territorio e chiama i rinforzi attraverso catturare delle zone!";
						case "de": MSG = "$fd0Herrsche über das Gebiet und erlöse teamkameraden durch Erobern der Pfähle!";
						default: MSG = "$fd0Control territory and revive teammates by capturing the poles!";
					} 
					Message::SendStatusMessage(Player, MSG, 4000, 0);
					declare UI <=> UIManager.GetUI(Player);
					if (UI != Null) 
					{
						/*ActionLoad(Player, CSmMode::EActionSlot::Slot_C, G_CustomStrafe);
						ActionBind(Player, CSmMode::EActionSlot::Slot_C, CSmMode::EActionInput::Consumable1);*/
						declare netread Net_SecondaryWeapon for UI = 1;
						switch (Net_SecondaryWeapon) 
						{
							case 1: //Soldier
							{
								ActionBind(Player, CSmMode::EActionSlot::Slot_B, CSmMode::EActionInput::None);
								SetPlayerWeapon(Player, CSmMode::EWeapon::Rocket, False);
								SetPlayerAmmoMax(Player, CSmMode::EWeapon::Rocket, C_RocketsAmmo);
								Player.StaminaMax = C_StaminaWith1Weapon;
								Player.StaminaGain = C_StaminaWith1Weapon;
								Player.SpeedPower = C_SpeedWith1Weapon;
								Player.AmmoGain = 1.0;
								SecondaryWeapon = 1;
							}
							case 2: // Ninja
							{
								// Action MAKER
								ActionLoad(Player, CSmMode::EActionSlot::Slot_B, G_CustomBounceRocket);
    							ActionBind(Player, CSmMode::EActionSlot::Slot_B, CSmMode::EActionInput::Weapon);
								Player.StaminaMax = C_StaminaWith1Weapon;
								Player.StaminaGain = C_StaminaWith1Weapon;
								Player.SpeedPower = C_SpeedWith1Weapon;
								SecondaryWeapon = 2;
							}
							case 3: // Commando
							{
								// Action MAKER
								ActionLoad(Player, CSmMode::EActionSlot::Slot_B, G_CustomElectricPistol);
    							ActionBind(Player, CSmMode::EActionSlot::Slot_B, CSmMode::EActionInput::Weapon);
								Player.StaminaMax = C_StaminaWith1Weapon;
								Player.StaminaGain = C_StaminaWith1Weapon;
								Player.SpeedPower = C_SpeedWith1Weapon;
								SecondaryWeapon = 3;
							}
							default: //basic
							{
								ActionBind(Player, CSmMode::EActionSlot::Slot_B, CSmMode::EActionInput::None);
								SetPlayerWeapon(Player, CSmMode::EWeapon::Rocket, False);
								SetPlayerAmmoMax(Player, CSmMode::EWeapon::Rocket, C_RocketsAmmo);
								Player.StaminaMax = C_StaminaWith1Weapon;
								Player.StaminaGain = C_StaminaWith1Weapon;
								Player.SpeedPower = C_SpeedWith1Weapon;
								Player.AmmoGain = 1.0;
								SecondaryWeapon = 1;
							}
						}
						G_SecondaryWeapons[Player.Login] = SecondaryWeapon;
						declare netwrite Integer[Text] Net_SecondaryWeapons for UI;
						Net_SecondaryWeapons = G_SecondaryWeapons;
					}
					else
					{
						SetPlayerWeapon(Player, CSmMode::EWeapon::Rocket, False);
						SetPlayerAmmoMax(Player, CSmMode::EWeapon::Rocket, C_RocketsAmmo);
						Player.StaminaMax = C_StaminaWith1Weapon;
						Player.StaminaGain = C_StaminaWith1Weapon;
						Player.SpeedPower = C_SpeedWith1Weapon;
						Player.AmmoGain = 1.0;
						SecondaryWeapon = 1;
					}
					Player.Armor = SpawnArmor;
					Player.ArmorMax = SpawnArmor;
				}
				else log(Now^">Wrong map, missing Spawn2");
			}
		}
	}		
}

// Timer management
if (G_RoundTime > 0) 
{
	// End of the round
	if (Now == EndTime) 
	{
		foreach (Player in Players)
		{
			declare SpawnTicket for Player = 0;
			SpawnTicket = 0;
			declare SpawnArmor for Player = 100;
			SpawnArmor = 0;
		}
		SM::UnspawnAllPlayers();
		Message::CleanBigMessages();
		Message::SendBigMessage(TextLib::Compose(_("Time limit reached!")), 4000, 0);
		Layers::Update("Progression", UpdateLayerProgression(0));
		LT_HidePlayersLists();
		declare Integer Points1 = 0;
		declare Integer Points2 = 0;
		switch(G_ZoneClanList[1])
		{
			case 1: Points1+=1;
			case 2: Points2+=1;
		}
		switch(G_ZoneClanList[2])
		{
			case 1: Points1+=1;
			case 2: Points2+=1;
		}
		switch(G_ZoneClanList[3])
		{
			case 1: Points1+=1;
			case 2: Points2+=1;
		}
		if(Points1 > Points2)
		{
			Victory::SetRoundWinnerIfNoWinner(1);
			RoundClanWinner = 1;
		}	
		else if(Points2 > Points1)
		{
			Victory::SetRoundWinnerIfNoWinner(2);
			RoundClanWinner = 2;
		}
		else
		{
			if(S_FinalRoundExceptDraw && MB_SectionRoundNb == S_MapPointsLimit*2+1)
			{
				declare AllPoints1 = 0;
				declare AllPoints2 = 0;
				foreach(Player in Players)
				{
					if(Player.CurrentClan == 1) AllPoints1 += Player.Score.RoundPoints;
					else if(Player.CurrentClan == 2) AllPoints2 += Player.Score.RoundPoints;
					
					if(AllPoints1 > AllPoints2)
					{
						Victory::SetRoundWinnerIfNoWinner(1);
						RoundClanWinner = 1;
					}
					else if(AllPoints2 > AllPoints1)
					{
						Victory::SetRoundWinnerIfNoWinner(2);
						RoundClanWinner = 2;
					}
					else
					{
						declare ran = MathLib::Rand(1, 2);
						Victory::SetRoundWinnerIfNoWinner(ran);
					}
				}
			}
			else
			{
				Victory::SetRoundDrawIfNoWinner();
				RoundClanWinner = 0;
			}	
		}	
		MB_StopRound = True;
	}
}

// Poles management
foreach (LandmarkGauge in MapLandmarks_Gauge) 
{
	if(LandmarkGauge.Sector != Null)
	{
		if(LandmarkGauge.Tag == "Zone A")
		{
			if (LandmarkGauge.Sector.PlayersIds.count > 0) 
			{
				foreach (PlayerId in LandmarkGauge.Sector.PlayersIds) 
				{
					declare Player <=> Players[PlayerId];
					if (FirstOnGoal != NullId && !LandmarkGauge.Sector.PlayersIds.exists(FirstOnGoal) && LandmarkGauge.Gauge.ValueReal != 0.) FirstOnGoal = NullId;
					if (FirstOnGoal == NullId) FirstOnGoal = PlayerId;
					PlayerCountA[Player.CurrentClan] += 1;
				}
			}
		}
		if(LandmarkGauge.Tag == "Zone B")
		{
			if (LandmarkGauge.Sector.PlayersIds.count > 0) 
			{
				foreach (PlayerId in LandmarkGauge.Sector.PlayersIds) 
				{
					declare Player <=> Players[PlayerId];
					if (FirstOnGoal != NullId && !LandmarkGauge.Sector.PlayersIds.exists(FirstOnGoal) && LandmarkGauge.Gauge.ValueReal != 0.) FirstOnGoal = NullId;
					if (FirstOnGoal == NullId) FirstOnGoal = PlayerId;
					PlayerCountB[Player.CurrentClan] += 1;
				}
			}
		}
		if(LandmarkGauge.Tag == "Zone C")
		{
			if (LandmarkGauge.Sector.PlayersIds.count > 0) 
			{
				foreach (PlayerId in LandmarkGauge.Sector.PlayersIds) 
				{
					declare Player <=> Players[PlayerId];
					if (FirstOnGoal != NullId && !LandmarkGauge.Sector.PlayersIds.exists(FirstOnGoal) && LandmarkGauge.Gauge.ValueReal != 0.) FirstOnGoal = NullId;
					if (FirstOnGoal == NullId) FirstOnGoal = PlayerId;
					PlayerCountC[Player.CurrentClan] += 1;
				}
			}
		}						
	}
}

foreach (LandmarkGauge in MapLandmarks_Gauge) 
{
	if(LandmarkGauge.Sector != Null)
	{
		if(LandmarkGauge.Tag == "Zone A")
		{
			if(PlayerCountA[1] > 0 || PlayerCountA[2] > 0)
			{
				if (LandmarkGauge.Gauge.Clan == 0) 
				{
					if (PlayerCountA[1] > PlayerCountA[2]) LandmarkGauge.Gauge.Clan = 1;
					else if (PlayerCountA[2] > PlayerCountA[1]) LandmarkGauge.Gauge.Clan = 2;
				}
				// Capturing
				if (PlayerCountA[LandmarkGauge.Gauge.Clan] > PlayerCountA[3-LandmarkGauge.Gauge.Clan] && !LandmarkGauge.Gauge.Captured) 
					LandmarkGauge.Gauge.Speed = 2 + PlayerCountA[LandmarkGauge.Gauge.Clan] - PlayerCountA[3-LandmarkGauge.Gauge.Clan];
				// Opposing
				else if (PlayerCountA[3-LandmarkGauge.Gauge.Clan] > PlayerCountA[LandmarkGauge.Gauge.Clan]) 
				{
					LandmarkGauge.Gauge.Speed = -1 - PlayerCountA[3-LandmarkGauge.Gauge.Clan] + PlayerCountA[LandmarkGauge.Gauge.Clan];
					if (LandmarkGauge.Gauge.Value == 0.)
					{
						UpdateMarker();
						LandmarkGauge.Gauge.Clan = 3-LandmarkGauge.Gauge.Clan;
						G_ZoneClanList[1] = 0;
						//FirstOnGoal == NullId;
					}
				} 
				// Draw
				else {
					LandmarkGauge.Gauge.Speed = 0;
				}
			}
			// Regeneration
			else if(LandmarkGauge.Gauge.Clan != 0 && G_ZoneClanList[1] == LandmarkGauge.Gauge.Clan && LandmarkGauge.Gauge.ValueReal <= 1.) LandmarkGauge.Gauge.Speed = 1;
			else LandmarkGauge.Gauge.Speed = 0;
			// Captured
			if (LandmarkGauge.Gauge.Value >= LandmarkGauge.Gauge.Max && LandmarkGauge.Gauge.Clan != G_ZoneClanList[1]) 
			{
				LandmarkGauge.Gauge.Captured = True;
				LandmarkGauge.Gauge.Value = LandmarkGauge.Gauge.Max;
				// Give bonus to timer and manage only once
				if (G_RoundTime > 0 && G_RoundTimeBonus > 0)
				{
					TempGoalNb += 1;
					if(TempGoalNb == 1)
					{
						EndTime += (G_RoundTimeBonus*1000);
						G_ZoneClanList[1] = LandmarkGauge.Gauge.Clan;
						UpdateMarker();
						UpdateLayerScoresTable(C_SequencePlaying);
					}
				}

				UpdateBasesColors();
				if(LandmarkGauge.Sector.PlayersIds.count > 0)
				{
					foreach (PlayerId in LandmarkGauge.Sector.PlayersIds) 
					{
						if (Players.existskey(PlayerId) && Players[PlayerId].Score != Null) 
						{
							declare Player <=> Players[PlayerId];
							Player.Armor += 200;
							Score::AddPoints(Player, 5);	
						}
					}
				}
				
				if (Players.existskey(FirstOnGoal)) 
				{
					foreach(Player in Players)
					{
						if(Player.CurrentClan == G_ZoneClanList[1] && Player.SpawnStatus == CSmPlayer::ESpawnStatus::NotSpawned)
						{
							UnspawnPlayer(Player);
							if(G_ZoneClanList[1] == 1)
 							{
 								declare SpawnTicket for Player = 0;
								SpawnTicket = 1;
 							}
							else if(G_ZoneClanList[1] == 2) 
							{
								declare SpawnTicket for Player = 0;
								SpawnTicket = 1;
							}	
						}		
					}
					if(G_ZoneClanList[1] > 0)
					{
						UIManager.UIAll.SendNotice(
						TextLib::Compose(_("$<%1$> captured Zone A"), Teams[G_ZoneClanList[1]-1].ColorizedName), 
						CUIConfig::ENoticeLevel::Default , Null, 
						CUIConfig::EAvatarVariant::Default, 
						CUIConfig::EUISound::Capture, 0
						);
						Message::CleanBigMessages();
						foreach(Player in Players)
						{
							declare MSG = "";
							switch(Player.User.Language)
							{
								case "pl": MSG = TextLib::Compose(_("$AAAStrefa A$g przejęta przez $<%1$>!"), Teams[G_ZoneClanList[1]-1].ColorizedName);
								case "fr": MSG = TextLib::Compose(_("$AAAZone A$g contrôlée par $<%1$>!"), Teams[G_ZoneClanList[1]-1].ColorizedName);
								case "ru": MSG = TextLib::Compose(_("$AAAЗона A$g контролируется $<%1$>!"), Teams[G_ZoneClanList[1]-1].ColorizedName);
								case "it": MSG = TextLib::Compose(_("$AAALa zona A$g Presa da $<%1$>!"), Teams[G_ZoneClanList[1]-1].ColorizedName);
								case "de": MSG = TextLib::Compose(_("$AAAZone A$g wird von $<%1$> kontrolliert!"), Teams[G_ZoneClanList[1]-1].ColorizedName);
								default: MSG = TextLib::Compose(_("$AAAZone A$g is controlled by $<%1$>!"), Teams[G_ZoneClanList[1]-1].ColorizedName);
							} 
							Message::SendBigMessage(Player, MSG, 3000, 0);
						}	
						foreach(Spectator in Spectators)
						{
							declare MSG = "";
							switch(Spectator.User.Language)
							{
								case "pl": MSG = TextLib::Compose(_("$AAAStrefa A$g przejęta przez $<%1$>!"), Teams[G_ZoneClanList[1]-1].ColorizedName);
								case "fr": MSG = TextLib::Compose(_("$AAAZone A$g contrôlée par $<%1$>!"), Teams[G_ZoneClanList[1]-1].ColorizedName);
								case "ru": MSG = TextLib::Compose(_("$AAAЗона A$g контролируется $<%1$>!"), Teams[G_ZoneClanList[1]-1].ColorizedName);
								case "it": MSG = TextLib::Compose(_("$AAALa zona A$g Presa da $<%1$>!"), Teams[G_ZoneClanList[1]-1].ColorizedName);
								case "de": MSG = TextLib::Compose(_("$AAAZone A$g wird von $<%1$> kontrolliert!"), Teams[G_ZoneClanList[1]-1].ColorizedName);
								default: MSG = TextLib::Compose(_("$AAAZone A$g is controlled by $<%1$>!"), Teams[G_ZoneClanList[1]-1].ColorizedName);
							} 
							Message::SendBigMessage(Spectator, MSG, 4000, 0);
						}
					}
				}
			}	
		}
		if(LandmarkGauge.Tag == "Zone B")
		{
			if(PlayerCountB[1] > 0 || PlayerCountB[2] > 0)
			{
				if (LandmarkGauge.Gauge.Clan == 0) 
				{
					if (PlayerCountB[1] > PlayerCountB[2]) LandmarkGauge.Gauge.Clan = 1;
					else if (PlayerCountB[2] > PlayerCountB[1]) LandmarkGauge.Gauge.Clan = 2;
				}
				// Capturing
				if (PlayerCountB[LandmarkGauge.Gauge.Clan] > PlayerCountB[3-LandmarkGauge.Gauge.Clan] && !LandmarkGauge.Gauge.Captured) 
					LandmarkGauge.Gauge.Speed = 2 + PlayerCountB[LandmarkGauge.Gauge.Clan] - PlayerCountB[3-LandmarkGauge.Gauge.Clan];
				// Opposing
				else if (PlayerCountB[3-LandmarkGauge.Gauge.Clan] > PlayerCountB[LandmarkGauge.Gauge.Clan]) 
				{
					LandmarkGauge.Gauge.Speed = -1 - PlayerCountB[3-LandmarkGauge.Gauge.Clan] + PlayerCountB[LandmarkGauge.Gauge.Clan];
					if (LandmarkGauge.Gauge.Value == 0.)
					{
						UpdateMarker();
						LandmarkGauge.Gauge.Clan = 3-LandmarkGauge.Gauge.Clan;
						G_ZoneClanList[2] = 0;
						//FirstOnGoal == NullId;
					}	
				} 
				// Draw
				else {
					LandmarkGauge.Gauge.Speed = 0;
				}
			} 
			// Regeneration
			else if(LandmarkGauge.Gauge.Clan != 0 && G_ZoneClanList[2] == LandmarkGauge.Gauge.Clan && LandmarkGauge.Gauge.ValueReal <= 1.) LandmarkGauge.Gauge.Speed = 1;
			else LandmarkGauge.Gauge.Speed = 0;
			// Captured
			if (LandmarkGauge.Gauge.Value >= LandmarkGauge.Gauge.Max && LandmarkGauge.Gauge.Clan != G_ZoneClanList[2]) 
			{
				LandmarkGauge.Gauge.Captured = True;
				LandmarkGauge.Gauge.Value = LandmarkGauge.Gauge.Max;
				// Give bonus to timer and manage only once
				if (G_RoundTime > 0 && G_RoundTimeBonus > 0)
				{
					TempGoalNb += 1;
					if(TempGoalNb == 1)
					{
						EndTime += (G_RoundTimeBonus*1000);
						G_ZoneClanList[2] = LandmarkGauge.Gauge.Clan;
						UpdateMarker();
						UpdateLayerScoresTable(C_SequencePlaying);
					}	
				}	

				UpdateBasesColors();
				if(LandmarkGauge.Sector.PlayersIds.count > 0)
				{
					foreach (PlayerId in LandmarkGauge.Sector.PlayersIds) 
					{
						if (Players.existskey(PlayerId) && Players[PlayerId].Score != Null) 
						{
							declare Player <=> Players[PlayerId];
							Player.Armor += 200;
							Score::AddPoints(Player, 5);
						}
					}
				}
				if (Players.existskey(FirstOnGoal)) 
				{
					foreach(Player in Players)
					{
						if(Player.CurrentClan == G_ZoneClanList[2] && Player.SpawnStatus == CSmPlayer::ESpawnStatus::NotSpawned)
						{
							UnspawnPlayer(Player);
							if(G_ZoneClanList[2] == 1)
 							{
 								declare SpawnTicket for Player = 0;
								SpawnTicket = 1;
 							}
							else if(G_ZoneClanList[2] == 2) 
							{
								declare SpawnTicket for Player = 0;
								SpawnTicket = 1;
							}	
						}		
					}
					if(G_ZoneClanList[2] > 0)
					{
						UIManager.UIAll.SendNotice(
						TextLib::Compose(_("$<%1$> captured Zone B"), Teams[G_ZoneClanList[2]-1].ColorizedName), 
						CUIConfig::ENoticeLevel::Default , Null, 
						CUIConfig::EAvatarVariant::Default, 
						CUIConfig::EUISound::Capture, 0
						);
						Message::CleanBigMessages();
		
						foreach(Player in Players)
						{
							declare MSG = "";
							switch(Player.User.Language)
							{
								case "pl": MSG = TextLib::Compose(_("$AAAStrefa B$g przejęta przez $<%1$>!"), Teams[G_ZoneClanList[2]-1].ColorizedName);
								case "fr": MSG = TextLib::Compose(_("$AAAZone B$g contrôlée par $<%1$>!"), Teams[G_ZoneClanList[2]-1].ColorizedName);
								case "ru": MSG = TextLib::Compose(_("$AAAЗона B$g контролируется $<%1$>!"), Teams[G_ZoneClanList[2]-1].ColorizedName);
								case "it": MSG = TextLib::Compose(_("$AAALa zona B$g Presa da $<%1$>!"), Teams[G_ZoneClanList[2]-1].ColorizedName);
								case "de": MSG = TextLib::Compose(_("$AAAZone B$g wird von $<%1$> kontrolliert!"), Teams[G_ZoneClanList[2]-1].ColorizedName);
								default: MSG = TextLib::Compose(_("$AAAZone B$g is controlled by $<%1$>!"), Teams[G_ZoneClanList[2]-1].ColorizedName);
							} 
							Message::SendBigMessage(Player, MSG, 3000, 0);
						}	
						foreach(Spectator in Spectators)
						{
							declare MSG = "";
							switch(Spectator.User.Language)
							{
								case "pl": MSG = TextLib::Compose(_("$AAAStrefa B$g przejęta przez $<%1$>!"), Teams[G_ZoneClanList[2]-1].ColorizedName);
								case "fr": MSG = TextLib::Compose(_("$AAAZone B$g contrôlée par $<%1$>!"), Teams[G_ZoneClanList[2]-1].ColorizedName);
								case "ru": MSG = TextLib::Compose(_("$AAAЗона B$g контролируется $<%1$>!"), Teams[G_ZoneClanList[2]-1].ColorizedName);
								case "it": MSG = TextLib::Compose(_("$AAALa zona B$g Presa da $<%1$>!"), Teams[G_ZoneClanList[2]-1].ColorizedName);
								case "de": MSG = TextLib::Compose(_("$AAAZone B$g wird von $<%1$> kontrolliert!"), Teams[G_ZoneClanList[2]-1].ColorizedName);
								default: MSG = TextLib::Compose(_("$AAAZone B$g is controlled by $<%1$>!"), Teams[G_ZoneClanList[2]-1].ColorizedName);
							} 
							Message::SendBigMessage(Spectator, MSG, 4000, 0);
						}
					}
				}
			}	
		}
		if(LandmarkGauge.Tag == "Zone C")
		{
			if(PlayerCountC[1] > 0 || PlayerCountC[2] > 0)
			{
				if (LandmarkGauge.Gauge.Clan == 0) 
				{
					if (PlayerCountC[1] > PlayerCountC[2]) LandmarkGauge.Gauge.Clan = 1;
					else if (PlayerCountC[2] > PlayerCountC[1]) LandmarkGauge.Gauge.Clan = 2;
				}
				// Capturing
				if (PlayerCountC[LandmarkGauge.Gauge.Clan] > PlayerCountC[3-LandmarkGauge.Gauge.Clan] && !LandmarkGauge.Gauge.Captured) 
					LandmarkGauge.Gauge.Speed = 2 + PlayerCountC[LandmarkGauge.Gauge.Clan] - PlayerCountC[3-LandmarkGauge.Gauge.Clan];
				// Opposing
				else if (PlayerCountC[3-LandmarkGauge.Gauge.Clan] > PlayerCountC[LandmarkGauge.Gauge.Clan]) 
				{
					LandmarkGauge.Gauge.Speed = -1 - PlayerCountC[3-LandmarkGauge.Gauge.Clan] + PlayerCountC[LandmarkGauge.Gauge.Clan];
					if (LandmarkGauge.Gauge.Value == 0.)
					{
						UpdateMarker();
						LandmarkGauge.Gauge.Clan = 3-LandmarkGauge.Gauge.Clan;
						G_ZoneClanList[3] = 0;
						//FirstOnGoal == NullId;
					}	
				} 
				// Draw
				else {
					LandmarkGauge.Gauge.Speed = 0;
				}
			} 
			// Regeneration
			else if(LandmarkGauge.Gauge.Clan != 0 && G_ZoneClanList[3] == LandmarkGauge.Gauge.Clan && LandmarkGauge.Gauge.ValueReal <= 1.) LandmarkGauge.Gauge.Speed = 1;
			else LandmarkGauge.Gauge.Speed = 0;
			// Captured
			if (LandmarkGauge.Gauge.Value >= LandmarkGauge.Gauge.Max && LandmarkGauge.Gauge.Clan != G_ZoneClanList[3]) 
			{
				LandmarkGauge.Gauge.Captured = True;
				LandmarkGauge.Gauge.Value = LandmarkGauge.Gauge.Max;
				// Give bonus to timer and manage only once
				if (G_RoundTime > 0 && G_RoundTimeBonus > 0)
				{
					TempGoalNb += 1;
					if(TempGoalNb == 1)
					{
						EndTime += (G_RoundTimeBonus*1000);
						G_ZoneClanList[3] = LandmarkGauge.Gauge.Clan;
						UpdateMarker();
						UpdateLayerScoresTable(C_SequencePlaying);
					}	
				}	

				UpdateBasesColors();
				if(LandmarkGauge.Sector.PlayersIds.count > 0)
				{
					foreach (PlayerId in LandmarkGauge.Sector.PlayersIds) 
					{
						if (Players.existskey(PlayerId) && Players[PlayerId].Score != Null) 
						{
							declare Player <=> Players[PlayerId];
							Player.Armor += 200;
							Score::AddPoints(Player, 5);
						}
					}
				}
				if (Players.existskey(FirstOnGoal)) 
				{
					foreach(Player in Players)
					{
						if(Player.CurrentClan == G_ZoneClanList[3] && Player.SpawnStatus == CSmPlayer::ESpawnStatus::NotSpawned)
						{
							UnspawnPlayer(Player);
							if(G_ZoneClanList[3] == 1)
 							{
 								declare SpawnTicket for Player = 0;
								SpawnTicket = 1;
 							}
							else if(G_ZoneClanList[3] == 2) 
							{
								declare SpawnTicket for Player = 0;
								SpawnTicket = 1;
							}	
						}		
					}
					if(G_ZoneClanList[3] > 0)
					{
						UIManager.UIAll.SendNotice(
							TextLib::Compose(_("$<%1$> captured Zone C"), Teams[G_ZoneClanList[3]-1].ColorizedName), 
							CUIConfig::ENoticeLevel::Default , Null, 
							CUIConfig::EAvatarVariant::Default, 
							CUIConfig::EUISound::Capture, 0
						);
						Message::CleanBigMessages();
						foreach(Player in Players)
						{
							declare MSG = "";
							switch(Player.User.Language)
							{
								case "pl": MSG = TextLib::Compose(_("$AAAStrefa C$g przejęta przez $<%1$>!"), Teams[G_ZoneClanList[3]-1].ColorizedName);
								case "fr": MSG = TextLib::Compose(_("$AAAZone C$g contrôlée par $<%1$>!"), Teams[G_ZoneClanList[3]-1].ColorizedName);
								case "ru": MSG = TextLib::Compose(_("$AAAЗона C$g контролируется $<%1$>!"), Teams[G_ZoneClanList[3]-1].ColorizedName);
								case "it": MSG = TextLib::Compose(_("$AAALa zona C$g Presa da $<%1$>!"), Teams[G_ZoneClanList[3]-1].ColorizedName);
								case "de": MSG = TextLib::Compose(_("$AAAZone C$g wird von $<%1$> kontrolliert!"), Teams[G_ZoneClanList[3]-1].ColorizedName);
								default: MSG = TextLib::Compose(_("$AAAZone C$g is controlled by $<%1$>!"), Teams[G_ZoneClanList[3]-1].ColorizedName);
							} 
							Message::SendBigMessage(Player, MSG, 3000, 0);
						}	
						foreach(Spectator in Spectators)
						{
							declare MSG = "";
							switch(Spectator.User.Language)
							{
								case "pl": MSG = TextLib::Compose(_("$AAAStrefa C$g przejęta przez $<%1$>!"), Teams[G_ZoneClanList[3]-1].ColorizedName);
								case "fr": MSG = TextLib::Compose(_("$AAAZone C$g contrôlée par $<%1$>!"), Teams[G_ZoneClanList[3]-1].ColorizedName);
								case "ru": MSG = TextLib::Compose(_("$AAAЗона C$g контролируется $<%1$>!"), Teams[G_ZoneClanList[3]-1].ColorizedName);
								case "it": MSG = TextLib::Compose(_("$AAALa zona C$g Presa da $<%1$>!"), Teams[G_ZoneClanList[3]-1].ColorizedName);
								case "de": MSG = TextLib::Compose(_("$AAAZone C$g wird von $<%1$> kontrolliert!"), Teams[G_ZoneClanList[3]-1].ColorizedName);
								default: MSG = TextLib::Compose(_("$AAAZone C$g is controlled by $<%1$>!"), Teams[G_ZoneClanList[3]-1].ColorizedName);
							} 
							Message::SendBigMessage(Spectator, MSG, 4000, 0);
						}
					}
				}
			}	
		}
	}
}

if(G_LastProgressUpdate + 800 < Now)
{
	G_LastProgressUpdate = Now;
	UpdateLayerScoresTable(C_SequencePlaying);
	Layers::Update("Progression", UpdateLayerProgression(0));
	Layers::Update("HUD", UpdateLayerHUD());
	G_PlayerCountA = PlayerCountA;
	G_PlayerCountB = PlayerCountB;
	G_PlayerCountC = PlayerCountC;

	G_PlayersAlive = [1 => 0, 2 => 0];
	
	foreach(Player in Players)
	{
		if(Player.Armor > 0) G_PlayersAlive[Player.CurrentClan] += 1;
	}	
	if(G_PlayersAlive[1] <= 0)
	{
		Victory::SetRoundWinnerIfNoWinner(2);
		RoundClanWinner = 2;
		MB_StopRound = True;
		LT_AnnounceEliminationMessage(0, 0);
	}
	else if(G_PlayersAlive[2] <= 0)
	{
		Victory::SetRoundWinnerIfNoWinner(1);
		RoundClanWinner = 1;
		MB_StopRound = True;
		LT_AnnounceEliminationMessage(1, 0);
	}
}	

// Spawn objects
SpawnWeaponItems();	

// Events
foreach (Event in PendingEvents) 
{
	// On player touches object
	if (Event.Type == CSmModeEvent::EType::OnPlayerTouchesObject)
	{
		if (Event.Player == Null) Discard(Event);
		else if (Event.Player != Null && Event.Player.SpawnStatus != CSmPlayer::ESpawnStatus::Spawned) Discard(Event);
		else 
		{
			PickUpObject(Event.Player, Event.Object);
			PassOn(Event);
		}
	}
	// On action event
	else if (Event.Type == CSmModeEvent::EType::OnActionEvent) 
	{
		if (Event.Player == Null) Discard(Event);
		else 
		{
			SwitchWeapon(Event.Player, Event.ActionInput);
			PassOn(Event);
		}		
	}
	// Armor empty
	else if (Event.Type == CSmModeEvent::EType::OnArmorEmpty && Event.Victim != Null) 
	{
		if (Event.Victim.Armor > 100)
		{
			declare SpawnArmor for Event.Victim = 100;
			SpawnArmor = Event.Victim.Armor - 100;
			declare SpawnTicket for Event.Victim = 0;
			SpawnTicket = 1;
		}
		else
		{
			declare SpawnTicket for Event.Victim = 0;
			SpawnTicket = 0;
			declare CurrentDeaths for Event.Victim.Score = 0;
			CurrentDeaths += 1;
			declare CurrentKills for Event.Shooter.Score = 0;
			CurrentKills += 1;
			if (G_PlayersAlive[Event.Victim.CurrentClan] > 1) 
			{
				declare SpawnArmor for Event.Victim = 100;
				SpawnArmor -= 100;

				//Remove primary weapon after elimination
				ActionBind(Event.Victim, CSmMode::EActionSlot::Slot_A, CSmMode::EActionInput::None);
				SetPlayerAmmoMax(Event.Victim, CSmMode::EWeapon::Laser, 0);
				SetPlayerAmmoMax(Event.Victim, CSmMode::EWeapon::Nucleus, 0);
				Event.Victim.AmmoGain = 0.;
				declare UI <=> UIManager.GetUI(Event.Victim);
				if (UI != Null) 
				{
					declare netwrite Net_PrimaryWeapon for UI = 0;
					Net_PrimaryWeapon = 0;
				}
				foreach(Player in Players)
				{
					declare UI <=> UIManager.GetUI(Player);
					if (UI != Null) 
					{
						declare netwrite Integer[Text] Net_PrimaryWeapons for UI;
						Net_PrimaryWeapons[Event.Victim.Login] = 0;
					}
				}

				declare PLeft = G_PlayersAlive[Event.Victim.CurrentClan]-1;
				if (PLeft <= 3) LT_AnnounceEliminationMessage(Event.Victim.CurrentClan-1, PLeft);
			}	
		}	
		XmlRpc::OnArmorEmpty(Event);
		PassOn(Event);
	}
	// Damage
	else if(Event.Type == CSmModeEvent::EType::OnHit && Event.Victim != Null) 
	{
		// Discard friendly fire
		if (Event.Shooter != Null && Event.Shooter.CurrentClan == Event.Victim.CurrentClan) {
			Discard(Event);
		} 
		else 
		{
			if(Event.WeaponNum == GetWeaponNum(CSmMode::EWeapon::Laser))
			{
				declare UI <=> UIManager.GetUI(Event.Shooter);
				if(UI != Null)
				{
					// Get distance
					declare Distance = MathLib::Distance(Event.Shooter.Position, Event.Victim.Position);
					LT_AnnounceHitDistance(Distance, Event.Shooter);
				}
				Event.Damage = 200;
				Event.ShooterPoints = 2;
			}		
			if (Event.Shooter != Event.Victim)
			{
				declare UI <=> UIManager.GetUI(Event.Shooter);
				if (UI != Null) 
				{
					Score::AddPoints(Event.Shooter, Event.Damage/100);
					---HeadshotFunctions---
					---AnnounceHeadshot---
				}
				if(Event.Victim.Armor - Event.Damage <= 0)
				{
					declare SpawnTicket for Event.Victim = 0;
					SpawnTicket = 0;
				}		
			}	
			//declare SpawnArmor for Event.Victim = 0;
			//SpawnArmor = Event.Victim.Armor - Event.Damage; 

			XmlRpc::OnHit(Event);
			PassOn(Event);
		}
	}
	// Action Maker Events
	else if(Event.Type == CSmModeEvent::EType::OnActionCustomEvent)
	{
		if(Event.Shooter == Null || Event.Victim == Null) Discard(Event);
		// Discard friendly fire
		if (Event.Param1 == "damage" && Event.Victim != Null && Event.Shooter != Null && Event.Shooter.CurrentClan == Event.Victim.CurrentClan) Discard(Event);
		else if(Event.Param1 == "damage" && Event.Victim != Null && Event.Shooter != Null && Event.Victim != Event.Shooter) 
		{
			declare Damage = TextLib::ToInteger(Event.Param2[0]);
           	declare Points = Damage / 100;
			declare UI <=> UIManager.GetUI(Event.Shooter);
			if (UI != Null) 
			{
				---HeadshotFunctions---
				---ActionMakerAnnounceHeadshot---
			}
            RemovePlayerArmor(Event.Victim, Damage, Event.Shooter, Points);
            Score::AddPoints(Event.Shooter, Points);
          	if(Event.Victim.Armor - Damage <= 0)
			{
				declare SpawnTicket for Event.Victim = 0;
				SpawnTicket = 0;
			}	
            PassOn(Event);
        }  
	}
	// On near miss
	else if(Event.Type == CSmModeEvent::EType::OnNearMiss && Event.Victim != Null) 
	{
		---OnNearMiss---
	}
	// Give Up
	else if (Event.Type == CSmModeEvent::EType::OnPlayerRequestRespawn && Event.Player != Null) 
	{
		declare Message = "";
		declare SpawnArmor for Event.Player = 100;
		SpawnArmor = Event.Player.Armor - 200;
		declare SpawnTicket for Event.Player = 0;
		if(SpawnArmor >= 100) SpawnTicket = 1;
		declare CurrentDeaths for Event.Player.Score = 0;
		CurrentDeaths += 1;

		//Remove primary weapon after elimination
		ActionBind(Event.Player, CSmMode::EActionSlot::Slot_A, CSmMode::EActionInput::None);
		SetPlayerAmmoMax(Event.Player, CSmMode::EWeapon::Laser, 0);
		SetPlayerAmmoMax(Event.Player, CSmMode::EWeapon::Nucleus, 0);
		Event.Player.AmmoGain = 0.;
		declare UI <=> UIManager.GetUI(Event.Player);
		if (UI != Null) 
		{
			declare netwrite Net_PrimaryWeapon for UI = 0;
			Net_PrimaryWeapon = 0;
		}
		foreach(Player in Players)
		{
			declare UI <=> UIManager.GetUI(Player);
			if (UI != Null) 
			{
				declare netwrite Integer[Text] Net_PrimaryWeapons for UI;
				Net_PrimaryWeapons[Event.Player.Login] = 0;
			}
		}
		if(G_PlayersAlive[Event.Player.CurrentClan] > 1) 
		{
			declare PLeft = G_PlayersAlive[Event.Player.CurrentClan];
			if(PLeft <= 3) LT_AnnounceEliminationMessage(Event.Player.CurrentClan-1, PLeft);
	 	}
		XmlRpc::OnPlayerRequestRespawn(Event);
		PassOn(Event);
	} 
	// Goal Captured
	else if (Event.Type == CSmModeEvent::EType::OnCapture && Event.Landmark != Null) {
		Discard(Event);
	}
	// Other events
	else {
		PassOn(Event);
	}
}

// Check end round conditions
if(G_ZoneClanList[1] == 1 && G_ZoneClanList[2] == 1 && G_ZoneClanList[3] == 1)
{
	Victory::SetRoundWinnerIfNoWinner(1);
	RoundClanWinner = 1;
	MB_StopRound = True;
	foreach(Player in Players)
	{
		declare MSG = "";
		switch(Player.User.Language)
		{
			case "pl": MSG = "zdobyli wszystkie cele.";
			case "fr": MSG = "a capturé tous les objectifs.";
			case "ru": MSG = "захватил все флаги.";
			case "it": MSG = "Hanno catturato tutte le obiettivi.";
			case "de": MSG = "hat alle Ziele erobert.";
			default: MSG = "captured all goals.";
		}
		Message::SendBigMessage(Player, TextLib::Compose(_("$<%1$> %2"), Teams[0].ColorizedName, MSG), 3500, 0, CUIConfig::EUISound::VictoryPoint, 2);
	}
	foreach(Spectator in Spectators)
	{
		declare MSG = "";
		switch(Spectator.User.Language)
		{
			case "pl": MSG = "zdobyli wszystkie cele.";
			case "fr": MSG = "a capturé tous les objectifs.";
			case "ru": MSG = "захватил все флаги.";
			case "it": MSG = "Hanno catturato tutte le obiettivi.";
			case "de": MSG = "hat alle Ziele erobert.";
			default: MSG = "captured all goals.";
		}
		Message::SendBigMessage(Spectator, TextLib::Compose(_("$<%1$> %2"), Teams[0].ColorizedName, MSG), 3500, 0, CUIConfig::EUISound::VictoryPoint, 2);
	}
}
else if(G_ZoneClanList[1] == 2 && G_ZoneClanList[2] == 2 && G_ZoneClanList[3] == 2)
{
	Victory::SetRoundWinnerIfNoWinner(2);
	RoundClanWinner = 2;
	MB_StopRound = True;
	foreach(Player in Players)
	{
		declare MSG = "";
		switch(Player.User.Language)
		{
			case "pl": MSG = "zdobyli wszystkie cele.";
			case "fr": MSG = "a capturé tous les objectifs.";
			case "ru": MSG = "захватил все флаги.";
			case "it": MSG = "Hanno catturato tutte le obiettivi.";
			case "de": MSG = "hat alle Ziele erobert.";
			default: MSG = "captured all goals.";
		}
		Message::SendBigMessage(Player, TextLib::Compose(_("$<%1$> %2"), Teams[1].ColorizedName, MSG), 3500, 0, CUIConfig::EUISound::VictoryPoint, 2);
	}
	foreach(Spectator in Spectators)
	{
		declare MSG = "";
		switch(Spectator.User.Language)
		{
			case "pl": MSG = "zdobyli wszystkie cele.";
			case "fr": MSG = "a capturé tous les objectifs.";
			case "ru": MSG = "захватил все флаги.";
			case "it": MSG = "Hanno catturato tutte le obiettivi.";
			case "de": MSG = "hat alle Ziele erobert.";
			default: MSG = "captured all goals.";
		}
		Message::SendBigMessage(Spectator, TextLib::Compose(_("$<%1$> %2"), Teams[1].ColorizedName, MSG), 3500, 0, CUIConfig::EUISound::VictoryPoint, 2);
	}
}
// Force a warm up
if (G_Override_NeedWarmUp) MB_StopRound = True;
***

***EndRound***
***
// Skip the round end sequence if a warm up was requested
// And restore the round to its previous state
if (G_Override_NeedWarmUp) {
	MB_SectionRoundNb -= 1;
	
	foreach (Score in Scores) 
	{
		declare CurrentKills for Score = 0;
		declare CurrentDeaths for Score = 0;
		declare CurrentMVP for Score = 0;
	
		declare Save_CurrentKills	for Score = CurrentKills;
		declare Save_CurrentDeaths	for Score = CurrentDeaths;
		declare Save_CurrentMVP		for Score = CurrentMVP;
	
		CurrentKills 	= Save_CurrentKills;
		CurrentDeaths	= Save_CurrentDeaths;
		CurrentMVP		= Save_CurrentMVP;
	}
	
	LT_DetachPlayersLists();
	Layers::Update("Progression", UpdateLayerProgression(1));
	UpdateLayerScoresTable(C_SequencePause);
	UpdateHeader();
	continue;
}
LT_HidePlayersLists();
Layers::Detach("Markers");
Layers::Update("Progression", UpdateLayerProgression(0));
// Search for MVP
foreach(Player in Players)
{
	if(Player.Score.RoundPoints > BestRoundScore && Player.Score.RoundPoints > 0)
	{
		BestRoundScore = Player.Score.RoundPoints;
		MVP = Player;
	}	
}
if(MVP != Null && RoundClanWinner != 0)
{
	declare CurrentMVP for MVP.Score = 0;
	CurrentMVP += 1;
	ST2::SetColValue("ST_MVP", MVP.Score, "$fc0"^TextLib::ToText(CurrentMVP));
}	
Sound::PlaySound("file://Media/Sounds/FireFight/roundend.ogg", -5., 400);
FF_Sleep(1500);
SM::UnspawnAllPlayers();
FF_Sleep(1000);
//DestroyMinimap();
UIManager.UIAll.UISequence = CUIConfig::EUISequence::EndRound;
UIManager.UIAll.MarkersXML = "";
Victory::RoundEnd();
EndTime = -1;
if(RoundClanWinner > 0) G_ClansMapPoints[RoundClanWinner] += 1;
UpdateLayerScoresTable(C_SequencePlaying);
Message::CleanAllMessages();
Layers::Update("Progression", UpdateLayerProgression(1));
LT_DetachPlayersLists();
Layers::Detach("HUD");
if(MB_SectionRoundNb % 5 == 0) DisplayNotice();
UpdateHeader();
LT_AnnounceRoundWin(RoundClanWinner);
UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::ForcedVisible;
FF_Sleep(6500);
UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::Normal;
Score::RoundEnd();
Message::CleanAllMessages();

// Run warmup if there's not enough players
WarmUp2::Clean();
if (ClansNbPlayers[1] <= 0 || (WarmUp2::GroupExists("Clan1") && WarmUp2::GetPlayersNb("Clan1") <= 0)) DoWarmUp();
else if (ClansNbPlayers[2] <= 0 || (WarmUp2::GroupExists("Clan2") && WarmUp2::GetPlayersNb("Clan2") <= 0)) DoWarmUp();

if(MB_SectionRoundNb == G_MapPointsLimit*2)
{
	if(G_ClansMapPoints[1] > G_ClansMapPoints[2])
	{
		ClanMapWinner = 1;
		MB_StopMap = True;
	}
	else if(G_ClansMapPoints[2] > G_ClansMapPoints[1])
	{
		ClanMapWinner = 2;
		MB_StopMap = True;
	}
	else
	{
		if(!S_FinalRoundExceptDraw)
		{
			ClanMapWinner = 0;
			MB_StopMap = True;
		}
		else
		{
			G_MapPointsLimit = G_ClansMapPoints[1]+1;
		}
	}
}
if(G_ClansMapPoints[1] > G_MapPointsLimit)
{
	ClanMapWinner = 1;
	MB_StopMap = True;
}
else if(G_ClansMapPoints[2] > G_MapPointsLimit)
{
	ClanMapWinner = 2;
	MB_StopMap = True;
}
if(MB_SectionRoundNb == G_MapPointsLimit)
{
	---AnnounceHalfTime---
	FF_Sleep(5000);
}
else if(MB_SectionRoundNb == G_MapPointsLimit*2 && S_FinalRoundExceptDraw && ClanMapWinner == 0)
{
	---AnnounceFinalRound---
	FF_Sleep(5000);
}
Message::CleanAllMessages();
***

***EndMap***
***
/*foreach (Score in Scores) 
{
	declare PrevPoints for Score = 0;
	PrevPoints = Score.Points;
	declare CurrentDeaths for Score = 0;
	declare CurrentMVP for Score = 0;
	Score.LadderMatchScoreValue = MathLib::ToReal(Score.Points + (CurrentMVP*3) - CurrentDeaths);
	// Winner
	if (Score.LadderClan == ClanMapWinner) {
		Score.Points = 4;
	}
	// Looser
	else if (Score.LadderClan == 3 - ClanMapWinner) {
		Score.Points = 1;
	}
	// Other
	else {
		Score.Points = 0;
		Score.LadderMatchScoreValue = 0.;
	}
}
Ladder_SetResultsVersion(1);
Score::MatchEnd(True);
foreach (Score in Scores) {
	declare PrevPoints for Score = 0;
	Score.Points = PrevPoints;
}*/

foreach (Player in Players) {
	if(Player.CurrentClan == ClanMapWinner && Player.Score != Null) {
		declare LadderBonus for Player.Score = 0;
		declare CurrentMVP for Player.Score = 0;
		LadderBonus += CurrentMVP*10;
	}
	else if(Player.CurrentClan != ClanMapWinner && Player.Score != Null) {
		declare LadderBonus for Player.Score = 0;
		declare CurrentMVP for Player.Score = 0;
		LadderBonus -= 40 - (CurrentMVP*5);
	}
}
foreach (Score in Scores) {
	declare LadderBonus for Score = 0;
	Score.Points += LadderBonus;
}
Score::MatchEnd();
foreach (Score in Scores) {
	declare LadderBonus for Score = 0;
	Score.Points -= LadderBonus;
}
ObjectDestroyAll();
Victory::MatchEnd();
Layers::Detach("Progression");
Message::SendStatusMessage(TextLib::Compose(_("Map result: %1 %2 - %3 %4"),Teams[0].ColorizedName,TextLib::ToText(G_ClansMapPoints[1]),TextLib::ToText(G_ClansMapPoints[2]),Teams[1].ColorizedName), 6000, 0, CUIConfig::EUISound::EndRound, 0);
if (ClanMapWinner > 0)
{
	Message::SendBigMessage(TextLib::Compose(_("%1 wins the map!"), Teams[ClanMapWinner - 1].ColorizedName), 6000, 0);
	ClanScores[ClanMapWinner] += 1;
	UpdateHeader();
}	
else Message::SendBigMessage(TextLib::Compose(_("|Match|Draw")), 6000, 0, CUIConfig::EUISound::Silence, 0);
UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::ForcedVisible;
UIManager.UIAll.UISequence = CUIConfig::EUISequence::Outro;
FF_Sleep(6000);
UpdateLayerScoresTable(C_SequencePodium);
UIManager.UIAll.UISequence = CUIConfig::EUISequence::Podium;
if(ClanScores[1] >= G_MapsToWin && ClanScores[1] > ClanScores[2]) 
{
	Message::SendBigMessage(TextLib::Compose(_("%1 wins the match!"), Teams[0].ColorizedName), 5000, 0);
	Message::SendStatusMessage(TextLib::Compose(_("Match result: %1 %2 - %3 %4"),Teams[0].ColorizedName,TextLib::ToText(ClanScores[1]),TextLib::ToText(ClanScores[2]),Teams[1].ColorizedName), 6000, 0, CUIConfig::EUISound::EndRound, 0);
	FF_Sleep(5000);
}	
else if(ClanScores[2] >= G_MapsToWin && ClanScores[2] > ClanScores[1]) 
{
	Message::SendBigMessage(TextLib::Compose(_("%1 wins the match!"), Teams[1].ColorizedName), 5000, 0);
	Message::SendStatusMessage(TextLib::Compose(_("Match result: %1 %2 - %3 %4"),Teams[0].ColorizedName,TextLib::ToText(ClanScores[1]),TextLib::ToText(ClanScores[2]),Teams[1].ColorizedName), 6000, 0, CUIConfig::EUISound::EndRound, 0);
	FF_Sleep(5000);
}	
FF_Sleep(4500);
UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::Normal;
Message::CleanAllMessages();
***

***EndServer***
***
Layers::Destroy("Progression");
Layers::Destroy("ProgressBar");
LT_DestroyLoadoutsLayers();
Layers::Destroy("RulesReminder");
Layers::Destroy("ScoresTable");
CustomUI::Unload();
CDraft::EndServer();
WarmUp2::Unload();
Layers::Destroy("Markers");
SpawnScreen::DestroyRules();
***

// Force Clublinks if #Command vote passed
Void ForceClublinkReload() {
	if (!G_Override_ForceClublinkReload) return;
	G_Override_ForceClublinkReload = False;
	
	Clublink::ResetAll();
	Clublink::DefineTeamAuto(True);
}

// Update the score table manialink string.
Void UpdateLayerScoresTable(Integer _Mode) 
{
	declare Logins			= Text[Integer];
	declare Kills			= Integer[Integer];
	declare Deaths			= Integer[Integer];
	declare MVP				= Integer[Integer];
	declare ReadyState		= Boolean[Integer];

declare ClansOrders = [1 => WarmUp2::GetGroup("Clan1"), 2 => WarmUp2::GetGroup("Clan2")];
for (I, 1, 2) {
	declare J = 1;
	foreach (Slot => Id in ClansOrders[I]) {
		if (Players.existskey(Id)) {
			declare Key = J+((I-1)*5);
			declare Player <=> Players[Id];
			Logins[Key] = Player.Login;
			if (Player.Score != Null && _Mode != C_SequenceWarmUp) {
				declare CurrentKills for Player.Score = 0;
				declare CurrentDeaths for Player.Score = 0;
				declare CurrentMVP for Player.Score = 0;
				Kills[Key] = CurrentKills;
				Deaths[Key] = CurrentDeaths;
				MVP[Key] = CurrentMVP;
			}
			ReadyState[Key] = WarmUp2::IsReady(Player);
		}
		J += 1;
	}
}

foreach (Player in AllPlayers) 
{
	declare UI <=> UIManager.GetUI(Player);
	if (UI == Null) continue;
	
	declare netwrite Integer			Net_LayerST_Update			for UI;
	declare netwrite Text[Integer]		Net_LayerST_Logins			for UI;
	declare netwrite Integer[Integer]	Net_LayerST_Kills			for UI;
	declare netwrite Integer[Integer]	Net_LayerST_Deaths			for UI;
	declare netwrite Integer[Integer]	Net_LayerST_MVP				for UI;
	declare netwrite Boolean[Integer]	Net_LayerST_Ready			for UI;
	declare netwrite Integer			Net_LayerST_Mode			for UI;
	
	Net_LayerST_Update			= Now;
	Net_LayerST_Logins			= Logins;
	Net_LayerST_Kills			= Kills;
	Net_LayerST_Deaths			= Deaths;
	Net_LayerST_MVP				= MVP;
	Net_LayerST_Ready			= ReadyState;
	Net_LayerST_Mode			= _Mode;
}
}

Void UpdateHeader() {
	UIManager.UIAll.OverlayScoreSummary = True;
	declare PlayerClan1Id = NullId;
	declare PlayerClan2Id = NullId;
	
	foreach (Player in Players) {
		if (PlayerClan1Id == NullId && Player.CurrentClan == 1) PlayerClan1Id = Player.Id;
		if (PlayerClan2Id == NullId && Player.CurrentClan == 2) PlayerClan2Id = Player.Id;
		if (PlayerClan1Id != NullId && PlayerClan2Id != NullId) break;
	}
	
	if (PlayerClan1Id != NullId) UIManager.UIAll.ScoreSummary_Player1 = PlayerClan1Id;
	else UIManager.UIAll.ScoreSummary_Player1 = NullId;
	if (PlayerClan2Id != NullId) UIManager.UIAll.ScoreSummary_Player2 = PlayerClan2Id;
	else UIManager.UIAll.ScoreSummary_Player2 = NullId;
	UIManager.UIAll.ScoreSummary_Points1		= G_ClansMapPoints[1];
	//UIManager.UIAll.ScoreSummary_Gauge1			= MathLib::ToReal((G_ClansMapPoints[1]/G_MapPointsLimit)*100);
	UIManager.UIAll.ScoreSummary_MatchPoints1	= ClanScores[1];
	UIManager.UIAll.ScoreSummary_Points2		= G_ClansMapPoints[2];
	UIManager.UIAll.ScoreSummary_MatchPoints2	= ClanScores[2];
	//UIManager.UIAll.ScoreSummary_Gauge2			= MathLib::ToReal((G_ClansMapPoints[2]/G_MapPointsLimit)*100);
}

/// Manage #Command
Void ManageCommand() {
	foreach (Event in PendingEvents) {
		if (Event.Type == CSmModeEvent::EType::OnCommand) {
			switch (Event.CommandName) {
				// ---------------------------------- //
				case "Command_MatchPointsClan1": {
					if (Event.CommandValueInteger < 0) ClanScores[1] = 0;
					else ClanScores[1] = Event.CommandValueInteger;
					MB_SectionMapNb = ClanScores[1] + ClanScores[2] + 1;
					if(ClanScores[1] >= G_MapsToWin && ClanScores[1] > ClanScores[2]) MB_StopMap = True;
					UpdateHeader();
				}
				// ---------------------------------- //
				case "Command_MatchPointsClan2": {
					if (Event.CommandValueInteger < 0) ClanScores[2] = 0;
					else ClanScores[2] = Event.CommandValueInteger;
					MB_SectionMapNb = ClanScores[1] + ClanScores[2] + 1;
					if(ClanScores[2] >= G_MapsToWin && ClanScores[2] > ClanScores[1]) MB_StopMap = True;
					UpdateHeader();
				}
				// ---------------------------------- //
				case "Command_CurrentMapPointsClan1": {
					if (Event.CommandValueInteger < 0) G_ClansMapPoints[1] = 0;
					else G_ClansMapPoints[1] = Event.CommandValueInteger;
					MB_SectionRoundNb = G_ClansMapPoints[1] + G_ClansMapPoints[2] + 1;
					if (MB_CurrentSection == "WarmUp") UpdateLayerScoresTable(C_SequenceWarmUp);
					else UpdateLayerScoresTable(C_SequencePlaying);
					if(G_ClansMapPoints[1] >= S_MapPointsLimit && G_ClansMapPoints[1] > G_ClansMapPoints[2]) MB_StopMap = True;
					UpdateHeader();
				}
				// ---------------------------------- //
				case "Command_CurrentMapPointsClan2": {
					if (Event.CommandValueInteger < 0) G_ClansMapPoints[2] = 0;
					else G_ClansMapPoints[2] = Event.CommandValueInteger;
					MB_SectionRoundNb = G_ClansMapPoints[1] + G_ClansMapPoints[2] + 1;
					if (MB_CurrentSection == "WarmUp") UpdateLayerScoresTable(C_SequenceWarmUp);
					else UpdateLayerScoresTable(C_SequencePlaying);
					if(G_ClansMapPoints[2] >= S_MapPointsLimit && G_ClansMapPoints[2] > G_ClansMapPoints[1]) MB_StopMap = True;
					UpdateHeader();
				}
				// ---------------------------------- //
				case "Command_ForceSpawnWinner": {
					if (Event.CommandValueInteger == 1 || Event.CommandValueInteger == 2) G_Override_SpawnWinner = Event.CommandValueInteger;
				}
				// ---------------------------------- //
				case "Command_ForceCDraftWinner": {
					if (Event.CommandValueInteger == 1 || Event.CommandValueInteger == 2) G_Override_CDraftWinner = Event.CommandValueInteger;
				}
				// ---------------------------------- //
				case "Command_ForceWarmUp": {
					if (Event.CommandValueBoolean) {
						G_Override_NeedWarmUp = True;
					}
				}
				// ---------------------------------- //
				case "Command_ForceClublinkReload": {
					if (Event.CommandValueBoolean) {
						G_Override_ForceClublinkReload = True;
					}
				}
			}
		}
	}
}

Void FF_Sleep(Integer _Duration) {
	declare End = Now + _Duration;
	while(Now < End) {
		MB_Yield();
		ManageCommand();
		ForceClublinkReload();
	}
}

// Initialize the warm up properties
Void InitWarmUp() 
{
	if (WarmUp2::GroupExists("Clan1")) WarmUp2::SetSlotsNb("Clan1", 5);
	else WarmUp2::CreateGroup("Clan1", 5);
	if (WarmUp2::GroupExists("Clan2")) WarmUp2::SetSlotsNb("Clan2", 5);
	else WarmUp2::CreateGroup("Clan2", 5);
	WarmUp2::DisplayClanSelection(True);
}

Void InitGoals() 
{
	G_NbPolesA	= 0;
	G_NbPolesB	= 0;
	G_NbPolesC	= 0;
	foreach (LandmarkGauge in MapLandmarks_Gauge) 
	{
		if(LandmarkGauge.Sector != Null)
		{
			if(LandmarkGauge.Tag == "Zone A") G_NbPolesA +=1;
			else if(LandmarkGauge.Tag == "Zone B") G_NbPolesB +=1;
			else if(LandmarkGauge.Tag == "Zone C") G_NbPolesC +=1;
		}
	}		
	
	foreach (LandmarkGauge in MapLandmarks_Gauge) 
	{
		if(LandmarkGauge.Sector != Null)
		{
			if(LandmarkGauge.Tag == "Zone A")
			{
				declare Summary = (G_PoleCaptureDuration-1) + G_NbPolesA;
				LandmarkGauge.Gauge.Max		= Summary * 3000;
				LandmarkGauge.Gauge.Value	= LandmarkGauge.Gauge.Max;
				LandmarkGauge.Gauge.Speed	= 0;
				LandmarkGauge.Gauge.Clan 	= G_ZoneClanList[1];
				LandmarkGauge.Gauge.Captured= True;
			}
			if(LandmarkGauge.Tag == "Zone B")
			{
				declare Summary = (G_PoleCaptureDuration-1) + G_NbPolesB;
				LandmarkGauge.Gauge.Max		= Summary * 3000;
				LandmarkGauge.Gauge.Value	= 0;
				LandmarkGauge.Gauge.Speed	= 0;
				LandmarkGauge.Gauge.Clan	= 0;
				LandmarkGauge.Gauge.Captured= False;
			}
			if(LandmarkGauge.Tag == "Zone C")
			{
				declare Summary = (G_PoleCaptureDuration-1) + G_NbPolesC;
				LandmarkGauge.Gauge.Max		= Summary * 3000;
				LandmarkGauge.Gauge.Value	= LandmarkGauge.Gauge.Max;
				LandmarkGauge.Gauge.Speed	= 0;
				LandmarkGauge.Gauge.Clan 	= G_ZoneClanList[3];
				LandmarkGauge.Gauge.Captured= True;
			}
		}	

	}
}

Void InitSpawns()
{
	// Init spawn
	G_SpawnList.clear();
	G_SpawnList1.clear();
	G_SpawnList2.clear();
	foreach (LandmarkPlayerSpawn in MapLandmarks_PlayerSpawn)
	{
		if (LandmarkPlayerSpawn.Tag == "Spawn1") 
		{
			G_SpawnList1.add(LandmarkPlayerSpawn.Id);
			G_SpawnList[LandmarkPlayerSpawn.Order] <=> LandmarkPlayerSpawn;
		}	
		else if (LandmarkPlayerSpawn.Tag == "Spawn2")
		{
			G_SpawnList2.add(LandmarkPlayerSpawn.Id);
			G_SpawnList[LandmarkPlayerSpawn.Order] <=> LandmarkPlayerSpawn;
		}	
	}	

}

Void UpdateTossMarker()
{
	// Set the marker above the goal
	UIManager.UIAll.MarkersXML = "";
	foreach (Spawn in MapLandmarks_PlayerSpawn) 
	{
		declare Name = "";
		declare Type = "";
		declare PosX = Spawn.Position.X;
		declare PosY = Spawn.Position.Y + 2;
		declare PosZ = Spawn.Position.Z;
		if (Spawn.Tag == "Spawn1") Name = "$o$f90Spawn #1";
		else if (Spawn.Tag == "Spawn2") Name = "$o$f90Spawn #2";
		
		if (Name == "") continue;
		Type = """label="{{{Name}}}" """;
		UIManager.UIAll.MarkersXML ^= """
			<marker {{{Type}}} pos="{{{PosX}}} {{{PosY}}} {{{PosZ}}}" />
		""";
	}	
}

Void UpdateBasesColors() {
	foreach (Base in MapBases) {
		Base.Clan = 0;
		Base.IsActive = True;
	}
	
	declare UpdatedBases = Ident[];
	
	foreach (Spawn in MapLandmarks_PlayerSpawn) 
	{
		if (Spawn.Base == Null) continue;
		
		if(LT_IsAfterHalfTime())
		{
			if(G_SpawnForClan[1] == 1)
			{
				switch(Spawn.Tag)
				{
					case "Spawn1": Spawn.Base.Clan = 2;
					case "Spawn2": Spawn.Base.Clan = 1;
				}
			}
			else
			{
				switch(Spawn.Tag)
				{
					case "Spawn1": Spawn.Base.Clan = 1;
					case "Spawn2": Spawn.Base.Clan = 2;
				}
			}	
		}
		else
		{
			if(G_SpawnForClan[1] == 1)
			{
				switch(Spawn.Tag)
				{
					case "Spawn1": Spawn.Base.Clan = 1;
					case "Spawn2": Spawn.Base.Clan = 2;
				}
			}
			else
			{
				switch(Spawn.Tag)
				{
					case "Spawn1": Spawn.Base.Clan = 2;
					case "Spawn2": Spawn.Base.Clan = 1;
				}
			}	
		}
		Spawn.Base.IsActive = True;
		UpdatedBases.add(Spawn.Base.Id);
	}
	
	foreach (Pole in MapLandmarks_Gauge)
	{
		declare Clan = 0;
		if (Pole.Gauge.Clan == 1 || Pole.Gauge.Clan == 2) Clan = Pole.Gauge.Clan;
		
		if (Pole.Base != Null) {
			if (!UpdatedBases.exists(Pole.Base.Id)) {
				Pole.Base.Clan = Clan;
				UpdatedBases.add(Pole.Base.Id);
			} else if (Pole.Base.Clan != Clan) {
				Pole.Base.Clan = 0;
			}
		}
	}
}

// Generate players list for the score table
Text CreatePlayersListBig(Real _Scale) 
{
	declare ML ="";
	declare PosX = 9.;
	declare PosY = 16.5;
	declare PlayersByCol = 5;
	declare S = _Scale;
	declare K = 1;
	declare AvatarSize = 6;
	
	declare Team1Color = TextLib::ColorToText(Teams[0].ColorPrimary);
	declare Team2Color = TextLib::ColorToText(Teams[1].ColorPrimary);
	
	ML ^= """
<framemodel posn="0 0" id="Frame_PlayerLeft">
	<gauge posn="-7 -11.5 1" sizen="{{{83.5*S}}} 12" valign="center" color="{{{Team1Color}}}5" style="EnergyBar" drawbg="0" drawblockbg="0" ratio="0.989"/>
	<quad posn="-5 -2.1 5" sizen="{{{78.5*S}}} 11.3" bgcolor="000" opacity="0.5" id="Quad_Eliminated" hidden="1" />
	<frame posn="-4 0.4">
		<quad posn="-10 -0.3 -3" sizen="3.5 11.1" halign="right" hidden="1" id="Quad_Echelon" />
		<quad posn="{{{73*S}}} -3 2" sizen="{{{4*S}}} 7" image="{{{C_ImgModeDir}}}/NotReady.dds" id="Quad_NotReady" />
		<quad posn="{{{73*S}}} -3 2" sizen="{{{4*S}}} 7" image="{{{C_ImgModeDir}}}/Ready.dds" hidden="1" id="Quad_Ready" />
		<quad posn="{{{(5*S)-1}}} -4 2" sizen="{{{AvatarSize}}} {{{AvatarSize}}}" halign="center" bgcolor="0003" id="Quad_Avatar" />
		<label posn="{{{11*S}}} -6 3" sizen="{{{35*S}}} 9" textsize="3" valign="center" id="Label_Name" />
		<label posn="{{{66*S}}} -6 3" sizen="{{{9*S}}} 6" textsize="4" halign="left" valign="center" id="Label_KD" />
		<label posn="{{{58*S}}} -6 3" sizen="{{{7*S}}} 5" textsize="3" halign="left" valign="center" id="Label_MVP" />
	</frame>
	<frame posn="-2 -11.8 3">
		<frame posn="{{{1*S}}} 0">
			<label posn="-1 0" sizen="{{{25*S}}} 5" textsize="1" scale="0.8" textemboss="1" valign="center" id="Label_Rank" />
		</frame>
		<frame posn="{{{34*S}}} 0" id="Frame_LadderPoints" hidden="1">
			<format textcolor="bb8" textsize="1" scale="0.8"/>
			<quad posn="-18 -0.2" sizen="5 4" halign="right" valign="center" style="Icons128x128_1" substyle="LadderPoints" />
			<label posn="-23.5 0" sizen="10 4" halign="right" valign="center" id="Label_LadderPoints"/>
			<quad posn="0 -0.2" sizen="5 4" halign="right" valign="center" style="Icons128x128_1" substyle="LadderPoints" />
			<label posn="-5.5 0" sizen="10 4" halign="right" valign="center" id="Label_LadderPointsTotal" />
		</frame>
	</frame>
</framemodel>
<framemodel posn="0 0" id="Frame_PlayerRight">
	<gauge posn="7 -11.5 1" sizen="{{{83.5*S}}} 12" halign="right" valign="center" color="{{{Team2Color}}}5" style="EnergyBar" drawbg="0" drawblockbg="0" ratio="0.989"/>
	<quad posn="5 -2.1 5" sizen="{{{78.5*S}}} 11.3" halign="right" bgcolor="000" opacity="0.5" id="Quad_Eliminated" hidden="1" />
	<frame posn="4 0.4">
		<quad posn="-10 -0.3 -3" sizen="3.5 11.1" halign="right" hidden="1" id="Quad_Echelon" />
		<quad posn="{{{-73*S}}} -3 2" sizen="{{{4*S}}} 7" halign="right" image="{{{C_ImgModeDir}}}/NotReady.dds" id="Quad_NotReady" />
		<quad posn="{{{-73*S}}} -3 2" sizen="{{{4*S}}} 7" halign="right" image="{{{C_ImgModeDir}}}/Ready.dds" hidden="1" id="Quad_Ready" />
		<quad posn="{{{(-5*S)-1}}} -4 2" sizen="{{{AvatarSize}}} {{{AvatarSize}}}" halign="center" bgcolor="0003" id="Quad_Avatar" />
		<label posn="{{{-11*S}}} -6 3" sizen="{{{35*S}}} 9" textsize="3" halign="right" valign="center" id="Label_Name" />
		<label posn="{{{-66*S}}} -6 3" sizen="{{{9*S}}} 6" textsize="4" halign="right" valign="center" id="Label_KD" />
		<label posn="{{{-58*S}}} -6 3" sizen="{{{7*S}}} 5" textsize="3" halign="right" valign="center" id="Label_MVP" />
	</frame>
	<frame posn="2 -11.8 3">
		<frame posn="{{{-1*S}}} 0">
			<label posn="1 0" sizen="{{{25*S}}} 5" textsize="1" scale="0.8" textemboss="1" halign="right" valign="center" id="Label_Rank" />
		</frame>
		<frame posn="{{{-34*S}}} 0" id="Frame_LadderPoints" hidden="1">
			<format textcolor="bb8" textsize="1" scale="0.8" />
			<quad posn="18 -0.2" sizen="5 4" halign="right" valign="center" style="Icons128x128_1" substyle="LadderPoints" />
			<label posn="23.5 0" sizen="10 4" halign="right" valign="center" id="Label_LadderPoints"/>
			<quad posn="0 -0.2" sizen="5 4" halign="right" valign="center" style="Icons128x128_1" substyle="LadderPoints" />
			<label posn="5.5 0" sizen="10 4" halign="right" valign="center" id="Label_LadderPointsTotal" />
		</frame>
	</frame>
</framemodel>
""";
	
	for (J, 1, 2) 
	{
		for (I, 1, PlayersByCol) {
			// Do not display more than 5 players in the scores table
			declare Hidden = "";
			if (I > 5) Hidden = """ hidden="1" """;
			if (J % 2 == 1) {
				ML ^= """
<frame posn="{{{PosX}}} {{{PosY}}}" {{{Hidden}}}>
	<quad posn="0 0 -3" sizen="{{{80*S}}} 11.1" id="Quad_Player_{{{K}}}" scriptevents="1" />
	<frameinstance modelid="Frame_PlayerLeft" id="Frame_Player_{{{K}}}" />
</frame>
""";
			} else {
				ML ^= """
<frame posn="{{{PosX+(125*S/2.)}}} {{{PosY}}}" {{{Hidden}}}>
	<quad posn="0 0 -3" sizen="{{{80*S}}} 11.1" halign="right" id="Quad_Player_{{{K}}}" scriptevents="1" />
	<frameinstance modelid="Frame_PlayerRight" id="Frame_Player_{{{K}}}" />
</frame>
""";
			}
			PosY -= 11.1;
			K += 1;
		}
		PosX += 168.5*S/2.;
		PosY = 16.44;
	}
	
	return ML;
}

// Create the score table manialink string.
Text CreateLayerScoresTable()
{
	declare CW = 1.;
	declare SW = 1.;
	declare PosY = 38;

	declare Team1Color = """{{{Teams[0].ColorPrimary.X}}} {{{Teams[0].ColorPrimary.Y}}} {{{Teams[0].ColorPrimary.Z}}}""";
	declare Team2Color = """{{{Teams[1].ColorPrimary.X}}} {{{Teams[1].ColorPrimary.Y}}} {{{Teams[1].ColorPrimary.Z}}}""";
	declare Clan1Color = TextLib::ColorToText(Teams[0].ColorPrimary);
	declare Clan2Color = TextLib::ColorToText(Teams[1].ColorPrimary);
	
return """
<!-- **************** Scores table **************** -->
<quad posn="0 {{{PosY-39}}} 21" sizen="180 80" halign="center" valign="center" image="{{{C_ImgModeDir}}}/scoreboard_base.dds" />
<quad posn="0 {{{PosY-54}}} 19" sizen="180 120" halign="center" valign="center" image="{{{C_ImgModeDir}}}/scoreboard_header.dds"/>
<quad posn="-78 -30 22" sizen="{{{78*CW}}} 58" halign="left" valign="bottom" bgcolor="{{{Clan1Color}}}1"/>
<quad posn="78 -30 22" sizen="{{{78*CW}}} 58" halign="right" valign="bottom" bgcolor="{{{Clan2Color}}}1"/>
<frame id="Frame_Legend">
	<format textsize="1"/>
	<label posn="-21 27.5 22" text="MVP"/>
	<label posn="-9.5 27.5 22" text="K:D"/>
	<label posn="21 27.5 22" halign="right" text="MVP"/>
	<label posn="9.5 27.5 22" halign="right" text="K:D"/>
</frame>	
<frame posn="0 {{{PosY}}} 21" id ="Frame_ScoresTable">
	<format textemboss="1" />
	<!-- **************** VS **************** -->
	<frame posn="0 -11" id="Frame_VS">
		<quad posn="-11 0" sizen="15 14" halign="right" valign="bottom" style="Emblems" substyle="#1" />
		<quad posn="11 0" sizen="15 14" valign="bottom" style="Emblems" substyle="#2" />
		<label posn="-47 1" sizen="40 5" textsize="4" halign="center" valign="bottom" scale="1.1" opacity="0.9" textemboss="1" id="Label_NameTeam1" />
		<label posn="47 1" sizen="40 5" textsize="4" halign="center" valign="bottom" scale="1.1" opacity="0.9" textemboss="1" id="Label_NameTeam2" />
	</frame>
	<!-- **************** Players Ranking **************** -->
	<frame posn="{{{-164.5*CW/2.}}} -27" id="Frame_Ranking">
		{{{CreatePlayersListBig(CW)}}}
	</frame>
	<!-- **************** Bottom panel **************** -->
	<frame posn="0 -62">
		<label posn="0 -8.5 2" sizen="{{{90*SW}}} 5" textsize="2" textcolor="FFF" halign="center" valign="center" textemboss="1" id="Label_GoalAverage" />
	</frame>
</frame>
<script><!--
#Include "TextLib" as TextLib
#Include "MathLib" as ML

#Const C_PlayerCardWidth {{{80*CW}}}

declare CMlLabel	Label_NameTeam1;
declare CMlLabel 	Label_NameTeam2;
declare CMlFrame	Frame_Ranking;
declare CMlLabel	Label_GoalAverage;

Text GetEchelonPath(CUser::EEchelon _Echelon, Integer _Side) {
	declare EchelonSide = "";
	if (_Side < 0) EchelonSide = "_rev";
					
	switch (_Echelon) {
		case CUser::EEchelon::Bronze1	: return "file://Media/Manialinks/Common/Echelons/small_echelon1"^EchelonSide^".dds";
		case CUser::EEchelon::Bronze2	: return "file://Media/Manialinks/Common/Echelons/small_echelon2"^EchelonSide^".dds";
		case CUser::EEchelon::Bronze3	: return "file://Media/Manialinks/Common/Echelons/small_echelon3"^EchelonSide^".dds";
		case CUser::EEchelon::Silver1	: return "file://Media/Manialinks/Common/Echelons/small_echelon4"^EchelonSide^".dds";
		case CUser::EEchelon::Silver2	: return "file://Media/Manialinks/Common/Echelons/small_echelon5"^EchelonSide^".dds";
		case CUser::EEchelon::Silver3	: return "file://Media/Manialinks/Common/Echelons/small_echelon6"^EchelonSide^".dds";
		case CUser::EEchelon::Gold1		: return "file://Media/Manialinks/Common/Echelons/small_echelon7"^EchelonSide^".dds";
		case CUser::EEchelon::Gold2		: return "file://Media/Manialinks/Common/Echelons/small_echelon8"^EchelonSide^".dds";
		case CUser::EEchelon::Gold3		: return "file://Media/Manialinks/Common/Echelons/small_echelon9"^EchelonSide^".dds";
	}
	
	return "";
}

Void UpdatePlayersList(
	Text[Integer]		_Logins, 
	Text[Integer]		_Names, 
	Integer[Integer]	_Ranks,
	Real[Integer]		_LadderPoints,
	Real[Integer]		_LadderPointsTotal,
	Boolean[Integer]	_Ready,
	Integer[Integer]	_Kills,
	Integer[Integer]	_Deaths,
	Integer[Integer]	_MVP,
	Integer				_Mode,
	Ident[Integer]		_PlayersIds
) {	
	for (I, 1, 10) {
		declare Frame_Player <=> (Frame_Ranking.GetFirstChild("Frame_Player_"^I) as CMlFrame);
		
		if (_Logins.existskey(I)) {
			declare Quad_NotReady			<=> (Frame_Player.GetFirstChild("Quad_NotReady")			as CMlQuad);
			declare Quad_Ready				<=> (Frame_Player.GetFirstChild("Quad_Ready")				as CMlQuad);
			declare Quad_Avatar 			<=> (Frame_Player.GetFirstChild("Quad_Avatar")				as CMlQuad);
			declare Quad_Eliminated			<=> (Frame_Player.GetFirstChild("Quad_Eliminated")			as CMlQuad);
			declare Label_Name				<=> (Frame_Player.GetFirstChild("Label_Name")				as CMlLabel);
			declare Quad_Echelon			<=> (Frame_Player.GetFirstChild("Quad_Echelon")				as CMlQuad);
			declare Label_Rank				<=> (Frame_Player.GetFirstChild("Label_Rank")				as CMlLabel);		
			declare Label_KD				<=> (Frame_Player.GetFirstChild("Label_KD")					as CMlLabel);
			declare Label_MVP				<=> (Frame_Player.GetFirstChild("Label_MVP")				as CMlLabel);
			declare Frame_Stats				<=> (Frame_Player.GetFirstChild("Frame_Stats")				as CMlFrame);
			declare Frame_LadderPoints		<=> (Frame_Player.GetFirstChild("Frame_LadderPoints")		as CMlFrame);
			declare Label_LadderPoints		<=> (Frame_Player.GetFirstChild("Label_LadderPoints")		as CMlLabel);
			declare Label_LadderPointsTotal	<=> (Frame_Player.GetFirstChild("Label_LadderPointsTotal")	as CMlLabel);
			//declare Quad_Bg1				<=> (Frame_Player.GetFirstChild("Quad_Bg1")					as CMlQuad);
			//declare Quad_Bg2				<=> (Frame_Player.GetFirstChild("Quad_Bg2")					as CMlQuad);
			
			declare Side = 1;
			if (Label_Name.RelativePosition.X < 0) Side = -1;
			
			Frame_Player.Show();
			// Ready state
			if (_Mode == {{{C_SequenceWarmUp}}} || _Mode == {{{C_SequencePause}}}) {
				//Quad_Bg1.Hide();
				//Quad_Bg2.Hide();
				//Quad_Avatar.RelativePosition.X = {{{4 + (3*CW)}}} * Side;
				//Label_Name.RelativePosition.X = {{{12*CW}}} * Side;
				if (_Ready.existskey(I)) {
					if (_Ready[I]) {
						Quad_Ready.Show();
						Quad_NotReady.Hide();
					} else {
						Quad_Ready.Hide();
						Quad_NotReady.Show();
					}
				} else {
					Quad_Ready.Hide();
					Quad_NotReady.Show();
				}
			} else {
				//Quad_Avatar.RelativePosition.X = {{{5 + (0*CW)}}} * Side;
				//Label_Name.RelativePosition.X = {{{10*CW}}} * Side;
				Quad_Ready.Hide();
				Quad_NotReady.Hide();
				//Quad_Bg1.Show();
				//Quad_Bg2.Show();
			}
			// Avatar
			if (_Logins.existskey(I) && _Names.existskey(I)) {
				Quad_Avatar.ChangeImageUrl("file://Avatars/"^_Logins[I]^"/Default");
			} else {
				Quad_Avatar.ChangeImageUrl("");
			}
			
			// Name
			if (_Names.existskey(I)) {
				Label_Name.SetText(_Names[I]);
			} else {
				Label_Name.SetText("-");
			}
			if (_PlayersIds.existskey(I) && Players.existskey(_PlayersIds[I])) {
				declare Player <=> Players[_PlayersIds[I]];
				
				// Echelons				
				declare EchelonPath = GetEchelonPath(Player.User.Echelon, Side);
				if (EchelonPath != "") {
					Quad_Echelon.Show();
					Quad_Echelon.ImageUrl = EchelonPath;
				} else {
					Quad_Echelon.Hide();
				}
			}
			// Rank
			if (_Ranks.existskey(I) && _Ranks[I] > 0) {
				Label_Rank.SetText(TextLib::Compose("%1: %2", _("Rank"), TextLib::ToText(_Ranks[I])));
			} else {
				Label_Rank.SetText(TextLib::Compose("%1: %2", _("Rank"), "-"));
			}
			// Stats
			if(_Mode != {{{C_SequenceWarmUp}}})
			{
				Label_KD.Visible = True;
				Label_MVP.Visible = True;
				declare Kills = 0;
				declare Deaths = 0;
				// K/D
				if (_Kills.existskey(I)) {
					Kills = _Kills[I];
				} else {
					Kills = 0;
				}
				if (_Deaths.existskey(I)) {
				Deaths = _Deaths[I];
				} else {
					Deaths = 0;
				}
				Label_KD.SetText(""^Kills^":"^Deaths);
				// MVP
				if (_MVP.existskey(I)) {
					Label_MVP.SetText(""^_MVP[I]);
				} else {
					Label_MVP.SetText("0");
				}
			}
			else
			{
				Label_KD.Visible = False;
				Label_MVP.Visible = False;
			}	
			// Ladder points
			if (_Mode == {{{C_SequencePodium}}} && _LadderPoints.existskey(I) && _LadderPoints[I] != -1.) {
				Frame_LadderPoints.Show();
				
				declare LadderPointsExplode = TextLib::Split(".", TextLib::ToText(_LadderPoints[I]));
				declare LadderPoints = "0.0";
				if (LadderPointsExplode.existskey(0)) LadderPoints = LadderPointsExplode[0];
				if (LadderPointsExplode.existskey(1)) LadderPoints ^= "."^TextLib::SubString(LadderPointsExplode[1], 0, 2);
				
				if (_LadderPoints[I] >= 0) Label_LadderPoints.SetText("+"^LadderPoints);
				else Label_LadderPoints.SetText(LadderPoints);
				
				if (_LadderPointsTotal.existskey(I)) {
					declare LadderPointsTotalExplode = TextLib::Split(".", TextLib::ToText(_LadderPointsTotal[I]));
					declare LadderPointsTotal = "0";
					if (LadderPointsTotalExplode.existskey(0)) LadderPointsTotal = LadderPointsTotalExplode[0];
					Label_LadderPointsTotal.SetText(LadderPointsTotal);
				} else {
					Label_LadderPointsTotal.SetText("0");
				}
			} else {
				Frame_LadderPoints.Hide();
			}
		} else {
			Frame_Player.Hide();
		}
	}
}

Void UpdateGameInfo() 
{
	if({{{S_FinalRoundExceptDraw}}}) Label_GoalAverage.SetText(TextLib::Compose(_("Round: %1/%2 | Points to win: %3 | Remaining rounds: %4"), TextLib::ToText({{{MB_SectionRoundNb}}}), TextLib::ToText({{{G_MapPointsLimit}}}*2+1), TextLib::ToText({{{G_MapPointsLimit}}}+1), TextLib::ToText({{{G_MapPointsLimit}}}*2-{{{MB_SectionRoundNb}}})));
	else Label_GoalAverage.SetText(TextLib::Compose(_("Round: %1/%2 | Points to win: %3 | Remaining rounds: %4"), TextLib::ToText({{{MB_SectionRoundNb}}}), TextLib::ToText({{{G_MapPointsLimit}}}*2), TextLib::ToText({{{G_MapPointsLimit}}}+1), TextLib::ToText({{{G_MapPointsLimit}}}*2-{{{MB_SectionRoundNb}}})));
}

Void UpdatePlayersStatus(Boolean _Forced) {
	declare netread Text[Integer] Net_LayerST_Logins for UI;
	
	foreach (Player in Players) {
		declare PrevSpawnStatus for Player = CSmPlayer::ESpawnStatus::Spawned;
		if (PrevSpawnStatus != Player.SpawnStatus || _Forced) {
			PrevSpawnStatus = Player.SpawnStatus;
			
			if (!Net_LayerST_Logins.exists(Player.Login)) continue;
			
			declare Frame_Player <=> (Frame_Ranking.GetFirstChild("Frame_Player_"^Net_LayerST_Logins.keyof(Player.Login)) as CMlFrame);
			if (Frame_Player == Null) continue;
			
			declare Quad_Eliminated <=> (Frame_Player.GetFirstChild("Quad_Eliminated")	as CMlQuad);
			declare netread Integer Net_LayerST_Mode for UI;
			
			if (Net_LayerST_Mode == {{{C_SequencePlaying}}} && UI.UISequence == CUIConfig::EUISequence::Playing) {
				if (Player.SpawnStatus == CSmPlayer::ESpawnStatus::NotSpawned) {
					Quad_Eliminated.Show();
				} else {
					Quad_Eliminated.Hide();
				}
			} else {
				Quad_Eliminated.Hide();
			}
		}
	}
}

main() {
	Label_NameTeam1			<=> (Page.GetFirstChild("Label_NameTeam1")		as CMlLabel);
	Label_NameTeam2			<=> (Page.GetFirstChild("Label_NameTeam2")		as CMlLabel);
	Frame_Ranking			<=> (Page.GetFirstChild("Frame_Ranking")		as CMlFrame);
	Label_GoalAverage		<=> (Page.GetFirstChild("Label_GoalAverage")	as CMlLabel);
	declare Quad_Clan1Color	<=> (Page.GetFirstChild("Quad_Clan1Color")		as CMlQuad);
	declare Quad_Clan2Color	<=> (Page.GetFirstChild("Quad_Clan2Color")		as CMlQuad);
	declare Frame_Legend	<=> (Page.GetFirstChild("Frame_Legend")			as CMlFrame);
	
	declare netread Integer				Net_LayerST_Update			for UI;
	declare netread Text[Integer]		Net_LayerST_Logins			for UI;
	declare netread Integer[Integer]	Net_LayerST_Kills			for UI;
	declare netread Integer[Integer]	Net_LayerST_Deaths			for UI;
	declare netread Integer[Integer]	Net_LayerST_MVP				for UI;
	declare netread Boolean[Integer]	Net_LayerST_Ready			for UI;
	declare netread Integer				Net_LayerST_Mode			for UI;
	
	declare Text[Integer]		Logins;
	declare Text[Integer]		Names;
	declare Integer[Integer]	LadderRanks;
	declare Integer				Order;
	declare Real[Integer]		LadderPoints;
	declare Real[Integer]		LadderPointsTotal;
	declare Ident[Integer]		PlayersIds;
	
	declare LastUpdate = -1;
	declare PrevUISequence = CUIConfig::EUISequence::None;
	declare PrevSpecCount = 0;
	declare PrevClan1Name = "";
	declare PrevClan2Name = "";
	declare PrevClan1Color = <0., 0., 1.>;
	declare PrevClan2Color = <1., 0., 0.>;

	while (True) {
		yield;
		
		if (InputPlayer == Null) continue;
		if (!PageIsVisible) continue;
		
		if (PrevClan1Name != Teams[0].ColorizedName) {
			PrevClan1Name = Teams[0].ColorizedName;
			if (Teams[0].ColorizedName == "$<$00fBlue$>") Label_NameTeam1.SetText("$<$fffBlue$>");
			else Label_NameTeam1.SetText(Teams[0].ColorizedName);
		}
		if (PrevClan2Name != Teams[1].ColorizedName) {
			PrevClan2Name = Teams[1].ColorizedName;
			if (Teams[1].ColorizedName == "$<$f00Red$>") Label_NameTeam2.SetText("$<$fffRed$>");
			else Label_NameTeam2.SetText(Teams[1].ColorizedName);
		}
		if (PrevClan1Color != Teams[0].ColorPrimary) {
			PrevClan1Color = Teams[0].ColorPrimary;
			Quad_Clan1Color.Colorize = Teams[0].ColorPrimary;
		}
		if (PrevClan2Color != Teams[1].ColorPrimary) {
			PrevClan2Color = Teams[1].ColorPrimary;
			Quad_Clan2Color.Colorize = Teams[1].ColorPrimary;
		}
		
		if(Net_LayerST_Mode == {{{C_SequenceWarmUp}}}) Frame_Legend.Visible = False;
		else Frame_Legend.Visible = True;
		
		if (LastUpdate != Net_LayerST_Update) {
			LastUpdate = Net_LayerST_Update;
			
			UpdatePlayersStatus(True);
			
			Logins = Net_LayerST_Logins;
			for (I, 1, 10) {
				declare Frame_Player <=> Frame_Ranking.GetFirstChild("Quad_Player_"^I);
				if (Frame_Player == Null) continue;
				declare SpectateLogin for Frame_Player = "";
				if (!Logins.existskey(I)) SpectateLogin = "";
				else SpectateLogin = Logins[I];				
			}
			
			Names.clear();
			LadderRanks.clear();
			foreach (Score in Scores) {
				if (Logins.exists(Score.User.Login)) {
					declare Key = Logins.keyof(Score.User.Login);
					Names[Key] = Score.User.Name;
					LadderRanks[Key] = Score.User.LadderRank;
					LadderPoints[Key] = Score.LadderScore;
					LadderPointsTotal[Key] = Score.User.LadderPoints;
				}
			}
			foreach (Player in Players) {
				if (Logins.exists(Player.Login)) {
					declare Key = Logins.keyof(Player.Login);
					PlayersIds[Key] = Player.Id;
				}
			}
			
			UpdatePlayersList(
				Logins, 
				Names, 
				LadderRanks,
				LadderPoints,
				LadderPointsTotal,
				Net_LayerST_Ready, 
				Net_LayerST_Kills, 
				Net_LayerST_Deaths,
				Net_LayerST_MVP,
				Net_LayerST_Mode,
				PlayersIds
			);
			
			UpdateGameInfo();
		}
		
		if (PrevUISequence != UI.UISequence) {
			PrevUISequence = UI.UISequence;
			
			if (UI.UISequence != CUIConfig::EUISequence::Playing) {
				for (I, 1, 10) {
					declare Frame_Player	<=> (Frame_Ranking.GetFirstChild("Frame_Player_"^I)	as CMlFrame);
					declare Quad_Eliminated <=> (Frame_Player.GetFirstChild("Quad_Eliminated") as CMlQuad);
					Quad_Eliminated.Hide();
				}
			}
			
			UpdatePlayersStatus(True);
		}
		
		if (UI.UISequence == CUIConfig::EUISequence::Playing) UpdatePlayersStatus(False);
		
		foreach (Event in PendingEvents) {
			if (Event.Type == CMlEvent::Type::MouseClick) {
				if (IsSpectatorMode) {
					declare SpectateLogin for Event.Control = "";
					if (SpectateLogin != "") SetSpectateTarget(SpectateLogin);
				}
			}
		}
	}
}
--></script>
""";
}

Void SpawnWeaponItems() {
	foreach (MapLandmark in MapLandmarks_ObjectAnchor) {
		declare ObjectAnchor <=> MapLandmark.ObjectAnchor;
		if (ObjectAnchor == Null) continue;
		
		declare ObjectSpawned for MapLandmark = False;
		declare ObjectNextSpawn for MapLandmark = Now;
		if (ObjectSpawned) continue;
		if (ObjectNextSpawn > Now) continue;
		
		declare CSmObject Object;
		switch (MapLandmark.Tag) {
			case C_Object["Laser"]			: Object = ObjectCreate(G_ObjectId[C_Object["Laser"]]);
			case C_Object["PlasmaGun"]		: Object = ObjectCreate(G_ObjectId[C_Object["PlasmaGun"]]);
			case C_Object["Grenades"]		: Object = ObjectCreate(G_ObjectId[C_Object["Grenades"]]);
			case C_Object["Nucleus"]		: Object = ObjectCreate(G_ObjectId[C_Object["Nucleus"]]);
			case C_Object["Shotgun"]		: Object = ObjectCreate(G_ObjectId[C_Object["Shotgun"]]);
			case C_Object["BlowBomb"]		: Object = ObjectCreate(G_ObjectId[C_Object["BlowBomb"]]);
		}
		if (Object != Null) {
			declare AnchorId for Object = NullId;
			declare Tag for Object = MapLandmark.Tag;
			AnchorId = MapLandmark.Id;
			Tag = MapLandmark.Tag;
			ObjectSpawned = True;
			Object.SetAnchor(ObjectAnchor);
		}
	}
}

Void PickUpWeapon(CSmPlayer _Player, Text _Weapon) 
{
	declare PrimaryWeapon for _Player = 1;
	switch (_Weapon) 
	{
		case "Laser":
		{
			SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Laser, 1);
			SetPlayerAmmo(_Player, CSmMode::EWeapon::Laser, 0);
			SetPlayerWeapon(_Player, CSmMode::EWeapon::Laser, False);
			ActionBind(_Player, CSmMode::EActionSlot::Slot_B, CSmMode::EActionInput::None);
			ActionBind(_Player, CSmMode::EActionSlot::Slot_A, CSmMode::EActionInput::None);
			_Player.AmmoGain = 0.85;
			PrimaryWeapon = 1;
		}
		case "PlasmaGun":
		{
			SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Laser, 0);
			SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Nucleus, 0);
			SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Arrow, 0);
			ActionLoad(_Player, CSmMode::EActionSlot::Slot_A, G_CustomPlasmaGun);
			ActionBind(_Player, CSmMode::EActionSlot::Slot_A, CSmMode::EActionInput::Weapon);
			PrimaryWeapon = 2;
		}
		case "Grenades":
		{
			SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Laser, 0);
			SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Nucleus, 0);
			SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Arrow, 0);
			ActionLoad(_Player, CSmMode::EActionSlot::Slot_A, G_CustomGrenades);
			ActionBind(_Player, CSmMode::EActionSlot::Slot_A, CSmMode::EActionInput::Weapon);
			PrimaryWeapon = 3;
		}
		case "Nucleus":
		{
			SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Nucleus, 2);
			SetPlayerAmmo(_Player, CSmMode::EWeapon::Nucleus, 1);
			SetPlayerWeapon(_Player, CSmMode::EWeapon::Nucleus, False);
			_Player.AmmoGain = 0.65;
			ActionBind(_Player, CSmMode::EActionSlot::Slot_B, CSmMode::EActionInput::None);
			ActionBind(_Player, CSmMode::EActionSlot::Slot_A, CSmMode::EActionInput::None);
			PrimaryWeapon = 4;
		}
		case "Shotgun":
		{
			SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Laser, 0);
			SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Nucleus, 0);
			SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Arrow, 0);
			ActionLoad(_Player, CSmMode::EActionSlot::Slot_A, G_CustomShotgun);
			ActionBind(_Player, CSmMode::EActionSlot::Slot_A, CSmMode::EActionInput::Weapon);
			PrimaryWeapon = 5;
		}
		case "BlowBomb":
		{
			SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Laser, 0);
			SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Nucleus, 0);
			SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Arrow, 0);
			ActionLoad(_Player, CSmMode::EActionSlot::Slot_A, G_CustomBlowBomb);
			ActionBind(_Player, CSmMode::EActionSlot::Slot_A, CSmMode::EActionInput::Weapon);
			PrimaryWeapon = 6;
		}
		default: return;
	}	
	_Player.StaminaMax = C_StaminaWith2Weapons;
	_Player.StaminaGain = C_StaminaWith2Weapons;
	_Player.SpeedPower = C_SpeedWith2Weapons;
	declare PUI <=> UIManager.GetUI(_Player);
	if(PUI != Null)
	{
		declare netwrite Net_PrimaryWeapon for PUI = 0;
		Net_PrimaryWeapon = PrimaryWeapon;
	}	
	foreach(Player in Players)
	{
		declare UI <=> UIManager.GetUI(Player);
		if (UI != Null) 
		{ 
			declare netwrite Integer[Text] Net_PrimaryWeapons for UI;
			Net_PrimaryWeapons[_Player.Login] = PrimaryWeapon;
		}
	}		

	UIManager.UIAll.SendNotice(
		TextLib::Compose(_("|Player picked up item|$<%1$> picked up %2"), _Player.Name, _Weapon), 
		CUIConfig::ENoticeLevel::Default , Null, 
		CUIConfig::EAvatarVariant::Happy, 
		CUIConfig::EUISound::Silence, 0
	);
}

Void PickUpObject(CSmPlayer _Player, CSmObject _Object) {
	if (_Player == Null || _Object == Null) return;
	
	declare Tag for _Object = "";
	declare AnchorId for _Object = NullId;
	
	if (!MapLandmarks_ObjectAnchor.existskey(AnchorId)) return;
	declare MapLandmark <=> MapLandmarks_ObjectAnchor[AnchorId];
	declare ObjectSpawned for MapLandmark = False;
	declare ObjectNextSpawn for MapLandmark = Now;
	ObjectSpawned = False;
	if(MB_CurrentSection == "WarmUp") ObjectNextSpawn = Now + 5000;
	else
	{
		if (S_ItemSpawnTime > 5) ObjectNextSpawn = Now + (S_ItemSpawnTime*1000);
		else ObjectNextSpawn = Now + 5000;
	}	
	
	switch (Tag) 
	{
		case C_Object["Laser"]: PickUpWeapon(_Player, Tag);
		case C_Object["PlasmaGun"]: PickUpWeapon(_Player, Tag);
		case C_Object["Grenades"]: PickUpWeapon(_Player, Tag);
		case C_Object["Nucleus"]: PickUpWeapon(_Player, Tag);
		case C_Object["Shotgun"]: PickUpWeapon(_Player, Tag);
		case C_Object["BlowBomb"]: PickUpWeapon(_Player, Tag);
	}
	
	_Object.SetPlayer(_Player);
	ObjectDestroy(_Object);
}

Void SwitchWeapon(CSmPlayer _Player, CSmModeEvent::EActionInput _Input) {
	declare PrimaryWeapon for _Player = 1;
	declare SecondaryWeapon for _Player = 1;
	declare CurrentWeaponSlot for _Player = 2;
	
	switch (_Input) {
		// Primary weapon
		case CSmModeEvent::EActionInput::Activable1: 
		{
			switch(PrimaryWeapon)
			{
				case 1:
				{
					SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Laser, 1);
					SetPlayerWeapon(_Player, CSmMode::EWeapon::Laser, False);
					ActionLoad(_Player, CSmMode::EActionSlot::Slot_A, NullId);
					ActionBind(_Player, CSmMode::EActionSlot::Slot_A, CSmMode::EActionInput::None);
					ActionBind(_Player, CSmMode::EActionSlot::Slot_B, CSmMode::EActionInput::None);
					_Player.AmmoGain = 0.85;
				}
				case 2:
				{
					SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Laser, 0);
					SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Nucleus, 0);
					SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Arrow, 0);
					ActionLoad(_Player, CSmMode::EActionSlot::Slot_A, G_CustomPlasmaGun);
					ActionBind(_Player, CSmMode::EActionSlot::Slot_A, CSmMode::EActionInput::Weapon);
					_Player.AmmoGain = 1.;
				}
				case 3:
				{
					SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Laser, 0);
					SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Nucleus, 0);
					SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Arrow, 0);
					ActionLoad(_Player, CSmMode::EActionSlot::Slot_A, G_CustomGrenades);
					ActionBind(_Player, CSmMode::EActionSlot::Slot_A, CSmMode::EActionInput::Weapon);
					_Player.AmmoGain = 1.;
				}
				case 4:
				{
					SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Nucleus, 2);
					SetPlayerWeapon(_Player, CSmMode::EWeapon::Nucleus, False);
					ActionLoad(_Player, CSmMode::EActionSlot::Slot_A, NullId);
					ActionBind(_Player, CSmMode::EActionSlot::Slot_A, CSmMode::EActionInput::None);
					ActionBind(_Player, CSmMode::EActionSlot::Slot_B, CSmMode::EActionInput::None);
					_Player.AmmoGain = 0.65;
				}
				case 5:
				{
					SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Laser, 0);
					SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Nucleus, 0);
					SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Arrow, 0);
					ActionLoad(_Player, CSmMode::EActionSlot::Slot_A, G_CustomShotgun);
					ActionBind(_Player, CSmMode::EActionSlot::Slot_A, CSmMode::EActionInput::Weapon);
					_Player.AmmoGain = 1.;
				}
				case 6:
				{
					SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Laser, 0);
					SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Nucleus, 0);
					SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Arrow, 0);
					ActionLoad(_Player, CSmMode::EActionSlot::Slot_A, G_CustomBlowBomb);
					ActionBind(_Player, CSmMode::EActionSlot::Slot_A, CSmMode::EActionInput::Weapon);
					_Player.AmmoGain = 1.;
				}
				default:
				{
					switch(SecondaryWeapon)
					{
						case 1:
						{
							//SetPlayerAmmo(_Player, CSmMode::EWeapon::Laser, 0);
							//SetPlayerAmmo(_Player, CSmMode::EWeapon::Nucleus, 0);
							SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Rocket, 4);
							SetPlayerWeapon(_Player, CSmMode::EWeapon::Rocket, False);
						//	ActionLoad(_Player, CSmMode::EActionSlot::Slot_A, NullId);
							ActionBind(_Player, CSmMode::EActionSlot::Slot_A, CSmMode::EActionInput::None);
							ActionBind(_Player, CSmMode::EActionSlot::Slot_B, CSmMode::EActionInput::None);
							_Player.AmmoGain = 1.;
						}
						case 2:
						{
							//SetPlayerAmmo(_Player, CSmMode::EWeapon::Laser, 0);
							//SetPlayerAmmo(_Player, CSmMode::EWeapon::Nucleus, 0);
							SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Rocket, 0);
							//ActionLoad(_Player, CSmMode::EActionSlot::Slot_A, NullId);
							ActionLoad(_Player, CSmMode::EActionSlot::Slot_B, G_CustomBounceRocket);
							ActionBind(_Player, CSmMode::EActionSlot::Slot_A, CSmMode::EActionInput::None);
							ActionBind(_Player, CSmMode::EActionSlot::Slot_B, CSmMode::EActionInput::Weapon);
							_Player.AmmoGain = 1.;
						}
						case 3:
						{
							//SetPlayerAmmo(_Player, CSmMode::EWeapon::Laser, 0);
							//SetPlayerAmmo(_Player, CSmMode::EWeapon::Nucleus, 0);
							SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Rocket, 0);
							//ActionLoad(_Player, CSmMode::EActionSlot::Slot_A, NullId);
							ActionLoad(_Player, CSmMode::EActionSlot::Slot_B, G_CustomElectricPistol);
							ActionBind(_Player, CSmMode::EActionSlot::Slot_A, CSmMode::EActionInput::None);
							ActionBind(_Player, CSmMode::EActionSlot::Slot_B, CSmMode::EActionInput::Weapon);
							_Player.AmmoGain = 1.;
						}
					}	
				}
			}
			CurrentWeaponSlot = 1;
		}
		// Secondary weapon
		case CSmModeEvent::EActionInput::Activable2: 
		{
			switch(SecondaryWeapon)
			{
				case 1:
				{
					SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Rocket, 4);
					SetPlayerWeapon(_Player, CSmMode::EWeapon::Rocket, False);
					//SetPlayerAmmo(_Player, CSmMode::EWeapon::Laser, 0);
					//SetPlayerAmmo(_Player, CSmMode::EWeapon::Nucleus, 0);
					//ActionLoad(_Player, CSmMode::EActionSlot::Slot_A, NullId);
					ActionBind(_Player, CSmMode::EActionSlot::Slot_A, CSmMode::EActionInput::None);
					ActionBind(_Player, CSmMode::EActionSlot::Slot_B, CSmMode::EActionInput::None);
					_Player.AmmoGain = 1.;
				}
				case 2:
				{
					SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Rocket, 0);
					//SetPlayerAmmo(_Player, CSmMode::EWeapon::Laser, 0);
					//SetPlayerAmmo(_Player, CSmMode::EWeapon::Nucleus, 0);
					SetPlayerWeapon(_Player, CSmMode::EWeapon::Rocket, False);
					//ActionLoad(_Player, CSmMode::EActionSlot::Slot_A, NullId);
					ActionLoad(_Player, CSmMode::EActionSlot::Slot_B, G_CustomBounceRocket);
					ActionBind(_Player, CSmMode::EActionSlot::Slot_A, CSmMode::EActionInput::None);
					ActionBind(_Player, CSmMode::EActionSlot::Slot_B, CSmMode::EActionInput::Weapon);
					_Player.AmmoGain = 1.;
				}
				case 3:
				{
					SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Rocket, 0);
					//SetPlayerAmmo(_Player, CSmMode::EWeapon::Laser, 0);
					//SetPlayerAmmo(_Player, CSmMode::EWeapon::Nucleus, 0);
					SetPlayerWeapon(_Player, CSmMode::EWeapon::Rocket, False);
					//ActionLoad(_Player, CSmMode::EActionSlot::Slot_A, NullId);
					ActionLoad(_Player, CSmMode::EActionSlot::Slot_B, G_CustomElectricPistol);
					ActionBind(_Player, CSmMode::EActionSlot::Slot_A, CSmMode::EActionInput::None);
					ActionBind(_Player, CSmMode::EActionSlot::Slot_B, CSmMode::EActionInput::Weapon);
					_Player.AmmoGain = 1.;
				}
			}	
			CurrentWeaponSlot = 2;
		}
	}
}

Void DisplayNotice()
{
	foreach (Player in Players) 
	{
		declare UI <=> UIManager.GetUI(Player);
		if (UI == Null) continue;
		declare rand = MathLib::Rand(1,6);
		
		declare Text[Integer] MSG;
		declare Prefix = "$f90$s*";
		switch(Player.User.Language)
		{
			case "pl":
			{
				MSG[1] = "Śledź maniaflash $h[maniaflash?firefight]firefight$h by uzyskać informacje o aktualizacjach";
				MSG[2] = "Tryb został stworzony przez ToRRent'a";
				MSG[3] = "Wciśnij F8 by zmodyfikować interfejs";
				MSG[4] = "Zdobywaj strefy terytorialne by odrodzić drużynę i się uleczyć";
				MSG[5] = "Jeżeli masz sugestie co do rozwoju trybu, napisz $l[http://forum.maniaplanet.com/viewtopic.php?f=10&t=28177&start=0]tutaj$l";
				MSG[6] = "Zbierz przedmiot znajdujący się na mapie by zdobyć broń główną.";
				MSG[7] = "Naciśnij M by zobaczyć/schwoać mapę pełnoekranową";
			}
			case "fr": 
			{
				MSG[1] = "Abonne-toi au Maniaflash $h[maniaflash?firefight]firefight$h pour avoir les informations concernant les mises-à-jour et les rendez-vous";
				MSG[2] = "Mode de jeu créé par ToRRent";
				MSG[3] = "Appuie sur F8 pour personnaliser l'interface";
				MSG[4] = "Capture les objectifs pour ranimer tes coéquipiers et te soigner";
				MSG[5] = "Pour toute suggestion concernant le mode de jeu, merci d'aller $l[http://forum.maniaplanet.com/viewtopic.php?f=10&t=28177&start=0]ici$l";
				MSG[6] = "Collect weapon item located on map to get primary weapon.";
				MSG[7] = "Appuie sur M pour montrer/cacher la mini-map en plein écran";
			}
			case "it": 
			{
				MSG[1] = "Segui maniaflash $h[maniaflash?firefight]firefight$h per ot tenere le informazioni sul tema di aggiornamenti e riunioni";
				MSG[2] = "Il modo è stato creato grazie a ToRRent'a";
				MSG[3] = "Digiti F8 per modificare l’interfaccia";
				MSG[4] = "catturi le zone territoriali per rinascere la squadra e curarsi";
				MSG[5] = "Se hai suggestioni rispetti allo sviluppo del modo, scrivi $l[http://forum.maniaplanet.com/viewtopic.php?f=10&t=28177&start=0]qui$l";
				MSG[6] = "Collect weapon item located on map to get primary weapon.";
				MSG[7] = "Digiti M per vedere/nascondere la mappa su tutto lo schermo";
			}
			case "de": 
			{
				MSG[1] = "Abonniere den ManiaFlash $h[maniaflash?firefight]firefight$h um Informationen über Aktualisierungen und Treffen zu erhalten";
				MSG[2] = "Spielmodus erstellt durch ToRRent";
				MSG[3] = "Drücke F8 um die Oberfläche anzupassen";
				MSG[4] = "Erobere Ziele um Teamkameraden zu erlösen und sich selbst zu heilen";
				MSG[5] = "Verbesserungsvorschläge bitte $l[http://forum.maniaplanet.com/viewtopic.php?f=10&t=28177&start=0]hier$l";
				MSG[6] = "Collect weapon item located on map to get primary weapon.";
				MSG[7] = "Minimaps anzeigen/verbergen durch Drücken von M im Vollbildmodus";
			}
			default:
			{
				MSG[1] = "Follow maniaflash $h[maniaflash?firefight]firefight$h to get informations about updates and meetings";
				MSG[2] = "Game mode was created by ToRRent";
				MSG[3] = "Press F8 to customize interface";
				MSG[4] = "Capture objectives to revive teammates and heal yourself.";
				MSG[5] = "If you have suggestion about gamemode, go $l[http://forum.maniaplanet.com/viewtopic.php?f=10&t=28177&start=0]here$l";
				MSG[6] = "Collect weapon item located on map to get primary weapon.";
				MSG[7] = "Press M to show/hide full screen map";
			}
		}

		switch(rand)
		{
			case 1: UI.SendChat(Prefix^MSG[1]);
			case 2: UI.SendChat(Prefix^MSG[2]);
			case 3: UI.SendChat(Prefix^MSG[3]);
			case 4: UI.SendChat(Prefix^MSG[4]);
			case 5: UI.SendChat(Prefix^MSG[5]);
			case 6: UI.SendChat(Prefix^MSG[6]);
		}
	}	
}

Text UpdateLayerHUD()
{
	declare Text ClanColorA;
	declare Text ClanColorB;
	declare Text ClanColorC;
	if(Teams.existskey(0) && Teams.existskey(1))
	{
		if(G_ZoneClanList[1] == 0) ClanColorA = "EEE";
		else ClanColorA = TextLib::SubString(Teams[G_ZoneClanList[1]-1].ColorText, 1, 3);
		if(G_ZoneClanList[2] == 0) ClanColorB = "EEE";
		else ClanColorB = TextLib::SubString(Teams[G_ZoneClanList[2]-1].ColorText, 1, 3);
		if(G_ZoneClanList[3] == 0) ClanColorC = "EEE";
		else ClanColorC = TextLib::SubString(Teams[G_ZoneClanList[3]-1].ColorText, 1, 3);
	}
	else
	{
		ClanColorA = "DDD";
		ClanColorB = "DDD";
		ClanColorC = "DDD";
	}
	
	return """
<frame hidden="1" id="Frame_Overlay">
	<label posn="-65 -70 1" text="1: -" textsize="1" halign="left" id="Label_Primary"/>
	<label posn="-65 -74 1" text="2: -" textsize="1" halign="left" id="Label_Secondary"/>
	<quad posn="0 -63 0" halign="center" valign="center" sizen="39 8" style="EnergyBar" substyle="BgText"/>
	<quad posn="-10 -60 1" halign="center" sizen="6 6" image="{{{C_ImgModeDir}}}/hud_map_A.dds" colorize="{{{ClanColorA}}}"/>
	<quad posn="0 -60 1" halign="center" sizen="6 6" image="{{{C_ImgModeDir}}}/hud_map_B.dds" colorize="{{{ClanColorB}}}"/>
	<quad posn="10 -60 1" halign="center" sizen="6 6" image="{{{C_ImgModeDir}}}/hud_map_C.dds" colorize="{{{ClanColorC}}}"/>
</frame>
<script><!--	
main()
{
	declare Frame_Overlay <=> (Page.GetFirstChild("Frame_Overlay") as CMlFrame);
	declare Label_Primary <=> (Page.GetFirstChild("Label_Primary") as CMlLabel);
	declare Label_Secondary <=> (Page.GetFirstChild("Label_Secondary") as CMlLabel);
	while(True)
	{
		yield;
		if(InputPlayer == Null) continue;
		if(InputPlayer.Armor > 0)
		{
			Frame_Overlay.Visible = True;
			declare netread Net_PrimaryWeapon for UI = 0;
			switch(Net_PrimaryWeapon)
			{
				case 1: Label_Primary.Value = "1: Laser";
				case 2: Label_Primary.Value = "1: Plasma Gun";
				case 3: Label_Primary.Value = "1: Grenades";
				case 4: Label_Primary.Value = "1: Nucleus";
				case 5: Label_Primary.Value = "1: Shotgun";
				case 6: Label_Primary.Value = "1: BlowBomb";
				default: Label_Primary.Value = "1: -";
			}
			declare netread Integer[Text] Net_SecondaryWeapons for UI;
			if(Net_SecondaryWeapons.existskey(InputPlayer.Login))
			{
				switch(Net_SecondaryWeapons[InputPlayer.Login])
				{
					case 1: Label_Secondary.Value = "2: Rockets";
					case 2: Label_Secondary.Value = "2: Bouncing Rockets";
					case 3: Label_Secondary.Value = "2: Electric Pistol";
					default: Label_Secondary.Value = "2: -";
				}
			}
			else Label_Secondary.Value = "2: -";
		}
		else Frame_Overlay.Visible = False;		
	}
}
--></script>
	""";
}

Text UpdateLayerMarkers(Integer _A, Integer _B, Integer _C)
{
	declare ScreenRatio		= 9./16.;
	declare MarkerHeight	= 5.;
	declare MarkerWidth		= MarkerHeight * ScreenRatio;
	declare ImgGoalA		= C_ImgModeDir^"/hud_map_A.dds";
	declare ImgGoalB		= C_ImgModeDir^"/hud_map_B.dds";
	declare ImgGoalC		= C_ImgModeDir^"/hud_map_C.dds";
	//declare ImgPlayer 		= C_ImgModeDir^"/hud_map_A.dds";
	declare MLText 			= "";
	declare MarkerColor		= "";

	MLText = """
<script><!--
main() 
{
	declare GoalAArray = CMlFrame[Integer];
	declare GoalBArray = CMlFrame[Integer];
	declare GoalCArray = CMlFrame[Integer];
	declare I = 1;
	for(I, 1, {{{_A}}}) GoalAArray[I] = (Page.GetFirstChild("Goal_A"^I) as CMlFrame);
	for(I, 1, {{{_B}}}) GoalAArray[I] = (Page.GetFirstChild("Goal_B"^I) as CMlFrame);
	for(I, 1, {{{_C}}}) GoalAArray[I] = (Page.GetFirstChild("Goal_C"^I) as CMlFrame);
}
--></script>
""";
	declare Index = 1;
	for(Index, 1, _A)
	{
		if(G_ZoneClanList[1] == 0) MarkerColor = "DDD";
		else MarkerColor = TextLib::SubString(Teams[G_ZoneClanList[1]-1].ColorText, 1, 3);
		MLText ^= """
			<frame id="Goal_A{{{Index}}}">
				<quad sizen="{{{MarkerWidth}}} {{{MarkerHeight}}}" valign="center" halign="center" autoscale="False" image="{{{ImgGoalA}}}" colorize="{{{MarkerColor}}}"/>
			</frame>
		""";
	}
	for(Index, 1, _B)
	{
		if(G_ZoneClanList[2] == 0) MarkerColor = "DDD";
		else MarkerColor = TextLib::SubString(Teams[G_ZoneClanList[2]-1].ColorText, 1, 3);
		MLText ^= """
			<frame id="Goal_B{{{Index}}}">
				<quad sizen="{{{MarkerWidth}}} {{{MarkerHeight}}}" valign="center" halign="center" autoscale="False" image="{{{ImgGoalB}}}" colorize="{{{MarkerColor}}}"/>
			</frame>
		""";
	}
	for(Index, 1, _C)
	{
		if(G_ZoneClanList[3] == 0) MarkerColor = "DDD";
		else MarkerColor = TextLib::SubString(Teams[G_ZoneClanList[3]-1].ColorText, 1, 3);
		MLText ^= """
			<frame id="Goal_C{{{Index}}}">
				<quad sizen="{{{MarkerWidth}}} {{{MarkerHeight}}}" valign="center" halign="center" autoscale="False" image="{{{ImgGoalC}}}" colorize="{{{MarkerColor}}}"/>
			</frame>
		""";
	}

	/*foreach(Player in Players)
	{
		MarkerColor = TextLib::SubString(Teams[Player.CurrentClan-1].ColorText, 1, 3);
		MLText ^= """
		<frame id="Player_{{{Player.Login}}}">
			<quad sizen="{{{MarkerWidth}}} {{{MarkerHeight}}}" valign="center" halign="center" autoscale="False" image="{{{ImgPlayer}}}" colorize="{{{MarkerColor}}}"/>
		</frame>
		""";
	}*/

	return MLText;		
}

Void UpdateMarker()
{
	UIManager.UIAll.MarkersXML = "";
	declare ManiaLink = "";
	declare A = 0;
	declare B = 0;
	declare C = 0;
	foreach (Goal in MapLandmarks_Gauge) 
	{
		declare PosX = Goal.Position.X;
		declare PosY = Goal.Position.Y + 0.2;
		declare PosZ = Goal.Position.Z;
		if (Goal.Tag == "Zone A") 
		{
			A+=1;
			ManiaLink ^= """<marker manialinkframeid="Goal_A{{{A}}}" pos="{{{PosX}}} {{{PosY}}} {{{PosZ}}}" distmax="400" hudvisibility="Always" />""";
		} 
		else if (Goal.Tag == "Zone B") 
		{
			B+=1;
			ManiaLink ^= """<marker manialinkframeid="Goal_B{{{B}}}" pos="{{{PosX}}} {{{PosY}}} {{{PosZ}}}" distmax="400" hudvisibility="Always" />""";
		}
		else if (Goal.Tag == "Zone C") 
		{
			C+=1;
			ManiaLink ^= """<marker manialinkframeid="Goal_C{{{C}}}" pos="{{{PosX}}} {{{PosY}}} {{{PosZ}}}" distmax="400" hudvisibility="Always" />""";
		}
	}
	foreach (MapLandmark in MapLandmarks_ObjectAnchor) 
	{
		declare PosX = MapLandmark.Position.X;
		declare PosY = MapLandmark.Position.Y+1;
		declare PosZ = MapLandmark.Position.Z;
		declare ImagePath = C_ImgModeDir^"/IconWeapon"^MapLandmark.Tag^".dds";
		ManiaLink ^= """
			<marker imageurl="{{{ImagePath}}}" pos="{{{PosX}}} {{{PosY}}} {{{PosZ}}}" hudvisibility="Always" distmax="{{{G_ObjectDetector}}}" />
		""";
	}
	/*foreach (Player in Players)
	{
		ManiaLink ^= """
			<marker manialinkframeid="Player_{{{Player.Login}}}" playerlogin="{{{Player.Login}}}" isturning="false" hudvisibility="Always" minimapvisibility="WhenInFrame" />
		""";	
	}*/
	Layers::Update("Markers", UpdateLayerMarkers(A, B, C));
	UIManager.UIAll.MarkersXML = ManiaLink;
}

Text UpdateLayerRulesReminder() {
	declare Text HighlightColor		= "fA0";
	declare Text TitleText 			= TextLib::Compose(_("Welcome to %1!"), "Firefight");
	
	return """
<dico>
   <language id="en">
    	<rule1>- Control 3 zones of goals or eliminate all enemies to win the round.</rule1>
    	<rule2>- Capture objectives to revive teammates and heal yourself (2 armors).</rule2>
    	<rule3>- Search for weapon items on map to get primary weapon.</rule3>
    	<rule4>- Controlled zone can be stolen by the opposing team.</rule4>
   </language>
   <language id="pl">
    	<rule1>- Zdobądz 3 strefy terytorialne lub wyeliminuj rywali by wygrać rundę.</rule1>
    	<rule2>- Zdobywaj cele by odrodzić wyeliminowanych i się uleczyć(2 pancerze).</rule2>
    	<rule3>- Zdobądź bonus na mapie by mieć 2 bronie.</rule3>
    	<rule4>- Rywale mogą przechwycić twoje strefy terytorialne.</rule4>
   </language>
   <language id="fr">
		<rule1>- Prends le contrôle de 3 zones d'objectifs ou élimine tous les adversaires pour gagner la manche.</rule1>
		<rule2>- Capture les objectifs pour ranimer tes coéquipiers et te soigner (2 armures).</rule2>
		<rule3>- Search for weapon items on map to get primary weapon.</rule3>
		<rule4>- Les zones contrôlées peuvent être volées par l'équipe adverse</rule4>
   </language>
   <language id="ru">
   		<rule1>- Контролируйте 3 зоны с флагами или уничтожьте всех врагов, чтобы выиграть раунд.</rule1>
   		<rule2>- Захват целей возрождает товарищей по команде и исцеляет вас (2 брони).</rule2>
   		<rule3>- Search for weapon items on map to get primary weapon.</rule3>
   		<rule4>- Контролируемую зону может захватить вражеская команда.</rule4>
   </language>
   <language id="it">
   		<rule1>- Cattura 3 zone territoriali o Elizina riali per vincere il turno.</rule1>
   		<rule2>- cattura destinazioni per rinascere eliminati e curarsi(2 armature).</rule2>
   		<rule3>- Search for weapon items on map to get primary weapon.</rule3>
   		<rule4>- Rivali possono prendere le tue zone territoriali.</rule4>
   </language>
   <language id="de">
    	<rule1>- Erobern Sie die 3 Zielzonen oder eliminieren Sie alle Gegner, um die Runde zu gewinnen.</rule1>
    	<rule2>- Nehmen Sie die Ziele ein, um ihre Teamkameraden wiederzubeleben und sich selbst zu heilen (2 Schilde).</rule2>
    	<rule3>- Search for weapon items on map to get primary weapon.</rule3>
    	<rule4>- Eroberte Zonen können vom gegnerischen Team gestohlen werden.</rule4>
    </language>
</dico>
<frame id="RulesReminderMainFrame" hidden="true" posn="0 13 100" >
	<quad posn="0 25 0" sizen="162 70" bgcolor="FFFA" image="{{{C_ImgModeDir}}}/WelcomeBg.dds" halign="center" valign="center"/>
	<label posn="-71 46 1" sizen="86 5" text="{{{TitleText}}}" textsize="4" textcolor="fA0" style="TextValueSmallSm"/>
	<label posn="-73 39 1" sizen="146 26" textid="rule1"/>
	<label posn="-73 33 1" sizen="146 26" textid="rule2"/>
	<label posn="-73 27 1" sizen="146 26" textid="rule3"/>
	<label posn="-73 21 1" sizen="146 26" textid="rule4"/>
	<label posn="0 12 1" halign="center" text="{{{TextLib::Compose(_("Press '$<%1F1$>' to close this window."), "$"^HighlightColor)}}}" textsize="3" />
</frame>
<script><!--
	while(InputPlayer == Null) yield;
	
	if(InputPlayer.User.LadderPoints > 3000) {
		return;
	}

	declare RulesReminderMainFrame 	<=> (Page.GetFirstChild("RulesReminderMainFrame") as CMlFrame);
	
	while(True) {
		yield;
		
		RulesReminderMainFrame.Show();
		
		foreach(Event in PendingEvents) {
			switch(Event.Type){
				case CMlEvent::Type::KeyPress: {
					if(Event.CharPressed == "2424832" ) { // F1
						RulesReminderMainFrame.Visible = !RulesReminderMainFrame.Visible;
						return; // End of this behavior
					}
				}
			}
		}
	}
--></script>""";
}

// Update Progression layer
Text UpdateLayerProgression(Integer _Show)
{
	declare Integer ZoneA;
	declare Real RZoneA;
	declare Integer ClanA;
	declare Text ClanColorA;
	declare Integer ZoneB;
	declare Real RZoneB;
	declare Integer ClanB;
	declare Text ClanColorB;
	declare Integer ZoneC;
	declare Real RZoneC;
	declare Integer ClanC;
	declare Text ClanColorC;
	declare Text ClanColor1;
	declare Text ClanColor2;
	if(Teams.existskey(0)) ClanColor1 = TextLib::ColorToText(Teams[0].ColorPrimary);
	else ClanColor1 = "11F";
	if(Teams.existskey(1)) ClanColor2 = TextLib::ColorToText(Teams[1].ColorPrimary);
	else ClanColor2 = "F11";
	foreach(LandmarkGauge in MapLandmarks_Gauge) 
	{
		if (LandmarkGauge.Gauge.ValueReal <= 0. || LandmarkGauge.Gauge.ValueReal > 1.) continue;
		if (LandmarkGauge.Tag == "Zone A") 
		{
			ZoneA = MathLib::NearestInteger(LandmarkGauge.Gauge.ValueReal * 100.);
			RZoneA = LandmarkGauge.Gauge.ValueReal;
			ClanA = LandmarkGauge.Gauge.Clan;
			if(G_ZoneClanList[1] == 0) ClanColorA = "$fff";
			else ClanColorA = Teams[G_ZoneClanList[1]-1].ColorText;
		}
		if (LandmarkGauge.Tag == "Zone B")
		{
			ZoneB = MathLib::NearestInteger(LandmarkGauge.Gauge.ValueReal * 100.);
			RZoneB = LandmarkGauge.Gauge.ValueReal;
			ClanB = LandmarkGauge.Gauge.Clan;
			if(G_ZoneClanList[2] == 0) ClanColorB = "$fff";
			else ClanColorB = Teams[G_ZoneClanList[2]-1].ColorText;
		}
		if (LandmarkGauge.Tag == "Zone C") 
		{
			ZoneC = MathLib::NearestInteger(LandmarkGauge.Gauge.ValueReal * 100.);
			RZoneC = LandmarkGauge.Gauge.ValueReal;
			ClanC = LandmarkGauge.Gauge.Clan;
			if(G_ZoneClanList[3] == 0) ClanColorC = "$fff";
			else ClanColorC = Teams[G_ZoneClanList[3]-1].ColorText;
		}	
	}
	declare Text ManiaLink = "";
	ManiaLink = """
<manialink version="1" name="Firefight:Progression Layer">
<dico>
   <language id="en">
    	<prog>Zone progression</prog>
   </language>
   <language id="fr">
   		<prog>Progression de la zone</prog>
   </language>
   <language id="ru">
   		<prog>Прогресс зоны</prog>
   </language>
   <language id="it">
   		<prog>Sviluppo della conquista</prog>
   </language>
   <language id="de">
   		<prog>Zone Fortschritt</prog>
   </language>
   <language id="pl">
    	<prog>Postęp zdobywania</prog>
   </language>
</dico>
<frame posn="{{{C_LayerProgressionPosition.X}}} {{{C_LayerProgressionPosition.Y}}} {{{C_LayerProgressionPosition.Z}}}" id="Frame_Progression" hidden="{{{_Show}}}">
	<quad posn="-23.5 -44 0" sizen="54 19" halign="left" valign="center" style="EnergyBar" substyle="BgText"/>
	<quad posn="12 -35 1" sizen="6 5" bgcolor="FFFA" image="{{{C_ImgModeDir}}}/DefendersLeft.dds" colorize="{{{ClanColor1}}}"/>
	<quad posn="22 -35 1" sizen="6 5" bgcolor="FFFA" image="{{{C_ImgModeDir}}}/DefendersLeft.dds" colorize="{{{ClanColor2}}}"/>
	<label posn="-21.5 -38 1" sizen="31 5" textid="prog" textsize="2" textemboss="1" valign="center2"/>
	<label posn="-20 -42 1" halign="left" valign="center" textsize="1" textemboss="1" text="{{{TextLib::Compose(_("%1A:$g"), ClanColorA)}}}" style="TextTitle3" sizen="10 6"/>
	<label posn="14 -42 1" halign="left" valign="center" textemboss="1" textsize="1" text="{{{TextLib::ToText(G_PlayerCountA[1])}}}" style="TextTitle3"/>
	<label posn="18 -42 1" halign="left" valign="center" textemboss="1" text="vs" style="TextTitle3" textsize="1"/>
	<label posn="24 -42 1" halign="left" valign="center" textemboss="1" textsize="1" text="{{{TextLib::ToText(G_PlayerCountA[2])}}}" style="TextTitle3"/>
	<gauge posn="-16 -37 1" sizen="29 10" halign="left" valign="middle" style="EnergyBar" ratio="{{{RZoneA}}}" clan="{{{ClanA}}}" drawbg="0" drawblockbg="1"/>
	<label posn="-20 -46 1" halign="left" valign="center" textsize="1" textemboss="1" text="{{{TextLib::Compose(_("%1B:$g"), ClanColorB)}}}" style="TextTitle3" sizen="10 6"/>
	<label posn="14 -46 1" halign="left" valign="center" textemboss="1" textsize="1" text="{{{TextLib::ToText(G_PlayerCountB[1])}}}" style="TextTitle3"/>
	<label posn="18 -46 1" halign="left" valign="center" textemboss="1" text="vs" style="TextTitle3" textsize="1"/>
	<label posn="24 -46 1" halign="left" valign="center" textemboss="1" textsize="1" text="{{{TextLib::ToText(G_PlayerCountB[2])}}}" style="TextTitle3"/>
	<gauge posn="-16 -41 1" sizen="29 10" halign="left" valign="middle" style="EnergyBar" ratio="{{{RZoneB}}}" clan="{{{ClanB}}}" drawbg="0" drawblockbg="1"/>
	<label posn="-20 -50 1" halign="left" valign="center" textsize="1" textemboss="1" text="{{{TextLib::Compose(_("%1C:$g"), ClanColorC)}}}" style="TextTitle3" sizen="10 6"/>
	<label posn="14 -50 1" halign="left" valign="center" textemboss="1" textsize="1" text="{{{TextLib::ToText(G_PlayerCountC[1])}}}" style="TextTitle3"/>
	<label posn="18 -50 1" halign="left" valign="center" textemboss="1" text="vs" style="TextTitle3" textsize="1"/>
	<label posn="24 -50 1" halign="left" valign="center" textemboss="1" textsize="1" text="{{{TextLib::ToText(G_PlayerCountC[2])}}}" style="TextTitle3"/>
	<gauge posn="-16 -45 1" sizen="29 10" halign="left" valign="middle" style="EnergyBar" ratio="{{{RZoneC}}}" clan="{{{ClanC}}}" drawbg="0" drawblockbg="1"/>
</frame>
<script><!--
main()
{
	declare Frame_Progression 	<=> (Page.GetFirstChild("Frame_Progression") 	as CMlFrame);
	declare netread Vec3 	Net_Firefight_ProgressionLayerPosition	for Teams[0];
	declare Vec3 PrevProgressionLayerPosition;

	while (True) 
	{
		sleep(2000);
		if (!PageIsVisible) continue;
		if (PrevProgressionLayerPosition != Net_Firefight_ProgressionLayerPosition) 
		{
			PrevProgressionLayerPosition = Net_Firefight_ProgressionLayerPosition;
			Frame_Progression.RelativePosition = Net_Firefight_ProgressionLayerPosition;
		}
	}
}
--></script>
</manialink>
""";
	return ManiaLink;
}

// Build capture progress layer
Text UpdateLayerProgressBar()
{
	declare Text ML = "";
	ML = """
<manialink version="1" name="Firefight:Real-Time Progress Bar">
<dico>
   <language id="en">
      <label0>Loading data...</label0>
      <label1>Decapturing opponent zone...</label1>
      <label2>Clear all goals in zone from enemies to begin capture.</label2>
      <label3>Zone captured.</label3>
      <label4>Defending captured zone...</label4>
      <label5>Capturing the zone...</label5>
   </language>
   <language id="fr">
      <label0>Chargement des données...</label0>
      <label1>Délivrance d'une zone adverse...</label1>
      <label2>Débarrasse de tout adversaire les objectifs d'une zone pour commencer la capture.</label2>
      <label3>Zone capturée.</label3>
      <label4>Défense d'une zone capturée...</label4>
      <label5>Capture d'une zone...</label5>
   </language>
   <language id="ru">
   	  <label0>Загрузка данных...</label0>
   	  <label1>Дезахват зоны противника...</label1>
   	  <label2>Уничтожьте всех врагов в зоне флагов, чтобы начать захват.</label2>
   	  <label3>Зона захвачена.</label3>
   	  <label4>Защита захваченной зоны...</label4>
   	  <label5>Захват зоны...</label5>
   </language>
   <language id="it">
   	  <label0>Caricamento...</label0>
   	  <label1>Conquista del territorio di un nemico...</label1>
   	  <label2>Pulisci i Mast Della zona dagli avversari per cominciare a catturare.</label2>
   	  <label3>La zona presa.</label3>
   	  <label4>La difesa Della zona presa...</label4>
   	  <label5>La conquista della zona...</label5>
   </language>
   <language id="de">
   		<label0>Lade daten...</label0>
   		<label1>Befreie gegnerische Zone...</label1>
   		<label2>Säubere alle Ziele in der Zone von Gegnern um die Eroberung zu beginnen.</label2>
   	  	<label3>Zone erobert.</label3>
   	  	<label4>Verteidige eroberte Zone...</label4>
   	 	<label5>Zone erobern...</label5>
   </language>
   <language id="pl">
      <label0>Ładowanie...</label0>
      <label1>Przechwytywanie terytorium wroga...</label1>
      <label2>Oczyść maszty strefy z przeciwników bo rozpocząć zdobywanie.</label2>
      <label3>Strefa zdobyta.</label3>
      <label4>Obrona zdobytej strefy...</label4>
      <label5>Zdobywanie strefy...</label5>
   </language>
</dico>
	<frame class="LibCustomUI_Module" id="FireFight_GaugeCapture">
		<frame posn="0 -51" id="Frame_Capture">
			<quad posn="0 0 2" sizen="128 20" halign="center" valign="center" image="{{{C_ImgModeDir}}}/Structure.dds" />
			<label posn="0 -2.5 3" halign="center" textsize="3" textemboss="1" textprefix="$bbb" textid="label0" id="Label_Goal" style="TextButtonBig"/>
			<label posn="0 13 3" halign="center" textsize="3" textemboss="1" style="TextCreditsTitle" textid="label1" hidden="1" textprefix="$o" id="Label_Info_1"/>
			<label posn="0 13 3" halign="center" textsize="3" textemboss="1" style="TextCreditsTitle" textid="label2" hidden="1" textprefix="$o" id="Label_Info_2"/>
			<label posn="0 13 3" halign="center" textsize="3" textemboss="1" style="TextCreditsTitle" textid="label3" hidden="1" textprefix="$o" id="Label_Info_3"/>
			<label posn="0 13 3" halign="center" textsize="3" textemboss="1" style="TextCreditsTitle" textid="label4" hidden="1" textprefix="$o" id="Label_Info_4"/>
			<label posn="0 13 3" halign="center" textsize="3" textemboss="1" style="TextCreditsTitle" textid="label5" hidden="1" textprefix="$o" id="Label_Info_5"/>
			<gauge posn="0 8 2" sizen="124 10.4" halign="center" style="EnergyBar" drawbg="1" drawblockbg="1" id="Gauge_Capture" />
		</frame>
	</frame>	
<script><!--
#Include "MathLib" as ML
main() 
{
	declare Frame_Capture 	<=> (Page.GetFirstChild("Frame_Capture") 	as CMlFrame);
	declare Label_Capture 	<=> (Page.GetFirstChild("Label_Capture") 	as CMlLabel);
	declare Label_Info_1	<=> (Page.GetFirstChild("Label_Info_1")		as CMlLabel);
	declare Label_Info_2	<=> (Page.GetFirstChild("Label_Info_2")		as CMlLabel);
	declare Label_Info_3	<=> (Page.GetFirstChild("Label_Info_3")		as CMlLabel);
	declare Label_Info_4	<=> (Page.GetFirstChild("Label_Info_4")		as CMlLabel);
	declare Label_Info_5	<=> (Page.GetFirstChild("Label_Info_5")		as CMlLabel);
	declare Label_Goal 		<=> (Page.GetFirstChild("Label_Goal") 		as CMlLabel);
	declare Gauge_Capture 	<=> (Page.GetFirstChild("Gauge_Capture") 	as CMlGauge);
	{{{CustomUI::InjectMLInit()}}}
	while (True) 
	{
		yield;
		if (InputPlayer == Null) continue;
		if (!PageIsVisible) continue;
		
		{{{CustomUI::InjectMLLoop()}}}
		
		declare CSmPlayer TargetPlayer;
		if (GUIPlayer != Null) TargetPlayer <=> GUIPlayer;
		else TargetPlayer <=> InputPlayer;

		Label_Info_1.Hide();
		Label_Info_2.Hide();
		Label_Info_3.Hide();		
		Label_Info_4.Hide();
		Label_Info_5.Hide();
		
		if (TargetPlayer.SpawnStatus == CSmPlayer::ESpawnStatus::Spawned && TargetPlayer.CapturedLandmark != Null && TargetPlayer.CapturedLandmark.Gauge != Null && (TargetPlayer.CapturedLandmark.Tag == "Zone A" || TargetPlayer.CapturedLandmark.Tag == "Zone B" || TargetPlayer.CapturedLandmark.Tag == "Zone C")) 
		{
			if (!Frame_Capture.Visible) Frame_Capture.Visible = True;
			Gauge_Capture.Ratio = TargetPlayer.CapturedLandmark.Gauge.ValueReal;
			Gauge_Capture.Clan = TargetPlayer.CapturedLandmark.Gauge.Clan;
			Label_Goal.Value = TargetPlayer.CapturedLandmark.Tag^"$dda  "^ML::FloorInteger(TargetPlayer.CapturedLandmark.Gauge.ValueReal * 100.)^"%";
			if(TargetPlayer.CapturedLandmark.Gauge.Speed < 0)
			{
				Label_Info_1.Show();
				Label_Info_2.Hide();
				Label_Info_3.Hide();		
				Label_Info_4.Hide();
				Label_Info_5.Hide();
			}
			else if(TargetPlayer.CapturedLandmark.Gauge.Speed == 0)
			{
				if(TargetPlayer.CapturedLandmark.Gauge.Clan != TargetPlayer.CurrentClan)
				{
					Label_Info_1.Hide();
					Label_Info_2.Show();
					Label_Info_3.Hide();		
					Label_Info_4.Hide();
					Label_Info_5.Hide();
				}	
				else if(TargetPlayer.CapturedLandmark.Gauge.ValueReal == 1.)
				{
					Label_Info_1.Hide();
					Label_Info_2.Hide();
					Label_Info_3.Show();		
					Label_Info_4.Hide();
					Label_Info_5.Hide();
				}
				else
				{
					Label_Info_1.Hide();
					Label_Info_2.Hide();
					Label_Info_3.Hide();		
					Label_Info_4.Show();
					Label_Info_5.Hide();
				}
			}
			else if(TargetPlayer.CapturedLandmark.Gauge.Speed > 1)
			{
				Label_Info_1.Hide();
				Label_Info_2.Hide();
				Label_Info_3.Hide();		
				Label_Info_4.Hide();
				Label_Info_5.Show();
			}

		} 
		else if (Frame_Capture.Visible) 
		{
			Frame_Capture.Visible = False;
		}
	}
}
--></script>
</manialink>	
""";
	
	return ML;	
}

Void SelectClasses(Integer _TimeToChoose) 
{
	---SelectClasses---
}

Void DoWarmUp() 
{
	XmlRpc::BeginWarmUp();
	
	// Shutdown the poles during warmup
	foreach (Goal in MapLandmarks_Gauge) {
		Goal.Gauge.Clan = 0;
		Goal.Gauge.Speed = 0;
		Goal.Gauge.Value = 0;
		Goal.Gauge.Max = 1000;
		Goal.Gauge.Captured = False;
	}
	
	UIManager.UIAll.UISequence = CUIConfig::EUISequence::Playing;
	UIManager.UIAll.BigMessageSound = CUIConfig::EUISound::PhaseChange;
	UIManager.UIAll.BigMessageSoundVariant = 0;
	if (G_Override_NeedWarmUp)
	{
		UIManager.UIAll.BigMessage = TextLib::Compose("$f90%1", _("Pause"));
		UIManager.UIAll.StatusMessage = _("Press F6 once you're ready.");
	}	
	else
	{
		UIManager.UIAll.BigMessage = TextLib::Compose("$f90%1", _("Warm-up"));
		UIManager.UIAll.StatusMessage = _("2 players needed in each team.");
	}

	// Load Items
	ObjectDestroyAll();
	foreach (MapLandmark in MapLandmarks_ObjectAnchor) 
	{
		declare ObjectSpawned for MapLandmark = False;
		declare ObjectNextSpawn for MapLandmark = Now;
		ObjectSpawned = False;
		ObjectNextSpawn = Now + 3000;
	}
	
	// Wait players sycnhro
	Mode::Synchro_DoBarrier();
	SM::UnspawnAllPlayers();
	foreach (Player in AllPlayers) {
		SetPlayerClan(Player, Player.RequestedClan);
		// @MM
		//SetPlayerClan(Player, MM_GetRequestedClan(Player));
		if (Player.CurrentClan == 1) WarmUp2::SetPlayerGroup(Player, "Clan1");
		else if (Player.CurrentClan == 2) WarmUp2::SetPlayerGroup(Player, "Clan2");
	}
	
	WarmUp2::Clean();
	WarmUp2::Begin();
	WarmUp2::Fill();
	
	declare WarmUpTime = 20;
	if(G_WarmUpDuration <= 20) WarmUpTime = 20;
	else WarmUpTime = G_WarmUpDuration;

	declare PrevWarmUpDuration = WarmUpTime-1;
	
	while (!WarmUp2::Stop()) {
		MB_Yield();
		ManageCommand();
		ForceClublinkReload();
		SpawnWeaponItems();
		
		// Let the server sleep if there's no players on it
		if (PlayersNbTotal <= 0) continue;
		
		foreach (Player in Players) {
			//if (Player.CurrentClan != Player.RequestedClan) {
			// @MM
			//declare RequestedClan = MM_GetRequestedClan(Player);
			if (Player.CurrentClan != Player.RequestedClan) {
				UnspawnPlayer(Player);
				SetPlayerClan(Player, Player.RequestedClan);
				// @MM
				//SetPlayerClan(Player, RequestedClan);
				if (Player.CurrentClan == 1) WarmUp2::SetPlayerGroup(Player, "Clan1");
				else if (Player.CurrentClan == 2) WarmUp2::SetPlayerGroup(Player, "Clan2");
			}
		}
		
		if (PrevWarmUpDuration != WarmUpTime) {
			PrevWarmUpDuration = WarmUpTime;
			
			declare LongTimer = WarmUpTime*1000;
			declare ShortTimer = 5000;
			if (LongTimer <= 0) { LongTimer = 0; ShortTimer = 0; }
			
			WarmUp2::SetGroupTimers("Clan1", [ShortTimer => [-1, 2], LongTimer => [1, 2]]);
			WarmUp2::SetGroupTimers("Clan2", [ShortTimer => [-1, 2], LongTimer => [1, 2]]);
		}
		
		WarmUp2::Fill();
		WarmUp2::Loop();
		if (WarmUp2::Updated()) 
		{
			if (G_Override_NeedWarmUp) UpdateLayerScoresTable(C_SequencePause);
			else UpdateLayerScoresTable(C_SequenceWarmUp);
			Clublink::DefineTeamAuto(True);
		}
		
		foreach(Player in Players) {
			if (Player.SpawnStatus == CSmPlayer::ESpawnStatus::NotSpawned) {
				declare Spawn <=> Map::GetPlayerSpawn("Spawn1", 0);
				if (Spawn != Null) {
					SM::SpawnPlayer(Player, Player.CurrentClan, Spawn);
					SetPlayerWeapon(Player, CSmMode::EWeapon::Laser, False);
					SetPlayerAmmoMax(Player, CSmMode::EWeapon::Laser, 1);
					ActionLoad(Player, CSmMode::EActionSlot::Slot_A, NullId);
					ActionLoad(Player, CSmMode::EActionSlot::Slot_B, NullId);
					ActionBind(Player, CSmMode::EActionSlot::Slot_A, CSmMode::EActionInput::None);
					ActionBind(Player, CSmMode::EActionSlot::Slot_B, CSmMode::EActionInput::None);
				}
			}
		}
		
		WarmUp2::ManageEvents();
	}
	
	WarmUp2::End();
	
	UIManager.UIAll.UISequence = CUIConfig::EUISequence::EndRound;
	UIManager.UIAll.StatusMessage = "";
	UIManager.UIAll.BigMessage = "";
	SM::UnspawnAllPlayers();
	ObjectDestroyAll();
	
	// ---------------------------------- //
	// Update the players clublinks
	if (S_ForceClublinkTeam1 == "" && S_ForceClublinkTeam2 == "") Clublink::DefineTeamAuto();
	else Clublink::DefineTeamFromUrl(S_ForceClublinkTeam1, S_ForceClublinkTeam2);
	
	XmlRpc::EndWarmUp();
}