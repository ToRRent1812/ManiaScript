// Search and destroy with dolars to get better weapon
#Extends "Modes/Shootmania/ShopCore.Script.txt"

#Const CompatibleMapTypes	"SNDArena"
#Const Version				"2014-09-21"
#Const ScriptName			"SND.Script.txt"

#Include "MathLib" as MathLib
#Include "TextLib" as TextLib
#Include "Libs/Nadeo/Victory.Script.txt" as Victory
#Include "Libs/Nadeo/CustomUI.Script.txt" as CustomUI
#Include "Libs/Nadeo/ShootMania/SM.Script.txt" as SM
#Include "Libs/Nadeo/ShootMania/Map.Script.txt" as Map
#Include "Libs/Nadeo/ShootMania/Score.Script.txt" as Score
#Include "Libs/Nadeo/ShootMania/SpawnScreen.Script.txt" as SpawnScreen

#Setting S_RoundTime			105		as _("Round time in seconds")
#Setting S_PlantingTime			4		as _("Planting/Defusing time in seconds")
#Setting S_BombCountdown		35		as _("Bomb timer in seconds")
#Setting S_MapPointsLimit		6		as _("Number of points to win the map")
#Setting S_BlueBot 				0 		as _("Number of blue test bots")
#Setting S_RedBot 				0 		as _("Number of red test bots")	
// Clublinks settings
#Setting S_UsePlayerClublinks	False	as _("Use players clublinks")	// Use the players clublinks, or otherwise use the default teams
#Setting S_ForceClublinkTeam1	""		as "<hidden>"	// Force the Clublink of team 1 (format: http://www.example.com/MyTeam.Club.xml)
#Setting S_ForceClublinkTeam2	""		as "<hidden>"	// Force the Clublink of team 2 (format: http://www.example.com/MyTeam.Club.xml)

#Const Description   			_("RULES: Famous Counter-Strike game mode is finally on Shootmania.")

#Const C_StateIdle 				0 	// Standard game state, attackers are trying to plant the bomb
#Const C_StatePlanted 			1 	// When bomb was planted
#Const C_StateExploded 			2 	// When bomb explode
#Const C_StateDefused 			3 	// When bomb was defused

#Const C_Object  				"Laser"

declare Integer[Integer]			G_ClansMapPoints;		// Number of points cumulated on one map for each clan
declare Integer[Integer]			G_PlayersAlive;			// How many players are alive in specific team
declare Integer						G_PlantedOn; 			// Where bomb was planted
declare Integer 					G_GameState;			// Current game state
declare CSmPlayer 					G_PlayerWithBomb;		// Player who has bomb
declare Integer 					G_AttackingClan;		// Which clan is attacking
declare Integer 					G_LastProgressUpdate;	// Time of the last progrresion layer update
declare Integer 					G_LastSettingsUpdate; 	// Time of the last setting layer update
declare Integer 					G_LastTempUpdate;

***LogVersion***
***
MB_LogVersion(ScriptName, Version);
MB_LogVersion(SM::GetScriptName(), SM::GetScriptVersion());
MB_LogVersion(Map::GetScriptName(), Map::GetScriptVersion());
MB_LogVersion(CustomUI::GetScriptName(), CustomUI::GetScriptVersion());
MB_LogVersion(Score::GetScriptName(), Score::GetScriptVersion());
MB_LogVersion(Layers::GetScriptName(), Layers::GetScriptVersion());
MB_LogVersion(Message::GetScriptName(), Message::GetScriptVersion());
MB_LogVersion(SpawnScreen::GetScriptName(), SpawnScreen::GetScriptVersion());
***

***InitServer***
***
MB_UseSectionRound		= True;
MB_UseSectionTurn		= False;
MB_UsePlayerClublinks	= S_UsePlayerClublinks;
***

***StartServer***
***
UseClans			= True;
UseProtectClanmates	= False;
UseLaserSkewering	= False;
UseAmmoBonusOnHit	= False;
UsePlayerTagging 	= True;

declare ModeName = "Search & Destroy";
declare ModeObjectives = TextLib::Compose(_("$<%1Attackers: $>Plant the bomb on 1 bombsite and wait for explosion to win.\n$<%1Defenders: $>Protect bombsites by %2 sec. or eliminate attackers to win the round"), "$"^SpawnScreen::GetModeColor(), TextLib::ToText(S_RoundTime));
declare ModeConditions = TextLib::Compose(_("$<%11. $>A game is divided in rounds.\n$<%12. $>The first team with %2 points wins the map.\n$<%13. $>Before round you can buy equipment using money.\n$<%14. $>You can earn money by hit, headshot, kill, capture, win and loss."), "$"^SpawnScreen::GetModeColor(), TextLib::ToText(S_MapPointsLimit));

SpawnScreen::AddSubsection(_("Type"), _("Team versus Team"), 0.);
SpawnScreen::AddSubsection(_("Objectives"), ModeObjectives, 20.);
SpawnScreen::AddSubsection(_("Conditions"), ModeConditions, 55.);
SpawnScreen::CreatePrettyRules(ModeName);
SM::SetupDefaultVisibility();

// Init movable elements
CustomUI::Load();
CustomUI::Add("PlayersList_1", <-160., 67.>, <46., 90.>, "top", "left");
CustomUI::Add("PlayersList_2", <160., 67.>, <46., 90.>, "top", "right");
CustomUI::Add("SND_GaugeCapture", <0., -45.>, <130., 20.>, "center", "center");
CustomUI::Build();

// Create layers
Layers::Create("ProgressBar"); // Specific capture progress
Layers::Create("Markers"); // markers layer
Layers::Create("HUD"); // Hud layer when player is spawned
Layers::Create("BombTimer"); // Hud layer replacing timer with bomb icon
Layers::Create("RulesReminder", UpdateLayerRulesReminder());
Layers::SetType("Markers", CUILayer::EUILayerType::Markers);
Layers::SetType("RulesReminder", CUILayer::EUILayerType::CutScene);
Layers::Attach("RulesReminder");

// Init scores table
ST2::SetStyle("LibST_SMBaseTeams");
ST2::SetStyle("LibST_SMBasePoints");
ST2::SetStyle("LibST_SMWithLegends");
ST2::SetSize(<197., -1.>, <190., -1.>, <190., -1.>);
ST2::SetBackgroundImage("file://Media/Manialinks/Shootmania/ScoresTable/bg-storm.dds", <0., 5.>, <240., 98.>);
ST2::SetTeamImage(1, "file://Media/Manialinks/Shootmania/ScoresTable/teamversus-left.dds", <0., 3.8>, <120.0, 25.>);
ST2::SetTeamImage(2, "file://Media/Manialinks/Shootmania/ScoresTable/teamversus-right.dds", <0., 3.8>, <120.0, 25.>);
ST2::SetFormat(2, 6);
MB_SetScoresTableStyleFromXml(S_ScoresTableStylePath);
ST2::CreateCol("ST_Captured", _("Objectives"), "0", 4.5, 90.);
ST2::CreateCol("ST_MVP", _("MVP"), "$fc0", 4.5, 95.);
ST2::SetColTextAlign("ST_Captured", CMlControl::AlignHorizontal::HCenter);
ST2::SetColTextAlign("ST_MVP", CMlControl::AlignHorizontal::HCenter);
ST2::SetColTextAlign("LibST_SMPoints", CMlControl::AlignHorizontal::HCenter);
ST2::SetColTextAlign("LibST_SMRoundPoints", CMlControl::AlignHorizontal::HCenter);
ST2::SetColLegend("LibST_SMRoundPoints", _("Round"));
ST2::SetColLegend("LibST_SMPoints", _("Score"));
ST2::SetColWidth("LibST_Name", 20.);
ST2::SetColWidth("LibST_SMRoundPoints", 4.5);
ST2::SetColWidth("LibST_SMPoints", 6.);
ST2::Build("SM");

// Init Item
ItemList_Begin();
G_ObjectId[C_Object] = ItemList_Add("PickUpFF/Laser.Item.gbx");
ItemList_End();
***					

***StartMatch***
***
// Reset clan scores
ClanScores[1] = 0;
ClanScores[2] = 0;
***

***InitMap***
***
declare Integer		ClanMapWinner;		// Clan who win the map
***

***StartMap***
***
UIManager.UIAll.MarkersXML = "";
UIManager.UIAll.ScreenIn3dHideVersus = False;
UIManager.UIAll.ScreenIn3dHideScoreSummary = True;
G_ClansMapPoints	= [1 => 0, 2 => 0];
G_PlantedOn 		= 0;
G_AttackingClan 	= 1;
ClanMapWinner		= 0;
// reset custom scores table data
foreach(Score in Scores)
{
	declare CurrentCapGoals for Score = 0;
	CurrentCapGoals = 0;
	declare CurrentMVP for Score = 0;
	CurrentMVP = 0;
}
// Init scores
Score::MatchBegin();
ST2::ClearScores();

// Init players
foreach (Player in Players)
{
	SetPlayerClan(Player, Player.RequestedClan);
	declare UI <=> UIManager.GetUI(Player);
	if(UI == Null) continue;
	declare netwrite Net_Cash for UI = S_StartCash;
	Net_Cash = S_StartCash;
	declare netwrite Net_Bought for UI = [False, False, False, False, False, False, False, False, False, False, False];
	Net_Bought = [False, False, False, False, False, False, False, False, False, False, False];	
}	

// Update the players clublinks
if (S_ForceClublinkTeam1 == "" && S_ForceClublinkTeam2 == "") Clublink::DefineTeamAuto();
else Clublink::DefineTeamFromUrl(S_ForceClublinkTeam1, S_ForceClublinkTeam2);
Clublink::SyncUpdate();

// Init UI
SM::SetupDefaultVisibility();
Message::CleanAllMessages();
Clublink::Attach();
Clublink::SetSponsorsDisplay(False);
SC_UpdateHeader(G_ClansMapPoints[1], G_ClansMapPoints[2]);

// Add test bots
Users_SetNbFakeUsers(S_BlueBot, S_RedBot);

SM::UnspawnAllPlayers();
SC_WaitForPlayers();
***

***InitRound***
***
declare Integer RoundClanWinner;// Team, who win the round
declare Integer TempGoalNb;		// To stop looping
declare Integer BestRoundScore;	// The best RoundPoints score in round
declare CSmPlayer MVP;			// The best player in round
***

***StartRound***
***
TempGoalNb 				= 0;
RoundClanWinner 		= 0;
BestRoundScore 			= 0;
MVP 					= Null;
G_PlayerWithBomb		= Null;
G_LastProgressUpdate 	= 0;
G_LastSettingsUpdate 	= 0;
G_LastTempUpdate 		= 0;
G_PlantedOn 			= 0;
G_GameState				= C_StateIdle;
Mode::Synchro_DoBarrier();
UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::Normal;
Victory::RoundBegin();
Score::RoundBegin();
UpdateFooter();
InitGoals();
// If this is the first round on the map, launch players presentation and toss
if (MB_SectionRoundNb == 1) 
{
	SC_UpdateHeader(G_ClansMapPoints[1], G_ClansMapPoints[2]);
	MB_PlayersPresentationSequence(2500);

	MB_UseIntro = True;
	G_AttackingClan = SC_DoTheToss(0);
}
UIManager.UIAll.UISequence = CUIConfig::EUISequence::EndRound;
UIManager.UIAll.UISequence_CanSkipIntroMT = True;
Message::CleanAllMessages();
Mode::PlaySound(CUIConfig::EUISound::StartRound, 0);
SC_UpdateHeader(G_ClansMapPoints[1], G_ClansMapPoints[2]);
UpdateBasesColors();
if(ServerShutdownRequested || MatchEndRequested) break;
foreach (Player in AllPlayers) 
{
	declare UI <=> UIManager.GetUI(Player);
	if(UI == Null) continue;
	UI.MarkersXML = "";
	declare SpawnTicket for Player = 0;
	declare netwrite Net_IsDead for UI = 0;
	if(SpawnTicket < 1) Net_IsDead = 1;
	else Net_IsDead = 0;
}
SC_EnableBuyZone(S_BuyTime*1000, G_AttackingClan);

// Init players and spawn ticket
foreach (Player in AllPlayers) 
{
	declare UI <=> UIManager.GetUI(Player);
	declare SpawnTicket for Player = 0;
	SpawnTicket = 1;
	ActionLoad(Player, CSmMode::EActionSlot::Slot_A, NullId);
	ActionBind(Player, CSmMode::EActionSlot::Slot_A, CSmMode::EActionInput::None);
	declare PrimaryWeapon for Player = 0;
	PrimaryWeapon = 0;
	if (UI != Null) 
	{ 
		declare netwrite Integer[Text] Net_PrimaryWeapons for UI;
		Net_PrimaryWeapons[Player.Login] = 0;
	}
	declare HasChangedClan for Player = False;
	declare NewSpectator for Player = False;
	SetPlayerClan(Player, Player.RequestedClan);
	HasChangedClan = False;
	NewSpectator = True;
}

foreach (Spectator in Spectators) {
	declare NewSpectator for Spectator = False;
	NewSpectator = False;
}

// Init spectator mode
foreach (Player in AllPlayers) 
{
	declare UI <=> UIManager.GetUI(Player);
	if (UI == Null) continue;
	
	if (Player.RequestsSpectate) 
	{
		declare SpawnTicket for Player = 0;
		SpawnTicket = 0;
		UI.SpectatorForceCameraType = -1;
		UI.SpectatorForcedClan = -1;
	} 
	else 
	{
		UI.SpectatorForceCameraType = 1;
		UI.SpectatorForcedClan = Player.CurrentClan;
	}
}

// Update the players clublinks
if (S_ForceClublinkTeam1 == "" && S_ForceClublinkTeam2 == "") Clublink::DefineTeamAuto();
else Clublink::DefineTeamFromUrl(S_ForceClublinkTeam1, S_ForceClublinkTeam2);
Clublink::SyncUpdate();
CustomUI::Attach();
UIManager.UIAll.UISequence = CUIConfig::EUISequence::Playing;
Layers::Update("ProgressBar", UpdateLayerProgressBar());
Layers::Update("BombTimer", UpdateLayerBomb());
Layers::Attach("ProgressBar");
Layers::Attach("Markers");
Layers::Update("HUD", UpdateLayerHUD());
Layers::Attach("HUD");
Layers::Attach("BombTimer");
Layers::Hide("BombTimer");
UpdateMarker();
ObjectDestroyAll();
SpawnBombItem();

SC_SetRoundTimer(S_RoundTime);
***

***OnPlayerAdded***
***
declare UI <=> UIManager.GetUI(Player);
if (UI != Null) 
{
	UI.SpectatorForcedClan		= Player.CurrentClan;
	UI.SpectatorForceCameraType	= 1;
	declare CurrentCapGoals for Player.Score = 0;
	declare CurrentMVP for Player.Score = 0;
	declare netwrite Net_PrimWpn for UI = 0;
	Net_PrimWpn = 0;
	declare netwrite Net_SecWpn for UI = 0;
	Net_SecWpn = 0;
	declare netwrite Net_Cash for UI = S_StartCash;
	Net_Cash = S_StartCash;
}
***

***OnNewSpectator***
***
declare UI <=> UIManager.GetUI(Spectator);
if (UI != Null) {
	UI.SpectatorForcedClan		= -1;
	UI.SpectatorForceCameraType	= -1;
	Layers::Detach("Shop", Spectator);
}
declare SpawnTicket for Spectator = 0;
SpawnTicket = 0;
***

***Yield***
***
Message::Loop();
***

***PlayLoop***
***
declare IsStanding = [1 => False, 2 => False];
//Layers::Update("BombTimer", UpdateLayerBomb());
if(G_LastSettingsUpdate + 1500 < Now)
{
	G_LastSettingsUpdate = Now;
	
	Users_SetNbFakeUsers(S_BlueBot, S_RedBot);
	
	if(PlayersNbTotal < 2) MB_StopRound = True;
}

// Unspawn and mark players changing clan
foreach (Player in Players) {
	if (!Player.IsFakePlayer && Player.SpawnStatus == CSmPlayer::ESpawnStatus::Spawned) {
		// if the player wants to change clan, then remove him from the current clan
		// it will be added to the correct clan at next respawn.
		if (Player.CurrentClan != 0 && Player.RequestedClan != Player.CurrentClan) {
			UnspawnPlayer(Player);
			declare HasChangedClan for Player = False;
			HasChangedClan = True;
		}
	}
	if(!Player.IsFakePlayer && Player.RequestsSpectate)
	{
		declare NewSpectator for Player = False;
		NewSpectator = True;
	}
}
// Don't let players going spectate respawn afterward
foreach (Spectator in Spectators) 
{
	declare NewSpectator for Spectator = False;
	if (NewSpectator) NewSpectator = False;
}
// Spawning players
if(RoundClanWinner == 0)
{
	foreach (Player in Players)
	{
		declare HasChangedClan for Player = False;
		declare NewSpectator for Player = True;
		if (Player.SpawnStatus == CSmPlayer::ESpawnStatus::NotSpawned && !HasChangedClan)
		{
			declare SecondaryWeapon for Player = 1;
			declare PrimaryWeapon for Player = 0;
			declare SpawnTicket for Player = 0;
			if(SpawnTicket <= 0) continue;
			if (Player.CurrentClan != 1 && Player.CurrentClan != 2) SetPlayerClan(Player, Player.RequestedClan);
			if (Player.RequestedClan == 1)
			{
				if(G_AttackingClan == 1)
				{
					Player.Armor = 300;
					Player.ArmorMax = 300;
					SM::SpawnPlayer(Player, Player.CurrentClan, Map::GetPlayerSpawn("SpawnAttack", 0), 3000);
					declare MSG2 = "";
					Message::SendBigMessage(Player, TextLib::Compose(_("|Imperative|Attack")), 7000, 0);
					
					switch(Player.User.Language)
					{
						case "pl": MSG2 = "$9d0Podłóż bombę i broń jej do momentu eksplozji";
						default: MSG2 = "$9d0Plant the bomb on the bombsite and defend until explosion";	
					} 
					Message::SendStatusMessage(Player, MSG2, 7000, 0);
				}	
				else
				{
					Player.Armor = 300;
					Player.ArmorMax = 300;
					SM::SpawnPlayer(Player, Player.CurrentClan, Map::GetPlayerSpawn("SpawnDefence", 0), 3000);
					declare MSG2 = ""; 
					Message::SendBigMessage(Player, TextLib::Compose(_("|Imperative|Defend")), 7000, 0);
					
					switch(Player.User.Language)
					{
						case "pl": MSG2 = "$9d0Nie pozwól atakującym podłożyć bombę";
						default: MSG2 = "$9d0Prevent attackers from bomb planting";	
					} 
					Message::SendStatusMessage(Player, MSG2, 7000, 0);
				}	
				SC_AddPlayerEQ(Player);
			}
			else if (Player.RequestedClan == 2)
			{
				if(G_AttackingClan == 2)
				{
					SM::SpawnPlayer(Player, Player.CurrentClan, Map::GetPlayerSpawn("SpawnAttack", 0), 3000);
					declare MSG2 = "";
					Message::SendBigMessage(Player, TextLib::Compose(_("|Imperative|Attack")), 7000, 0);
					
					switch(Player.User.Language)
					{
						case "pl": MSG2 = "$9d0Podłóż bombę i broń jej do momentu eksplozji";
						default: MSG2 = "$9d0Plant the bomb on the bombsite and defend until explosion";	
					} 
					Message::SendStatusMessage(Player, MSG2, 7000, 0);
				}	
				else
				{
					SM::SpawnPlayer(Player, Player.CurrentClan, Map::GetPlayerSpawn("SpawnDefence", 0), 3000);
					declare MSG2 = "";
					Message::SendBigMessage(Player, TextLib::Compose(_("|Imperative|Defend")), 7000, 0);
					
					switch(Player.User.Language)
					{
						case "pl": MSG2 = "$9d0Nie pozwól atakującym podłożyć bombę";
						default: MSG2 = "$9d0Prevent attackers from bomb planting";	
					} 
					Message::SendStatusMessage(Player, MSG2, 7000, 0);
				}	
				SC_AddPlayerEQ(Player);
			}
		}
	}		
}

// Timer management
if (S_RoundTime > 0) 
{
	if (Now == EndTime) 
	{
		SM::UnspawnAllPlayers();
		// Attackers didn't plant the bomb
		if(G_GameState == C_StateIdle)
		{
			Message::CleanBigMessages();
			Message::SendBigMessage(TextLib::Compose(_("Time limit reached!")), 4000, 0);
			Victory::SetRoundWinnerIfNoWinner(3-G_AttackingClan);
			RoundClanWinner = 3-G_AttackingClan;
			MB_StopRound = True;
		}
		// Attackers explode the bombsite 
		else if(G_GameState == C_StatePlanted)
		{
			Message::CleanBigMessages();
			Message::SendBigMessage(TextLib::Compose(_("Bomb explode!")), 4000, 0);
			Victory::SetRoundWinnerIfNoWinner(G_AttackingClan);
			RoundClanWinner = G_AttackingClan;
			G_GameState = C_StateExploded;
			MB_StopRound = True;
		}	
	}
}

// Poles management
foreach (LandmarkGauge in MapLandmarks_Gauge) 
{	
	if(LandmarkGauge.Sector != Null)
	{
		if(G_GameState == C_StateIdle) // Attacker with bomb is standing on bombsite
		{
			if (LandmarkGauge.Sector.PlayersIds.count > 0) 
			{
				foreach (PlayerId in LandmarkGauge.Sector.PlayersIds) 
				{
					declare Player <=> Players[PlayerId];
					if(LandmarkGauge.Tag == "Bombsite A")
					{
						if(Player.CurrentClan == G_AttackingClan && Player == G_PlayerWithBomb && !IsStanding[1]) IsStanding[1] = True;
					}
					else if	(LandmarkGauge.Tag == "Bombsite B")
					{
						if(Player.CurrentClan == G_AttackingClan && Player == G_PlayerWithBomb && !IsStanding[2]) IsStanding[2] = True;
					}
				}
			}
		}
		else if(G_GameState == C_StatePlanted) // Bomb planted, defenders are trying to defuse	
		{
			if (LandmarkGauge.Sector.PlayersIds.count > 0) 
			{
				foreach (PlayerId in LandmarkGauge.Sector.PlayersIds) 
				{
					declare Player <=> Players[PlayerId];
					if(LandmarkGauge.Tag == "Bombsite A")
					{
						if(Player.CurrentClan == 3-G_AttackingClan && !IsStanding[1]) IsStanding[1] = True;
					}
					else if	(LandmarkGauge.Tag == "Bombsite B")
					{
						if(Player.CurrentClan == 3-G_AttackingClan && !IsStanding[2]) IsStanding[2] = True;
					}
				}
			}
		}		
	}					
}

foreach (LandmarkGauge in MapLandmarks_Gauge) 
{
	if(LandmarkGauge.Sector != Null && G_GameState == C_StateIdle)
	{
		if(LandmarkGauge.Tag == "Bombsite A")
		{
			// Planting
			if (IsStanding[1]) LandmarkGauge.Gauge.Speed = 1;
			else
			{
				LandmarkGauge.Gauge.ValueReal = 0.;
				LandmarkGauge.Gauge.Speed = 0;
			}	
			// Planted
			if (LandmarkGauge.Gauge.Value == LandmarkGauge.Gauge.Max) 
			{
				LandmarkGauge.Gauge.Captured = True;
				LandmarkGauge.Gauge.Clan = G_AttackingClan;
				G_PlantedOn = 1;
				G_GameState = C_StatePlanted;
				EndTime = Now+(S_BombCountdown*1000);
				Layers::Show("BombTimer");
				if(LandmarkGauge.Sector.PlayersIds.count > 0)
				{
					foreach (PlayerId in LandmarkGauge.Sector.PlayersIds) 
					{
						if (Players.existskey(PlayerId) && Players[PlayerId].Score != Null && Players[PlayerId] == G_PlayerWithBomb) 
						{
							declare CurrentCapGoals for Players[PlayerId].Score = 0;
							CurrentCapGoals += 1;
							declare UI <=> UIManager.GetUI(Players[PlayerId]);
							if(UI != Null)
							{
								declare netwrite Net_Cash for UI = S_StartCash;
								Net_Cash += C_CashForCapture;
							}	
							ST2::SetColValue("ST_Captured", Players[PlayerId].Score, "$1F1"^TextLib::ToText(CurrentCapGoals));
							Score::AddPoints(Players[PlayerId], 3);	
						}
					}
				}
				Message::CleanBigMessages();
				foreach(Player in Players)
				{
					declare MSG = "";
					switch(Player.User.Language)
					{
						case "pl": MSG = "Bomba podłożona!";
						default: MSG = "The bomb has been planted!";
					} 
					Message::SendBigMessage(Player, MSG, 4000, 0);
				}	
				foreach(Spectator in Spectators)
				{
					declare MSG = "";
					switch(Spectator.User.Language)
					{
						case "pl": MSG = "Bomba podłożona!";
						default: MSG = "The bomb has been planted!";
					} 
					Message::SendBigMessage(Spectator, MSG, 5000, 0);
				}
				Mode::PlaySound(CUIConfig::EUISound::Capture, 0);
			}
		}
		if(LandmarkGauge.Tag == "Bombsite B")
		{
			// Planting
			if (IsStanding[2]) LandmarkGauge.Gauge.Speed = 1;
			else
			{
				LandmarkGauge.Gauge.ValueReal = 0.;
				LandmarkGauge.Gauge.Speed = 0;
			}	
			// Planted
			if (LandmarkGauge.Gauge.Value == LandmarkGauge.Gauge.Max) 
			{
				LandmarkGauge.Gauge.Captured = True;
				LandmarkGauge.Gauge.Clan = G_AttackingClan;
				G_PlantedOn = 2;
				G_GameState = C_StatePlanted;
				EndTime = Now+(S_BombCountdown*1000);
				Layers::Show("BombTimer");
				if(LandmarkGauge.Sector.PlayersIds.count > 0)
				{
					foreach (PlayerId in LandmarkGauge.Sector.PlayersIds) 
					{
						if (Players.existskey(PlayerId) && Players[PlayerId].Score != Null && Players[PlayerId] == G_PlayerWithBomb) 
						{
							declare CurrentCapGoals for Players[PlayerId].Score = 0;
							CurrentCapGoals += 1;
							declare UI <=> UIManager.GetUI(Players[PlayerId]);
							if(UI != Null)
							{
								declare netwrite Net_Cash for UI = S_StartCash;
								Net_Cash += C_CashForCapture;
							}	
							ST2::SetColValue("ST_Captured", Players[PlayerId].Score, "$1F1"^TextLib::ToText(CurrentCapGoals));
							Score::AddPoints(Players[PlayerId], 3);	
						}
					}
				}
				Message::CleanBigMessages();
				foreach(Player in Players)
				{
					declare MSG = "";
					switch(Player.User.Language)
					{
						case "pl": MSG = "Bomba podłożona!";
						default: MSG = "The bomb has been planted!";
					} 
					Message::SendBigMessage(Player, MSG, 4000, 0);
				}	
				foreach(Spectator in Spectators)
				{
					declare MSG = "";
					switch(Spectator.User.Language)
					{
						case "pl": MSG = "Bomba podłożona!";
						default: MSG = "The bomb has been planted!";
					} 
					Message::SendBigMessage(Spectator, MSG, 5000, 0);
				}
				Mode::PlaySound(CUIConfig::EUISound::Capture, 0);
			}
		}
	}
	else if(LandmarkGauge.Sector != Null && G_GameState == C_StatePlanted)
	{
		if(LandmarkGauge.Tag == "Bombsite A" && G_PlantedOn == 1)
		{
			// Defusing
			if (IsStanding[1]) LandmarkGauge.Gauge.Speed = -1;
			else
			{
				LandmarkGauge.Gauge.ValueReal = 1.;
				LandmarkGauge.Gauge.Speed = 0;
			}	
			// Defused
			if (LandmarkGauge.Gauge.Value == 0) 
			{
				LandmarkGauge.Gauge.Captured = False;
				G_GameState = C_StateDefused;
				EndTime = -1;
				Layers::Hide("BombTimer");
				if(LandmarkGauge.Sector.PlayersIds.count > 0)
				{
					foreach (PlayerId in LandmarkGauge.Sector.PlayersIds) 
					{
						if (Players.existskey(PlayerId) && Players[PlayerId].Score != Null && Players[PlayerId].CurrentClan == 3-G_AttackingClan) 
						{
							declare CurrentCapGoals for Players[PlayerId].Score = 0;
							CurrentCapGoals += 1;
							declare UI <=> UIManager.GetUI(Players[PlayerId]);
							if(UI != Null)
							{
								declare netwrite Net_Cash for UI = S_StartCash;
								Net_Cash += C_CashForCapture;
							}	
							ST2::SetColValue("ST_Captured", Players[PlayerId].Score, "$1F1"^TextLib::ToText(CurrentCapGoals));
							Score::AddPoints(Players[PlayerId], 3);	
						}
					}
				}
				Message::CleanBigMessages();
				foreach(Player in Players)
				{
					declare MSG = "";
					switch(Player.User.Language)
					{
						case "pl": MSG = "Bomba rozbrojona!";
						default: MSG = "The bomb has been defused!";
					} 
					Message::SendBigMessage(Player, MSG, 4000, 0);
				}	
				foreach(Spectator in Spectators)
				{
					declare MSG = "";
					switch(Spectator.User.Language)
					{
						case "pl": MSG = "Bomba rozbrojona!";
						default: MSG = "The bomb has been defused!";
					} 
					Message::SendBigMessage(Spectator, MSG, 5000, 0);
				}
				Mode::PlaySound(CUIConfig::EUISound::Capture, 0);
				RoundClanWinner = 3-G_AttackingClan;
				MB_StopRound = True;
			}
		}
		else if(LandmarkGauge.Tag == "Bombsite B" && G_PlantedOn == 2)
		{
			// Defusing
			if (IsStanding[2] && LandmarkGauge.Gauge.ValueReal > 0.) LandmarkGauge.Gauge.Speed = -1;
			else
			{
				LandmarkGauge.Gauge.ValueReal = 1.;
				LandmarkGauge.Gauge.Speed = 0;
			}	
			// Defused
			if (LandmarkGauge.Gauge.Value == 0) 
			{
				LandmarkGauge.Gauge.Captured = False;
				G_GameState = C_StateDefused;
				EndTime = -1;
				Layers::Hide("BombTimer");
				if(LandmarkGauge.Sector.PlayersIds.count > 0)
				{
					foreach (PlayerId in LandmarkGauge.Sector.PlayersIds) 
					{
						if (Players.existskey(PlayerId) && Players[PlayerId].Score != Null && Players[PlayerId].CurrentClan == 3-G_AttackingClan) 
						{
							declare CurrentCapGoals for Players[PlayerId].Score = 0;
							CurrentCapGoals += 1;
							declare UI <=> UIManager.GetUI(Players[PlayerId]);
							if(UI != Null)
							{
								declare netwrite Net_Cash for UI = S_StartCash;
								Net_Cash += C_CashForCapture;
							}	
							ST2::SetColValue("ST_Captured", Players[PlayerId].Score, "$1F1"^TextLib::ToText(CurrentCapGoals));
							Score::AddPoints(Players[PlayerId], 3);	
						}
					}
				}
				Message::CleanBigMessages();
				foreach(Player in Players)
				{
					declare MSG = "";
					switch(Player.User.Language)
					{
						case "pl": MSG = "Bomba rozbrojona!";
						default: MSG = "The bomb has been defused!";
					} 
					Message::SendBigMessage(Player, MSG, 4000, 0);
				}	
				foreach(Spectator in Spectators)
				{
					declare MSG = "";
					switch(Spectator.User.Language)
					{
						case "pl": MSG = "Bomba rozbrojona!";
						default: MSG = "The bomb has been defused!";
					} 
					Message::SendBigMessage(Spectator, MSG, 5000, 0);
				}
				Mode::PlaySound(CUIConfig::EUISound::Capture, 0);
				RoundClanWinner = 3-G_AttackingClan;
				MB_StopRound = True;
			}
		}
	}
}

if(G_LastProgressUpdate + 1000 < Now)
{
	G_LastProgressUpdate = Now;
	Layers::Update("HUD", UpdateLayerHUD());
	MB_Log("G_PlayerWithBomb = "^G_PlayerWithBomb);
	MB_Log("G_PlantedOn = "^G_PlantedOn);

	G_PlayersAlive = [1 => 0, 2 => 0];
	
	foreach(Player in Players)
	{
		if(Player.Armor > 0 && Player.CurrentClan > 0) G_PlayersAlive[Player.CurrentClan] += 1;
	}	
	if(G_PlayersAlive[G_AttackingClan] <= 0 && G_GameState != C_StatePlanted)
	{
		Victory::SetRoundWinnerIfNoWinner(3-G_AttackingClan);
		RoundClanWinner = 3-G_AttackingClan;
		MB_StopRound = True;
		SC_AnnounceEliminationMessage(G_AttackingClan-1, 0);
	}
	else if(G_PlayersAlive[3-G_AttackingClan] <= 0)
	{
		Victory::SetRoundWinnerIfNoWinner(G_AttackingClan);
		RoundClanWinner = G_AttackingClan;
		MB_StopRound = True;
		SC_AnnounceEliminationMessage(3-G_AttackingClan-1, 0);
	}
}

foreach (Event in PendingEvents) 
{
	switch(Event.Type)
	{
		// Weapon switch via mouse scroll
		case CSmModeEvent::EType::OnPlayerRequestActionChange: 
		{
			if (Event.Player == Null) Discard(Event);
			else 
			{
				SC_CycleWeapon(Event.Player, Event.ActionChange);
				PassOn(Event);
			}
		}
		// On near miss
		case CSmModeEvent::EType::OnNearMiss:
		{
			---OnNearMiss---
		}
		// When player touches object
		case CSmModeEvent::EType::OnPlayerTouchesObject:
		{
			if(Event.Player == Null || Event.Player.SpawnStatus != CSmPlayer::ESpawnStatus::Spawned) Discard(Event);
			else if(Event.Player.CurrentClan == G_AttackingClan) 
			{
				PickUpObject(Event.Player, Event.Object);
				PassOn(Event);
			}
			else Discard(Event);
		}
		// Weapon switch via keyboard and add ability to drop the bomb
		case CSmModeEvent::EType::OnActionEvent: 
		{
			if(Event.Player == Null) Discard(Event);

			/*if(Event.ActionInput == CSmModeEvent::EActionInput::Consumable1 && Event.Player == G_PlayerWithBomb)
			{
				DropTheBomb(Event.Player);
				PassOn(Event);
			}
			else
			{
				SC_SwitchWeapon(Event.Player, Event.ActionInput);
				PassOn(Event);
			}	*/	
			SC_SwitchWeapon(Event.Player, Event.ActionInput);
			PassOn(Event);
		}
		// Armor empty
		case CSmModeEvent::EType::OnArmorEmpty:
		{
			if(Event.Victim == Null) Discard(Event);
			if (Event.Victim.Armor > 100)
			{
				declare SpawnTicket for Event.Victim = 0;
				SpawnTicket = 1;
			}
			else
			{
				declare SpawnTicket for Event.Victim = 0;
				SpawnTicket = 0;
				declare SUI <=> UIManager.GetUI(Event.Shooter);
				if (SUI != Null)
				{
					declare netwrite Net_Cash for SUI = S_StartCash;
					Net_Cash += C_CashForKill;
				}
				// If victim had the bomb, make a drop
				if(G_PlayerWithBomb == Event.Victim) DropTheBomb(Event.Victim);
		
				// Remove eq that player bought
				ActionBind(Event.Victim, CSmMode::EActionSlot::Slot_A, CSmMode::EActionInput::None);
				SetPlayerAmmoMax(Event.Victim, CSmMode::EWeapon::Laser, 0);
				SetPlayerAmmoMax(Event.Victim, CSmMode::EWeapon::Nucleus, 0);
				declare UI <=> UIManager.GetUI(Event.Victim);
				if (UI != Null) 
				{
					declare netwrite Net_PrimWpn for UI = 0;
					Net_PrimWpn = 0;
					declare netwrite Net_SecWpn for UI = 0;
					Net_SecWpn = 0;
					declare netwrite Net_Bought for UI = [False, False, False, False, False, False, False, False, False, False, False];
					Net_Bought = [False, False, False, False, False, False, False, False, False, False, False];
				}
				foreach(Player in Players)
				{
					declare UI <=> UIManager.GetUI(Player);
					if (UI != Null) 
					{
						declare netwrite Integer[Text] Net_PrimaryWeapons for UI;
						Net_PrimaryWeapons[Event.Victim.Login] = 0;
					}
				}
		
				if (G_PlayersAlive[Event.Victim.CurrentClan] > 1) 
				{
					declare PLeft = G_PlayersAlive[Event.Victim.CurrentClan]-1;
					if (PLeft <= 3) SC_AnnounceEliminationMessage(Event.Victim.CurrentClan-1, PLeft);
				}
			}		
			XmlRpc::OnArmorEmpty(Event);
			PassOn(Event);
		}
		// Damage
		case CSmModeEvent::EType::OnHit:
		{
			if(Event.Shooter == Null || Event.Victim == Null) Discard(Event);
			// Discard friendly fire(In future, there will be ff option)
			if (Event.Shooter != Null && Event.Shooter.CurrentClan == Event.Victim.CurrentClan) Discard(Event);
			else 
			{
				if(Event.WeaponNum == GetWeaponNum(CSmMode::EWeapon::Laser))
				{
					declare UI <=> UIManager.GetUI(Event.Shooter);
					if(UI != Null)
					{
						// Get distance
						declare Distance = MathLib::Distance(Event.Shooter.Position, Event.Victim.Position);
						SC_AnnounceHitDistance(Distance, Event.Shooter);
					}
				}		
				if (Event.Shooter != Event.Victim)
				{
					declare UI <=> UIManager.GetUI(Event.Shooter);
					if (UI != Null) 
					{
						declare netwrite Net_Cash for UI = S_StartCash;
						Score::AddPoints(Event.Shooter, Event.Damage/100);
						Net_Cash += C_CashForHit;
						---HeadshotFunctions---
						---AnnounceHeadshot---
					}
					if(Event.Victim.Armor - Event.Damage <= 0)
					{
						declare SpawnTicket for Event.Victim = 0;
						SpawnTicket = 0;
					}		
				}	
				XmlRpc::OnHit(Event);
				PassOn(Event);
			}
		}
		// Action Maker Events
		case CSmModeEvent::EType::OnActionCustomEvent:
		{
			if(Event.Shooter == Null || Event.Victim == Null) Discard(Event);
			// Discard friendly fire
			if (Event.Param1 == "damage" && Event.Victim != Null && Event.Shooter != Null && Event.Shooter.CurrentClan == Event.Victim.CurrentClan) Discard(Event);
			else if(Event.Param1 == "damage" && Event.Victim != Null && Event.Shooter != Null && Event.Victim != Event.Shooter) 
			{
				declare Damage = TextLib::ToInteger(Event.Param2[0]);
      		 	declare Points = Damage / 100;
      		 	// Shotgun fix (+0 when hit)
				if(Damage < 100)
				{
					Points = 1;
					Damage = 100;
				}	
				declare UI <=> UIManager.GetUI(Event.Shooter);
				if (UI != Null) 
				{
					declare netwrite Net_Cash for UI = S_StartCash;
        		   	Net_Cash += C_CashForHit;
					---HeadshotFunctions---
					---ActionMakerAnnounceHeadshot---
				}
      		  RemovePlayerArmor(Event.Victim, Damage, Event.Shooter, Points);
      		  Score::AddPoints(Event.Shooter, Points);
     		   if(Event.Victim.Armor - Damage <= 0)
				{
					declare SpawnTicket for Event.Victim = 0;
					SpawnTicket = 0;
				}	
   		   		PassOn(Event);
  		  }  
		}
		// Give Up
		case CSmModeEvent::EType::OnPlayerRequestRespawn:
		{
			if(Event.Player == Null) Discard(Event);

			declare Message = "";
			declare SpawnTicket for Event.Player = 0;
			SpawnTicket = 0;

			// If player had the bomb, make a drop
			if(G_PlayerWithBomb == Event.Player) DropTheBomb(Event.Player);
			//Remove eq that player bought
			ActionBind(Event.Player, CSmMode::EActionSlot::Slot_A, CSmMode::EActionInput::None);
			SetPlayerAmmoMax(Event.Player, CSmMode::EWeapon::Laser, 0);
			SetPlayerAmmoMax(Event.Player, CSmMode::EWeapon::Nucleus, 0);
			declare UI <=> UIManager.GetUI(Event.Player);
			if (UI != Null) 
			{
				declare netwrite Net_PrimWpn for UI = 0;
				Net_PrimWpn = 0;
				declare netwrite Net_SecWpn for UI = 0;
				Net_SecWpn = 0;
				declare netwrite Net_Bought for UI = [False, False, False, False, False, False, False, False, False, False, False];
				Net_Bought = [False, False, False, False, False, False, False, False, False, False, False];
			}
			foreach(Player in Players)
			{
				declare UI <=> UIManager.GetUI(Player);
				if (UI != Null) 
				{
					declare netwrite Integer[Text] Net_PrimaryWeapons for UI;
					Net_PrimaryWeapons[Event.Player.Login] = 0;
				}
			}
			if(G_PlayersAlive[Event.Player.CurrentClan] > 1) 
			{
				declare PLeft = G_PlayersAlive[Event.Player.CurrentClan];
				if(PLeft <= 3) SC_AnnounceEliminationMessage(Event.Player.CurrentClan-1, PLeft);
			}
			XmlRpc::OnPlayerRequestRespawn(Event);
			PassOn(Event);
		}
		// Goal Captured
		case CSmModeEvent::EType::OnCapture: Discard(Event);
		default: PassOn(Event);
	}	
}
***

***EndRound***
***
Layers::Detach("Markers");
Layers::Hide("BombTimer");
// Search for MVP
foreach(Player in Players)
{
	if(Player.Score.RoundPoints > BestRoundScore && Player.Score.RoundPoints > 0)
	{
		BestRoundScore = Player.Score.RoundPoints;
		MVP = Player;
	}	
}
if(MVP != Null && RoundClanWinner != 0)
{
	declare CurrentMVP for MVP.Score = 0;
	CurrentMVP += 1;
	ST2::SetColValue("ST_MVP", MVP.Score, "$fc0"^TextLib::ToText(CurrentMVP));
}	
MB_Sleep(1500);
//Give money for win/loss
if(RoundClanWinner > 0)
{
	G_ClansMapPoints[RoundClanWinner] += 1;
	foreach(Player in Players)
	{
		declare UI <=> UIManager.GetUI(Player);
		if(UI == Null) continue;
		UI.MarkersXML = "";	// Clear markers for player
		declare netwrite Net_Cash for UI = S_StartCash;
		if(Player.CurrentClan == RoundClanWinner) Net_Cash += C_CashForWin;
		else if(Player.CurrentClan == 3-RoundClanWinner) Net_Cash += C_CashForLoss;
	}
}	
SM::UnspawnAllPlayers();
MB_Sleep(1000);
UIManager.UIAll.UISequence = CUIConfig::EUISequence::EndRound;
Victory::RoundEnd();
EndTime = -1;
Message::CleanAllMessages();
Layers::Detach("HUD");
if(MB_SectionRoundNb % 3 == 0) DisplayNotice();
SC_UpdateHeader(G_ClansMapPoints[1], G_ClansMapPoints[2]);
SC_AnnounceRoundWin(RoundClanWinner);
UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::ForcedVisible;
MB_Sleep(4000);
Score::RoundEnd();
if(G_ClansMapPoints[1] >= S_MapPointsLimit)
{
	ClanMapWinner = 1;
	MB_StopMap = True;
}
else if(G_ClansMapPoints[2] >= S_MapPointsLimit)
{
	ClanMapWinner = 2;
	MB_StopMap = True;
}
MB_Sleep(4000);
UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::Normal;
Message::CleanAllMessages();
if(PlayersNbTotal < 2) SC_WaitForPlayers();
//Switch the roles
G_AttackingClan = 3 - G_AttackingClan;
***

***EndMap***
***
/*foreach (Score in Scores) 
{
	declare PrevPoints for Score = 0;
	PrevPoints = Score.Points;
	declare CurrentMVP for Score = 0;
	Score.LadderMatchScoreValue = MathLib::ToReal(Score.Points + (CurrentMVP*2));
	// Winner
	if (Score.LadderClan == ClanMapWinner) {
		Score.Points = 4;
	}
	// Looser
	else if (Score.LadderClan == 3 - ClanMapWinner) {
		Score.Points = 2;
	}
	// Other
	else {
		Score.Points = 0;
		Score.LadderMatchScoreValue = 0.;
	}
}
Ladder_SetResultsVersion(1);
Score::MatchEnd(True);
foreach (Score in Scores) {
	declare PrevPoints for Score = 0;
	Score.Points = PrevPoints;
}*/

foreach (Player in Players) {
	if(Player.CurrentClan == ClanMapWinner && Player.Score != Null) {
		declare LadderBonus for Player.Score = 0;
		declare CurrentMVP for Player.Score = 0;
		LadderBonus += CurrentMVP*5;
	}
	else if(Player.CurrentClan != ClanMapWinner && Player.Score != Null) {
		declare LadderBonus for Player.Score = 0;
		declare CurrentMVP for Player.Score = 0;
		LadderBonus -= 30 - (CurrentMVP*3);
	}
}
foreach (Score in Scores) {
	declare LadderBonus for Score = 0;
	Score.Points += LadderBonus;
}
Score::MatchEnd();
foreach (Score in Scores) {
	declare LadderBonus for Score = 0;
	Score.Points -= LadderBonus;
}
Victory::MatchEnd();
Message::SendStatusMessage(TextLib::Compose(_("Map result: %1 %2 - %3 %4"),Teams[0].ColorizedName,TextLib::ToText(G_ClansMapPoints[1]),TextLib::ToText(G_ClansMapPoints[2]),Teams[1].ColorizedName), 6000, 0, CUIConfig::EUISound::EndRound, 0);
if (ClanMapWinner > 0) Message::SendBigMessage(TextLib::Compose(_("%1 wins the map!"), Teams[ClanMapWinner - 1].ColorizedName), 6000, 0);
else Message::SendBigMessage(TextLib::Compose(_("|Match|Draw")), 6000, 0, CUIConfig::EUISound::Silence, 0);
UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::ForcedVisible;
MB_Sleep(6000);
UIManager.UIAll.UISequence = CUIConfig::EUISequence::Podium;
MB_Sleep(6000);
UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::Normal;
Message::CleanAllMessages();
***

***EndServer***
***
Layers::Destroy("ProgressBar");
Layers::Destroy("RulesReminder");
Layers::Destroy("BombTimer");
Layers::Destroy("HUD");
CustomUI::Unload();
Layers::Destroy("Markers");
SpawnScreen::DestroyRules();
***

Void InitGoals() 
{
	foreach (LandmarkGauge in MapLandmarks_Gauge) 
	{
		if(LandmarkGauge.Sector != Null)
		{
			switch(LandmarkGauge.Tag)
			{
				case "Bombsite A":
				{
					LandmarkGauge.Gauge.Max		= S_PlantingTime * 1000;
					LandmarkGauge.Gauge.Value	= 0;
					LandmarkGauge.Gauge.Speed	= 0;
					LandmarkGauge.Gauge.Clan 	= 0;
					LandmarkGauge.Gauge.Captured= False;
				}
				case "Bombsite B":
				{
					LandmarkGauge.Gauge.Max		= S_PlantingTime * 1000;
					LandmarkGauge.Gauge.Value	= 0;
					LandmarkGauge.Gauge.Speed	= 0;
					LandmarkGauge.Gauge.Clan 	= 0;
					LandmarkGauge.Gauge.Captured= False;
				}
			}
		}	
	}
}

Void UpdateBasesColors() {
	foreach (Base in MapBases) {
		Base.Clan = 0;
		Base.IsActive = True;
	}
	
	declare UpdatedBases = Ident[];
	
	foreach (Spawn in MapLandmarks_PlayerSpawn) 
	{
		if (Spawn.Base == Null) continue;
		
		if(G_AttackingClan == 2)
		{
			switch(Spawn.Tag)
			{
				case "SpawnAttack": Spawn.Base.Clan = 2;
				case "SpawnDefence": Spawn.Base.Clan = 1;
			}	
		}
		else
		{
			switch(Spawn.Tag)
			{
				case "SpawnAttack": Spawn.Base.Clan = 1;
				case "SpawnDefence": Spawn.Base.Clan = 2;
			}
		}
		Spawn.Base.IsActive = True;
		UpdatedBases.add(Spawn.Base.Id);
	}
	
	foreach (Pole in MapLandmarks_Gauge)
	{
		if (Pole.Base != Null) {
			if (!UpdatedBases.exists(Pole.Base.Id)) {
				Pole.Base.Clan = 3-G_AttackingClan;
				UpdatedBases.add(Pole.Base.Id);
			} else if (Pole.Base.Clan != 3-G_AttackingClan) {
				Pole.Base.Clan = G_AttackingClan;
			}
		}
	}
}

Void DropTheBomb(CSmPlayer _Player)
{
	if(_Player == Null) return;

	foreach (Object in _Player.Objects)
	{
		if(Object == Null || Object.Id != G_ObjectId[C_Object]) continue;
		if(Object.Status == CSmObject::EStatus::OnPlayer)
		{
			Object.SetPosition(_Player.Position);
			G_PlayerWithBomb = Null;
		}	
	}	
}

Void SpawnBombItem() 
{
	foreach (MapLandmark in MapLandmarks_ObjectAnchor) 
	{
		declare ObjectAnchor <=> MapLandmark.ObjectAnchor;
		if (ObjectAnchor == Null) continue;
		
		declare CSmObject Object;
		Object = ObjectCreate(G_ObjectId[C_Object]);
		if (Object != Null) 
		{
			//declare AnchorId for Object = NullId;
			declare Tag for Object = MapLandmark.Tag;
			//AnchorId = MapLandmark.Id;
			Tag = MapLandmark.Tag;
			Object.SetAnchor(ObjectAnchor);
		}
	}
}

Void PickUpObject(CSmPlayer _Player, CSmObject _Object) {
	if (_Player == Null || _Object == Null || _Player.CurrentClan != G_AttackingClan) return;
	
	declare Tag for _Object = "";
	/*declare AnchorId for _Object = NullId;
	
	if(_Object.Id != AnchorId) return;
	
	if (!MapLandmarks_ObjectAnchor.existskey(AnchorId)) return;
	declare MapLandmark <=> MapLandmarks_ObjectAnchor[AnchorId];*/
	 
	G_PlayerWithBomb = _Player;
	foreach(Player in Players)
	{
		declare UI <=> UIManager.GetUI(Player);
		if(UI == Null || Player.CurrentClan != G_AttackingClan) continue;
		UI.SendNotice(
			TextLib::Compose(_("|Player picked up item|$<%1$> picked up %2"), _Player.Name, "Laser"), 
			CUIConfig::ENoticeLevel::Default , Null, 
			CUIConfig::EAvatarVariant::Happy, 
			CUIConfig::EUISound::Silence, 0
		);
	}	
	
	_Object.SetPlayer(_Player);
	ObjectDestroy(_Object);
}

Void DisplayNotice()
{
	foreach (Player in Players) 
	{
		declare UI <=> UIManager.GetUI(Player);
		if (UI == Null) continue;
		declare rand = MathLib::Rand(1,5);
		
		declare Text[Integer] MSG;
		declare Prefix = "$f90$s>>";
		switch(Player.User.Language)
		{
			case "pl":
			{
				MSG[1] = "Śledź maniaflash $h[maniaflash?snd]snd$h by uzyskać informacje o aktualizacjach";
				MSG[2] = "Tryb został stworzony przez ToRRent'a";
				MSG[3] = "Wciśnij F8 by zmodyfikować interfejs";
				MSG[4] = "Drużyny co rundę zmieniają się rolami, jedni atakują, drudzy bronią.";
				MSG[5] = "Jeżeli masz sugestie co do rozwoju trybu, napisz $l[http://forum.maniaplanet.com/viewtopic.php?f=10&t=28177&start=0]tutaj$l";
			}
			case "fr": 
			{
				MSG[1] = "Abonne-toi au Maniaflash $h[maniaflash?snd]snd$h pour avoir les informations concernant les mises-à-jour et les rendez-vous";
				MSG[2] = "Mode de jeu créé par ToRRent";
				MSG[3] = "Appuie sur F8 pour personnaliser l'interface";
				MSG[4] = "Teams are switching roles every round, One is attacking, another defending";
				MSG[5] = "Pour toute suggestion concernant le mode de jeu, merci d'aller $l[http://forum.maniaplanet.com/viewtopic.php?f=10&t=28177&start=0]ici$l";
			}
			case "it": 
			{
				MSG[1] = "Segui maniaflash $h[maniaflash?snd]snd$h per ot tenere le informazioni sul tema di aggiornamenti e riunioni";
				MSG[2] = "Il modo è stato creato grazie a ToRRent'a";
				MSG[3] = "Digiti F8 per modificare l’interfaccia";
				MSG[4] = "Teams are switching roles every round, One is attacking, another defending";
				MSG[5] = "Se hai suggestioni rispetti allo sviluppo del modo, scrivi $l[http://forum.maniaplanet.com/viewtopic.php?f=10&t=28177&start=0]qui$l";
			}
			case "de": 
			{
				MSG[1] = "Abonniere den ManiaFlash $h[maniaflash?snd]snd$h um Informationen über Aktualisierungen und Treffen zu erhalten";
				MSG[2] = "Spielmodus erstellt durch ToRRent";
				MSG[3] = "Drücke F8 um die Oberfläche anzupassen";
				MSG[4] = "Teams are switching roles every round, One is attacking, another defending";
				MSG[5] = "Verbesserungsvorschläge bitte $l[http://forum.maniaplanet.com/viewtopic.php?f=10&t=28177&start=0]hier$l";
			}
			default:
			{
				MSG[1] = "Follow maniaflash $h[maniaflash?snd]snd$h to get informations about updates and meetings";
				MSG[2] = "Game mode was created by ToRRent";
				MSG[3] = "Press F8 to customize interface";
				MSG[4] = "Teams are switching roles every round, One is attacking, another defending";
				MSG[5] = "If you have suggestion about gamemode, go $l[http://forum.maniaplanet.com/viewtopic.php?f=10&t=28177&start=0]here$l";
			}
		}

		switch(rand)
		{
			case 1: UI.SendChat(Prefix^MSG[1]);
			case 2: UI.SendChat(Prefix^MSG[2]);
			case 3: UI.SendChat(Prefix^MSG[3]);
			case 4: UI.SendChat(Prefix^MSG[4]);
			case 5: UI.SendChat(Prefix^MSG[5]);
		}
	}	
}

Text UpdateLayerHUD()
{
	return """
<manialink version="1" name="SND:Player HUD">
<frame hidden="1" id="Frame_Overlay">
	<label posn="-65 -70 1" text="1: -" textsize="1" halign="left" id="Label_Primary"/>
	<label posn="-65 -74 1" text="2: -" textsize="1" halign="left" id="Label_Secondary"/>
	<label posn="52 -70 1" text="0" textsize="4" halign="right" style="TextRaceChrono" id="Label_Cash"/>
	<label posn="58 -70 1" text="$9f0$$" textsize="4" halign="right"/>
	<label posn="0 -62 1" text="Function" style="TextTitle3" textsize="3" halign="center" id="Label_Role"/>
	<label posn="0 -56 1" text="Press 3 to drop the bomb" style="TextTitle3" hidden="1" textsize="3" halign="center" id="Label_Bomb"/>
</frame>
<script><!--	
main()
{
	declare Frame_Overlay <=> (Page.GetFirstChild("Frame_Overlay") as CMlFrame);
	declare Label_Primary <=> (Page.GetFirstChild("Label_Primary") as CMlLabel);
	declare Label_Secondary <=> (Page.GetFirstChild("Label_Secondary") as CMlLabel);
	declare Label_Cash <=> (Page.GetFirstChild("Label_Cash") as CMlLabel);
	declare Label_Role <=> (Page.GetFirstChild("Label_Role") as CMlLabel);
	declare Label_Bomb <=> (Page.GetFirstChild("Label_Bomb") as CMlLabel);
	while(True)
	{
		yield;
		if(InputPlayer == Null) continue;
		if(InputPlayer.Armor > 0)
		{			
			Frame_Overlay.Visible = True;
			declare netread Net_Cash for UI = {{{S_StartCash}}};
			Label_Cash.Value = Net_Cash^"";
			if(InputPlayer.CurrentClan == {{{G_AttackingClan}}}) Label_Role.SetText(_("|Imperative|Attack"));
			else Label_Role.SetText(_("|Imperative|Defend")); 

			/*if(InputPlayer == Null) Label_Bomb.Show();
			else Label_Bomb.Hide();*/

			declare netread Integer[Text] Net_PrimaryWeapons for UI;
			if(Net_PrimaryWeapons.existskey(InputPlayer.Login))
			{
				switch(Net_PrimaryWeapons[InputPlayer.Login])
				{
					case 1: Label_Primary.Value = "1: Laser";
					case 2: Label_Primary.Value = "1: Plasma Gun";
					case 3: Label_Primary.Value = "1: Grenades";
					case 4: Label_Primary.Value = "1: Nucleus";
					case 5: Label_Primary.Value = "1: Shotgun";
					case 6: Label_Primary.Value = "1: Blow Bomb";
					default: Label_Primary.Value = "1: -";
				}
			}	
			declare netread Integer[Text] Net_SecondaryWeapons for UI;
			if(Net_SecondaryWeapons.existskey(InputPlayer.Login))
			{
				switch(Net_SecondaryWeapons[InputPlayer.Login])
				{
					case 1: Label_Secondary.Value = "2: Rockets";
					case 2: Label_Secondary.Value = "2: Bouncing Rockets";
					case 3: Label_Secondary.Value = "2: Electric Pistol";
					default: Label_Secondary.Value = "2: -";
				}
			}
			else Label_Secondary.Value = "2: -";
		}
		else Frame_Overlay.Visible = False;		
	}
}
--></script>
</manialink>
	""";
}

Void UpdateMarker()
{
	UIManager.UIAll.MarkersXML = "";
	declare Manialink = "";
	foreach (Goal in MapLandmarks_Gauge) 
	{
		declare PosX = Goal.Position.X;
		declare PosY = Goal.Position.Y + 0.7;
		declare PosZ = Goal.Position.Z;
		if (Goal.Tag == "Bombsite A") 
		{
			Manialink ^= """<marker label="$oA" pos="{{{PosX}}} {{{PosY}}} {{{PosZ}}}" hudvisibility="Always" />""";
		} 
		else if (Goal.Tag == "Bombsite B") 
		{
			Manialink ^= """<marker label="$oB" pos="{{{PosX}}} {{{PosY}}} {{{PosZ}}}" hudvisibility="Always" />""";
		}
	}
	if(G_PlayerWithBomb != Null)
	{
		Manialink ^= """<marker label="Laser" objectid="{{{G_ObjectId[C_Object]}}}" hudvisibility="Always" />""";
	}
	
	UIManager.UIAll.MarkersXML = Manialink;
}

Text UpdateLayerRulesReminder() {
	declare Text HighlightColor		= "f90";
	
	declare Text TitleText 			= TextLib::Compose(_("Welcome to %1!"), "Search And Destroy");
	
	return """
<manialink version="1" name="SND:Rules Reminder">	
<dico>
   <language id="en">
    	<rule1>$f70Attackers$g: Plant the bomb on 1 bombsite and wait for explosion to win.</rule1>
    	<rule2>$f70Defenders$g: Protect bombsites to end of the round or eliminate attackers to win.</rule2>
    	<rule3>For actions like kills, headshots, wins etc. you are earning money.</rule3>
    	<rule4>Before round, you can buy equipment in the shop.</rule4>
   </language>
   <language id="pl">
    	<rule1>$f70W ataku$g: Podłóż bombę w strefie i doprowadź do eksplozji by wygrać.</rule1>
    	<rule2>$f70W obronie$g: Chroń stref do końca trwania rundy lub wyeliminuj atakujących by wygrać.</rule2>
    	<rule3>Za akcje jak eliminacje, headshoty, zwycięstwa itp. zdobywasz pieniądze.</rule3>
    	<rule4>Przed rundą możesz kupić ekwipunek.</rule4>
   </language>
</dico>
<frame id="RulesReminderMainFrame" hidden="true" posn="0 13 100" >
	<quad posn="0 25 0" sizen="162 70" bgcolor="FFFA" image="{{{C_ImgModeDir}}}/WelcomeBg.dds" halign="center" valign="center"/>
	<label posn="-71 46 1" sizen="86 5" text="{{{TitleText}}}" textsize="4" textcolor="{{{HighlightColor}}}" style="TextValueSmallSm"/>
	<label posn="-73 39 1" sizen="146 26" textid="rule1"/>
	<label posn="-73 33 1" sizen="146 26" textid="rule2"/>
	<label posn="-73 27 1" sizen="146 26" textid="rule3"/>
	<label posn="-73 21 1" sizen="146 26" textid="rule4"/>
	<label posn="0 12 1" halign="center" text="{{{TextLib::Compose(_("Press '$<%1F1$>' to close this window."), "$"^HighlightColor)}}}" textsize="3" />
</frame>
<script><!--
	while(InputPlayer == Null) yield;
	
	if(InputPlayer.User.LadderPoints > 3000) {
		return;
	}

	declare RulesReminderMainFrame 	<=> (Page.GetFirstChild("RulesReminderMainFrame") as CMlFrame);
	
	while(True) {
		yield;
		
		RulesReminderMainFrame.Show();
		
		foreach(Event in PendingEvents) {
			switch(Event.Type){
				case CMlEvent::Type::KeyPress: {
					if(Event.CharPressed == "2424832" ) { // F1
						RulesReminderMainFrame.Visible = !RulesReminderMainFrame.Visible;
						return; // End of this behavior
					}
				}
			}
		}
	}
--></script>
</manialink>
""";
}

// Build capture progress layer
Text UpdateLayerProgressBar()
{
	declare Text ML = "";
	ML = """
<manialink version="1" name="SND:Real-Time Progress Bar">
<frame class="LibCustomUI_Module" id="SND_GaugeCapture">
	<frame posn="0 -46" id="Frame_Capture">
		<quad posn="0 0 2" sizen="128 20" halign="center" valign="center" image="{{{C_ImgModeDir}}}/Structure.dds" />
		<label posn="0 -2.5 3" halign="center" textsize="3" textemboss="1" textprefix="$bbb" textid="label0" id="Label_Goal" style="TextButtonBig"/>
		<gauge posn="0 8 2" sizen="124 10.4" halign="center" style="EnergyBar" drawbg="1" drawblockbg="1" id="Gauge_Capture" />
	</frame>
</frame>	
<script><!--
#Include "MathLib" as ML
main() 
{
	declare Frame_Capture 	<=> (Page.GetFirstChild("Frame_Capture") 	as CMlFrame);
	declare Label_Goal 		<=> (Page.GetFirstChild("Label_Goal") 		as CMlLabel);
	declare Gauge_Capture 	<=> (Page.GetFirstChild("Gauge_Capture") 	as CMlGauge);
	{{{CustomUI::InjectMLInit()}}}
	while (True) 
	{
		yield;
		if (InputPlayer == Null) continue;
		if (!PageIsVisible) continue;
		
		{{{CustomUI::InjectMLLoop()}}}
		
		declare CSmPlayer TargetPlayer;
		if (GUIPlayer != Null) TargetPlayer <=> GUIPlayer;
		else TargetPlayer <=> InputPlayer;
		
		if (TargetPlayer.SpawnStatus == CSmPlayer::ESpawnStatus::Spawned && TargetPlayer.CapturedLandmark != Null && TargetPlayer.CapturedLandmark.Gauge != Null && (TargetPlayer.CapturedLandmark.Tag == "Bombsite A" || TargetPlayer.CapturedLandmark.Tag == "Bombsite B")) 
		{
			if (!Frame_Capture.Visible) Frame_Capture.Visible = True;
			Gauge_Capture.Ratio = TargetPlayer.CapturedLandmark.Gauge.ValueReal;
			Gauge_Capture.Clan = TargetPlayer.CurrentClan;
			Label_Goal.Value = "$dda"^ML::FloorInteger(TargetPlayer.CapturedLandmark.Gauge.ValueReal * 100.)^"%";
		} 
		else if (Frame_Capture.Visible) 
		{
			Frame_Capture.Visible = False;
		}
	}
}
--></script>
</manialink>	
""";
	
	return ML;	
}

Text UpdateLayerBomb()
{
	return """
<manialink version="1" name="SND:Bomb Text">
<label posn="0 81.5 250" halign="center" sizen="16 16" text="$f50BOMB" scale="0.9" style="TextTitle3"/>
</manialink>
	""";
}

Void UpdateFooter()
{
	SC_UpdateSTFooter(S_MapPointsLimit, G_ClansMapPoints[1], G_ClansMapPoints[2], G_AttackingClan);
}