// Search and hack with dolars to get better loadouts

#Extends "Modes/Shootmania/ModeBase.Script.txt"

#Const CompatibleMapTypes	"OverloadArena"
#Const Version				"2014-09-01"
#Const ScriptName			"Strike.Script.txt"

#Include "MathLib" as MathLib
#Include "TextLib" as TextLib
#Include "Libs/Nadeo/Layers2.Script.txt" as Layers
#Include "Libs/Nadeo/Message.Script.txt" as Message
#Include "Libs/Nadeo/Victory.Script.txt" as Victory
#Include "Libs/Nadeo/Sound.Script.txt" as Sound
#Include "Libs/Nadeo/CustomUI.Script.txt" as CustomUI
#Include "Libs/Nadeo/ShootMania/SM.Script.txt" as SM
#Include "Libs/Nadeo/ShootMania/Map.Script.txt" as Map
#Include "Libs/Nadeo/ShootMania/Score.Script.txt" as Score
#Include "Libs/Nadeo/Shootmania/Toss.Script.txt" as Toss
#Include "Libs/Nadeo/ShootMania/SpawnScreen.Script.txt" as SpawnScreen

#Setting S_RoundTime			120		as _("Round time in seconds")
#Setting S_PoleCaptureDuration	4		as _("Hacking time in seconds")
#Setting S_BuyTime				20		as _("Time in seconds to buy before round.")
#Setting S_MapPointsLimit		9		as _("Number of points to win the map")
#Setting S_BlueBot 				0 		as _("Number of blue test bots")
#Setting S_RedBot 				0 		as _("Number of red test bots")
//#Setting S_UseNextMapVote		True	as "<hidden>"		
// Clublinks settings
#Setting S_UsePlayerClublinks	False	as _("Use players clublinks")	// Use the players clublinks, or otherwise use the default teams
#Setting S_ForceClublinkTeam1	""		as "<hidden>"	// Force the Clublink of team 1 (format: http://www.example.com/MyTeam.Club.xml)
#Setting S_ForceClublinkTeam2	""		as "<hidden>"	// Force the Clublink of team 2 (format: http://www.example.com/MyTeam.Club.xml)

#Const Description  _("RULES: Locate vulnerable point and do overload to win the round.")

#Const C_ImgBaseDir				"file://Media/Manialinks/Shootmania/Common/"
#Const C_ImgModeDir				"file://Media/Manialinks/Shootmania/Common/FireFight"

#Const C_RocketsAmmo			3 // rockets
#Const C_BRocketsAmmo			3 // bouncing rockets
#Const C_PistolAmmo 			6 // Electric Pistol

// For easier shop management
#Const C_BoughtMoreStamina		0
#Const C_BoughtBouncingRockets	1
#Const C_BoughtElectricPistol 	2
#Const C_BoughtPlasmaGun		3
#Const C_BoughtShotgun			4
#Const C_BoughtLaser			5
#Const C_BoughtNucleus			6
#Const C_BoughtBlowBomb			7
#Const C_BoughtMortar			8			
#Const C_BoughtShield			9
#Const C_BoughtJuggernautSuit	10

								  //0,  1,   2,   3,    4,    5,    6,    7,    8,    9,  10
#Const C_ShopPrices 			[0, 700, 600, 950, 1400, 2000, 2500, 2250, 2400, 2600, 650, 3000]

#Const C_BasicStamina		 	0.7
#Const C_BasicSpeed 			0.9

#Const C_StartCash 				800
#Const C_CashForHit 			15
#Const C_CashForKill 			300
#Const C_CashForHeadshotHit 	30
#Const C_CashForCapture 		1000
#Const C_CashForWin 			1500
#Const C_CashForLoss 			750

declare Integer[Integer]			G_ClansMapPoints;		// Number of points cumulated on one map for each clan
declare Integer[Integer]			G_PlayersAlive;			// How many players are alive in specific team
declare Integer						G_Capturable; 			// Which checkpoint is capturable
declare Integer 					G_AttackingClan;		// Which clan is attacking
declare Integer[Text]				G_SecondaryWeapons;		// Current player secondary weapons
declare Integer[Text]				G_PrimaryWeapons;		// Current player secondary weapons
declare Integer 					G_LastProgressUpdate;	// Time of the last progrresion layer update
declare Integer 					G_LastSettingsUpdate; 	// Time of the last setting layer update
declare Integer 					G_LastTempUpdate;

// Globals caches the settings
declare Integer 					G_RoundTime;
declare Integer 					G_PoleCaptureDuration;
declare Integer 					G_MapPointsLimit;
declare Integer 					G_BuyTime;
declare Integer 					G_BlueBot;
declare Integer 					G_RedBot;

declare Ident[Text] 				G_ObjectId;				// Ids of the objects
declare Ident 						G_CustomBounceRocket;
declare Ident 						G_CustomGrenades;
declare Ident 						G_CustomPlasmaGun;
declare Ident 						G_CustomElectricPistol;
declare Ident 						G_CustomShotgun;
declare Ident 						G_CustomBlowBomb;

***LogVersion***
***
MB_LogVersion(ScriptName, Version);
MB_LogVersion(SM::GetScriptName(), SM::GetScriptVersion());
MB_LogVersion(Map::GetScriptName(), Map::GetScriptVersion());
MB_LogVersion(CustomUI::GetScriptName(), CustomUI::GetScriptVersion());
MB_LogVersion(Score::GetScriptName(), Score::GetScriptVersion());
MB_LogVersion(Layers::GetScriptName(), Layers::GetScriptVersion());
MB_LogVersion(Message::GetScriptName(), Message::GetScriptVersion());
MB_LogVersion(SpawnScreen::GetScriptName(), SpawnScreen::GetScriptVersion());
//MB_LogVersion(Draft::GetScriptName(), Draft::GetScriptVersion());
***

***InitServer***
***
MB_UseSectionRound		= True;
MB_UseSectionTurn		= False;
MB_UsePlayerClublinks	= S_UsePlayerClublinks;
***

***StartServer***
***
UseClans			= True;
UseProtectClanmates	= False;
UseLaserSkewering	= False;
UseAmmoBonusOnHit	= False;
UsePlayerTagging 	= True;

if(S_RoundTime < 30) G_RoundTime = 30;
else G_RoundTime = S_RoundTime;

if(S_PoleCaptureDuration < 1) G_PoleCaptureDuration = 1;
else G_PoleCaptureDuration = S_PoleCaptureDuration;

if(S_MapPointsLimit < 1) G_MapPointsLimit = 1;
else G_MapPointsLimit = S_MapPointsLimit;

if(S_BuyTime < 10) G_BuyTime = 10;
else G_BuyTime = S_BuyTime;

if(S_BlueBot <= 0) G_BlueBot = 0;
else G_BlueBot = S_BlueBot;

if(S_RedBot < 0) G_RedBot = 0;
else G_RedBot = S_RedBot;

declare ModeName = "Overload";
declare ModeObjectives = TextLib::Compose(_("$<%1Access points: $>There are 3 access points, only one is vulnerable.\n$<%1Attackers: $>Find vulnerable access point and hack to win the round.\n$<%1Defenders: $>Protect vulnerable point by %2 sec. or eliminate attackers to win the round"), "$"^SpawnScreen::GetModeColor(), TextLib::ToText(S_RoundTime));
declare ModeConditions = TextLib::Compose(_("$<%11. $>A game is divided in rounds.\n$<%12. $>The first team with %2 points wins the map.\n$<%13. $>Before round you can buy equipment using money.\n$<%14. $>You can earn money by every hit, headshot, kill, capture, win and loss."), "$"^SpawnScreen::GetModeColor(), TextLib::ToText(S_MapPointsLimit+1));

SpawnScreen::AddSubsection(_("Type"), _("Team versus Team"), 0.);
SpawnScreen::AddSubsection(_("Objectives"), ModeObjectives, 20.);
SpawnScreen::AddSubsection(_("Conditions"), ModeConditions, 55.);
SpawnScreen::CreatePrettyRules(ModeName);
ModeStatusMessage = _("RULES: Locate vulnerable point and do overload to win the round.");
SM::SetupDefaultVisibility();

Sound::Load();
Sound::Attach();
CustomUI::Load();
CustomUI::Add("Overload_PlayersList_1", <-160., 67.>, <46., 90.>, "top", "left");
CustomUI::Add("Overload_PlayersList_2", <160., 67.>, <46., 90.>, "top", "right");
CustomUI::Add("Overload_GaugeCapture", <0., -45.>, <130., 20.>, "center", "center");
CustomUI::Build();
// Create layers
Layers::Create("ProgressBar"); // Specific capture progress
Layers::Create("Markers"); // markers layer
Layers::Create("Players"); // players lists layer
Layers::Create("Shop"); // Shop 
Layers::Create("HUD"); // Hud layer when player is spawned
Layers::Create("RulesReminder", UpdateLayerRulesReminder());
Layers::SetType("Markers", CUILayer::EUILayerType::Markers);
Layers::SetType("RulesReminder", CUILayer::EUILayerType::CutScene);
Layers::Attach("RulesReminder");

// Init Actions
ActionList_Begin();
G_CustomBounceRocket 				= ActionList_Add("BRocket.Action.Gbx");
G_CustomPlasmaGun					= ActionList_Add("PlasmaGun.Action.Gbx");
G_CustomGrenades 					= ActionList_Add("Grenades.Action.Gbx");
G_CustomElectricPistol 				= ActionList_Add("ElectricPistol.Action.Gbx");
G_CustomShotgun 					= ActionList_Add("Shotgun.Action.Gbx");
G_CustomBlowBomb 					= ActionList_Add("BlowBomb.Action.Gbx");
ActionList_End();

// Init scores table
ST2::SetStyle("LibST_SMBaseTeams");
ST2::SetStyle("LibST_SMBasePoints");
ST2::SetStyle("LibST_SMWithLegends");
//ST2::SetSize(<197., -1.>, <190., -1.>, <190., -1.>);
ST2::SetSize(<197., -1.>, <190., -1.>, <190., -1.>);
ST2::SetBackgroundImage("file://Media/Manialinks/Shootmania/ScoresTable/bg-storm.dds", <0., 5.>, <240., 98.>);
ST2::SetTeamImage(1, "file://Media/Manialinks/Shootmania/ScoresTable/teamversus-left.dds", <0., 3.8>, <120.0, 25.>);
ST2::SetTeamImage(2, "file://Media/Manialinks/Shootmania/ScoresTable/teamversus-right.dds", <0., 3.8>, <120.0, 25.>);
ST2::SetFormat(2, 6);
MB_SetScoresTableStyleFromXml(S_ScoresTableStylePath);
ST2::CreateCol("ST_Captured", _("Objectives"), "0", 4.5, 90.);
ST2::CreateCol("ST_MVP", _("MVP"), "$fc0", 4.5, 95.);
ST2::SetColTextAlign("ST_Captured", CMlControl::AlignHorizontal::HCenter);
ST2::SetColTextAlign("ST_MVP", CMlControl::AlignHorizontal::HCenter);
ST2::SetColTextAlign("LibST_SMPoints", CMlControl::AlignHorizontal::HCenter);
ST2::SetColTextAlign("LibST_SMRoundPoints", CMlControl::AlignHorizontal::HCenter);
ST2::SetColLegend("LibST_SMRoundPoints", _("Round"));
ST2::SetColLegend("LibST_SMPoints", _("Score"));
ST2::SetColWidth("LibST_Name", 20.);
ST2::SetColWidth("LibST_SMRoundPoints", 4.5);
ST2::SetColWidth("LibST_SMPoints", 6.);
ST2::Build("SM");
***	

***WhenCaptured***
***
if(LandmarkGauge.Sector.PlayersIds.count > 0)
{
	foreach (PlayerId in LandmarkGauge.Sector.PlayersIds) 
	{
		if (Players.existskey(PlayerId) && Players[PlayerId].Score != Null) 
		{
			declare CurrentCapGoals for Players[PlayerId].Score = 0;
			CurrentCapGoals += 1;
			declare UI <=> UIManager.GetUI(Players[PlayerId]);
			if(UI != Null)
			{
				declare netwrite Net_Cash for UI = C_StartCash;
				Net_Cash += C_CashForCapture;
			}	
			ST2::SetColValue("ST_Captured", Players[PlayerId].Score, "$1F1"^TextLib::ToText(CurrentCapGoals));
			Score::AddPoints(Players[PlayerId], 5);	
		}
	}
}
Message::CleanBigMessages();
foreach(Player in Players)
{
	declare MSG = "";
	switch(Player.User.Language)
	{
		case "pl": MSG = TextLib::Compose(_("$<%1$> zhakowali punkt dostępu!"), Teams[G_AttackingClan-1].ColorizedName);
		default: MSG = TextLib::Compose(_("$<%1$> hacked the access point!"), Teams[G_AttackingClan-1].ColorizedName);
	} 
	Message::SendBigMessage(Player, MSG, 3500, 0);
}	
foreach(Spectator in Spectators)
{
	declare MSG = "";
	switch(Spectator.User.Language)
	{
		case "pl": MSG = TextLib::Compose(_("$<%1$> zhakowali punkt dostępu!"), Teams[G_AttackingClan-1].ColorizedName);
		default: MSG = TextLib::Compose(_("$<%1$> hacked the access point!"), Teams[G_AttackingClan-1].ColorizedName);
	} 
	Message::SendBigMessage(Spectator, MSG, 4000, 0);
}
Mode::PlaySound(CUIConfig::EUISound::Capture, 0);
RoundClanWinner = G_AttackingClan;
MB_StopRound = True;
***	

***AnnounceHeadshot***
***
declare headdistance = MathLib::Distance(HeadPosi, stutz);
if (headdistance < 0.2)
{
	Message::SendStatusMessage(Event.Shooter, TextLib::Compose(_("$f90Headshot!")), 2500, 1);
	declare MSG = "";
	switch(Event.Victim.User.Language)
	{
		case "pl": MSG = "trafił cię w głowę!";
		case "fr": MSG = "t'as tiré dans la tête !";
		case "ru": MSG = "попал в голову!";
		case "it": MSG = "Ti ha colpito Alla testa!";
		case "de": MSG = "Am Kopf getroffen!";
		default: MSG = "hit your head!";
	}
	Message::SendStatusMessage(Event.Victim, TextLib::Compose(_("$<%1$> %2"), Event.Shooter.Name, MSG), 2500, 1);
	Sound::PlaySound("file://Media/Sounds/FireFight/headshot.ogg", -1., 200, Event.Shooter);
	Sound::PlaySound("file://Media/Sounds/FireFight/headshot.ogg", -1., 300, Event.Victim);
	Score::AddPoints(Event.Shooter, 1);
	declare UI <=> UIManager.GetUI(Event.Shooter);
	if(UI != Null)
	{
		declare netwrite Net_Cash for UI = C_StartCash;
		Net_Cash += C_CashForHeadshotHit;
	}	
	Event.ShooterPoints += 1;
	Event.Damage += 100;
}
***

***ActionMakerAnnounceHeadshot***
***
declare headdistance = MathLib::Distance(HeadPosi, stutz);
if (headdistance < 0.2)
{
	Message::SendStatusMessage(Event.Shooter, TextLib::Compose(_("$f90Headshot!")), 2500, 1);
	declare MSG = "";
	switch(Event.Victim.User.Language)
	{
		case "pl": MSG = "trafił cię w głowę!";
		case "fr": MSG = "t'as tiré dans la tête !";
		case "ru": MSG = "попал в голову!";
		case "it": MSG = "Ti ha colpito Alla testa!";
		case "de": MSG = "Am Kopf getroffen!";
		default: MSG = "hit your head!";
	}
	Message::SendStatusMessage(Event.Victim, TextLib::Compose(_("$<%1$> %2"), Event.Shooter.Name, MSG), 2500, 1);
	Sound::PlaySound("file://Media/Sounds/FireFight/headshot.ogg", -1., 200, Event.Shooter);
	Sound::PlaySound("file://Media/Sounds/FireFight/headshot.ogg", -1., 300, Event.Victim);
	Score::AddPoints(Event.Shooter, 1);
	declare UI <=> UIManager.GetUI(Event.Shooter);
	if(UI != Null)
	{
		declare netwrite Net_Cash for UI = C_StartCash;
		Net_Cash += C_CashForHeadshotHit;
	}	
	Points += 1;
	Damage += 100;
}
***

***HeadshotFunctions***
***
declare HeadPosi = <Event.Victim.Position[0]+Event.Victim.AimDirection[0]*0.2, Event.Victim.Position[1]+1.5, Event.Victim.Position[2]+Event.Victim.AimDirection[2]*0.2>;
declare ShootPosi = Event.Shooter.Position+<0.0, 1.35, 0.0>;
declare ShootDir = Event.Shooter.AimDirection;
declare a1 = Private_Skalar(ShootDir, ShootPosi);
declare a2 = Private_Skalar(ShootDir, ShootDir);
declare a3 = Private_Skalar(ShootDir, -HeadPosi);
declare gamma = (a1+a3)/(-1*a2);
declare stutz = ShootPosi + (gamma*ShootDir);		
***

***OnNearMiss***
***
if (Event.Shooter == Null || Event.Shooter == Event.Victim) Discard(Event);
else 
{
	if (Event.WeaponNum == GetWeaponNum(CSmMode::EWeapon::Laser)) 
	{
		declare MaxMissDist = 0.2;
		if (Event.Shooter != Null && Event.Victim != Null) 
		{
			declare Distance = MathLib::Distance(Event.Shooter.Position, Event.Victim.Position);
			MaxMissDist = Distance * 2 / 100;
			if (MaxMissDist > 0.2) MaxMissDist = 0.2;
	
			if (Event.MissDist <= MaxMissDist)
			{
				declare MSG1 = "";
				switch(Event.Shooter.User.Language)
				{
					case "pl": MSG1 = "Chybiłeś o $ff0%2cm$g gracza $<%1$>.";
					case "fr": MSG1 = "Tu as loupé $<%1$> de $ff0%2cm.";
					case "ru": MSG1 = "Вы промахнулись по $<%1$> на $ff0%2см.";
					case "it": MSG1 = "È mancato $ff0%2cm$g al giocatore $<%1$>.";
					case "de": MSG1 = "$<%1$> um $ff0%2cm verfehlt.";
					default: MSG1 = "You missed $<%1$> by $ff0%2cm.";
				}

				declare MSG2 = "";
				switch(Event.Victim.User.Language)
				{
					case "pl": MSG2 = "Uniknąłeś trafienia z lasera $<%1$> o $ff0%2cm.";
					case "fr": MSG2 = "Tu as esquivé le laser de $<%1$> de $ff0%2cm.";
					case "ru": MSG2 = "Вы уклонились от лазера $<%1$> на $ff0%2см.";
					case "it": MSG2 = "Hai evitato un colpito di laser $<%1$> di $ff0%2cm.";
					case "de": MSG2 = "Der Laser hat $<%1$> um $ff0%2cm verfehlt.";
					default: MSG2 = "You dodged $<%1$> laser by $ff0%2cm.";
				}
				if (Event.MissDist < 0.01)
				{
					Message::SendStatusMessage(Event.Shooter, TextLib::Compose(MSG1, Event.Victim.Name, TextLib::ToText(1)), 3000, 2);
					Message::SendStatusMessage(Event.Victim, TextLib::Compose(MSG2, Event.Shooter.Name), 3000, 2);
				}
				else
				{
					Message::SendStatusMessage(Event.Shooter, TextLib::Compose(MSG1, Event.Victim.Name, TextLib::ToText(MathLib::CeilingInteger(Event.MissDist*100))), 3000, 2);
					Message::SendStatusMessage(Event.Victim, TextLib::Compose(MSG2, Event.Shooter.Name, TextLib::ToText(MathLib::CeilingInteger(Event.MissDist*100))), 3000, 2);
				}	
				XmlRpc::OnNearMiss(Event);
				PassOn(Event);
			}
			else Discard(Event);
		}
	}
}
***

***StartMatch***
***
// Reset clan scores
ClanScores[1] = 0;
ClanScores[2] = 0;
***

***InitMap***
***
declare Integer		ClanMapWinner;		// Clan who win the map
declare Integer 	VoteClanNb;			// Who will use tosS?
MB_UseIntro = False;
***

***StartMap***
***
UIManager.UIAll.MarkersXML = "";
UIManager.UIAll.ScreenIn3dHideVersus = False;
UIManager.UIAll.ScreenIn3dHideScoreSummary = True;
UIManager.UIAll.NoticesFilter_HideMapInfo = True;
UIManager.UIAll.NoticesFilter_HideMapWarning = True;
UIManager.UIAll.NoticesFilter_HideMatchInfo = True;
// Init player labels visibility
UIManager.UIAll.TeamLabelsVisibility = CUIConfig::ELabelsVisibility::WhenVisible;
UIManager.UIAll.TeamLabelsShowGauges = CUIConfig::EVisibility::ForcedHidden;
UIManager.UIAll.TeamLabelsShowNames = CUIConfig::EVisibility::Normal;
UIManager.UIAll.OpposingTeamLabelsVisibility = CUIConfig::ELabelsVisibility::WhenInMiddleOfScreen;
G_ClansMapPoints	= [1 => 0, 2 => 0];
G_Capturable 		= 0;
G_AttackingClan = 1;
G_SecondaryWeapons.clear();
G_PrimaryWeapons.clear();
ClanMapWinner		= 0;
// reset custom scores table data
foreach(Score in Scores)
{
	declare CurrentCapGoals for Score = 0;
	CurrentCapGoals = 0;
	declare CurrentMVP for Score = 0;
	CurrentMVP = 0;
}
// Init scores
Score::MatchBegin();
ST2::ClearScores();

// Init players
foreach (Player in Players)
{
	SetPlayerClan(Player, Player.RequestedClan);
	declare UI <=> UIManager.GetUI(Player);
	if(UI == Null) continue;
	declare netwrite Net_Cash for UI = C_StartCash;
	Net_Cash = C_StartCash;
	declare netwrite Net_Bought for UI = [False, False, False, False, False, False, False, False, False, False, False];
	Net_Bought = [False, False, False, False, False, False, False, False, False, False, False];
	
}	

// Update the players clublinks
if (S_ForceClublinkTeam1 == "" && S_ForceClublinkTeam2 == "") Clublink::DefineTeamAuto();
else Clublink::DefineTeamFromUrl(S_ForceClublinkTeam1, S_ForceClublinkTeam2);
Clublink::SyncUpdate();

// Init UI
SM::SetupDefaultVisibility();
Message::CleanAllMessages();
Clublink::Attach();
Clublink::SetSponsorsDisplay(False);
UpdateHeader(G_ClansMapPoints[1], G_ClansMapPoints[2]);

// Debug
Users_SetNbFakeUsers(G_BlueBot, G_RedBot);

SM::UnspawnAllPlayers();
WaitForPlayers();
***

***InitRound***
***
declare Integer RoundClanWinner;// Team, who win the round
declare Integer TempGoalNb;		// To stop looping
declare Integer BestRoundScore;	// The best RoundPoints score in round
declare CSmPlayer MVP;			// The best player in round
***

***StartRound***
***
TempGoalNb = 0;
RoundClanWinner = 0;
BestRoundScore = 0;
MVP = Null;
G_LastProgressUpdate = 0;
G_LastSettingsUpdate = 0;
G_LastTempUpdate = 0;
G_Capturable = MathLib::Rand(1, 3);
G_SecondaryWeapons.clear();
G_PrimaryWeapons.clear();
Mode::Synchro_DoBarrier();
UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::Normal;
Victory::RoundBegin();
Score::RoundBegin();
UpdateSTFooter();
InitGoals();
UIManager.UIAll.UISequence = CUIConfig::EUISequence::EndRound;
// If this is the first round and turn on the map, launch the players presentation
if (MB_SectionRoundNb == 1) 
{
	UpdateHeader(G_ClansMapPoints[1], G_ClansMapPoints[2]);
	MB_PlayersPresentationSequence(2500);

	// Play the toss
	if (MB_SectionMapNb == 1) 
	{
		MB_UseIntro = True;
		UIManager.UIAll.UISequence_CanSkipIntroMT = False;
		UIManager.UIAll.UISequence = CUIConfig::EUISequence::RollingBackgroundIntro;
		VoteClanNb = Toss::Toss();
		G_AttackingClan = Toss::SelectSide(VoteClanNb);
	}
}
UIManager.UIAll.UISequence = CUIConfig::EUISequence::EndRound;
UIManager.UIAll.UISequence_CanSkipIntroMT = True;
Message::CleanAllMessages();
Mode::PlaySound(CUIConfig::EUISound::StartRound, 0);
UpdateHeader(G_ClansMapPoints[1], G_ClansMapPoints[2]);
UpdateBasesColors();
Layers::Update("Players", UpdateLayerPlayers());
Layers::Attach("Players");
Layers::Hide("Players");
if(ServerShutdownRequested || MatchEndRequested) break;
UIManager.UIAll.MarkersXML = "";
Layers::Update("Shop", UpdateLayerShop());
EnableBuyZone(G_BuyTime*1000);

// Init players and spawn ticket
foreach (Player in AllPlayers) 
{
	declare UI <=> UIManager.GetUI(Player);
	declare SpawnTicket for Player = 0;
	SpawnTicket = 1;
	ActionLoad(Player, CSmMode::EActionSlot::Slot_A, NullId);
	ActionBind(Player, CSmMode::EActionSlot::Slot_A, CSmMode::EActionInput::None);
	declare PrimaryWeapon for Player = 0;
	PrimaryWeapon = 0;
	if (UI != Null) 
	{ 
		declare netwrite Integer[Text] Net_PrimaryWeapons for UI;
		Net_PrimaryWeapons[Player.Login] = 0;
	}
	declare HasChangedClan for Player = False;
	declare NewSpectator for Player = False;
	SetPlayerClan(Player, Player.RequestedClan);
	HasChangedClan = False;
	NewSpectator = True;
}

foreach (Spectator in Spectators) {
	declare NewSpectator for Spectator = False;
	NewSpectator = False;
}

// Init spectator mode
foreach (Player in AllPlayers) 
{
	declare UI <=> UIManager.GetUI(Player);
	if (UI == Null) continue;
	
	if (Player.RequestsSpectate) 
	{
		declare SpawnTicket for Player = 0;
		SpawnTicket = 0;
		UI.SpectatorForceCameraType = -1;
		UI.SpectatorForcedClan = -1;
	} 
	else 
	{
		UI.SpectatorForceCameraType = 1;
		UI.SpectatorForcedClan = Player.CurrentClan;
	}
}

// Update the players clublinks
if (S_ForceClublinkTeam1 == "" && S_ForceClublinkTeam2 == "") Clublink::DefineTeamAuto();
else Clublink::DefineTeamFromUrl(S_ForceClublinkTeam1, S_ForceClublinkTeam2);
Clublink::SyncUpdate();
CustomUI::Attach();
UIManager.UIAll.UISequence = CUIConfig::EUISequence::Playing;
Layers::Update("ProgressBar", UpdateLayerProgressBar());
Layers::Attach("ProgressBar");
Layers::Attach("Markers");
Layers::Update("HUD", UpdateLayerHUD());
Layers::Attach("HUD");
Layers::Show("Players");
UpdateMarker();
//MB_Log("G_Capturable = "^G_Capturable);

// Set the timers
StartTime = Now;
if (G_RoundTime > 0) EndTime = Now + (G_RoundTime*1000) + 3000;
else EndTime = Now;
UIManager.UIAll.CountdownEndTime = -1;
***

***OnNewPlayer***
***
declare UI <=> UIManager.GetUI(Player);
if (UI != Null) 
{
	UI.SpectatorForcedClan		= Player.CurrentClan;
	UI.SpectatorForceCameraType	= 1;
	Layers::Attach("Progression", Player);
	declare CurrentCapGoals for Player.Score = 0;
	declare CurrentMVP for Player.Score = 0;
	declare netwrite Net_PrimaryWeapon for UI = 0;
	Net_PrimaryWeapon = 0;
}
***

***OnNewSpectator***
***
declare UI <=> UIManager.GetUI(Spectator);
if (UI != Null) {
	UI.SpectatorForcedClan		= -1;
	UI.SpectatorForceCameraType	= -1;
	Layers::Attach("Progression", Spectator);
}
declare SpawnTicket for Spectator = 100;
SpawnTicket = 0;
***

***Yield***
***
Message::Loop();
***

***PlayLoop***
***
declare PlayerCountA = [1 => 0, 2 => 0];
declare PlayerCountB = [1 => 0, 2 => 0];
declare PlayerCountC = [1 => 0, 2 => 0];

if(G_LastSettingsUpdate + 2000 < Now)
{
	G_LastSettingsUpdate = Now;
	if(S_RoundTime < 20) G_RoundTime = 20;
	else G_RoundTime = S_RoundTime;

	if(S_PoleCaptureDuration < 1) G_PoleCaptureDuration = 1;
	else G_PoleCaptureDuration = S_PoleCaptureDuration;

	if(S_MapPointsLimit < 1)
	{
		G_MapPointsLimit = 1;
		UpdateSTFooter();
	}	
	else
	{
		G_MapPointsLimit = S_MapPointsLimit;
		UpdateSTFooter();
	}
	
	if(S_BlueBot < 0) G_BlueBot = 0;
	else G_BlueBot = S_BlueBot;

	if(S_RedBot < 0) G_RedBot = 0;
	else G_RedBot = S_RedBot;
	
	Users_SetNbFakeUsers(G_BlueBot, G_RedBot);
	
	if(PlayersNbTotal < 2) MB_StopRound = True;
}

// Unspawn and mark players changing clan
foreach (Player in Players) {
	if (!Player.IsFakePlayer && Player.SpawnStatus == CSmPlayer::ESpawnStatus::Spawned) {
		// if the player wants to change clan, then remove him from the current clan
		// it will be added to the correct clan at next respawn.
		if (Player.CurrentClan != 0 && Player.RequestedClan != Player.CurrentClan) {
			UnspawnPlayer(Player);
			declare HasChangedClan for Player = False;
			HasChangedClan = True;
		}
	}
	if(!Player.IsFakePlayer && Player.RequestsSpectate)
	{
		declare NewSpectator for Player = False;
		NewSpectator = True;
	}
}

// Don't let players going spectate respawn afterward
foreach (Spectator in Spectators) 
{
	declare NewSpectator for Spectator = False;
	if (NewSpectator) NewSpectator = False;
}
// Spawning players
if(RoundClanWinner == 0)
{
	foreach (Player in Players)
	{
		declare HasChangedClan for Player = False;
		declare NewSpectator for Player = True;
		if (Player.SpawnStatus == CSmPlayer::ESpawnStatus::NotSpawned && !HasChangedClan)
		{
			declare SecondaryWeapon for Player = 1;
			declare SpawnTicket for Player = 0;
			if(SpawnTicket <= 0) continue;
			if (Player.CurrentClan != 1 && Player.CurrentClan != 2) SetPlayerClan(Player, Player.RequestedClan);
			if (Player.RequestedClan == 1)
			{
				if(G_AttackingClan == 1)
				{
					Player.Armor = 300;
					Player.ArmorMax = 300;
					SM::SpawnPlayer(Player, Player.CurrentClan, Map::GetPlayerSpawn("SpawnAttack", 0), 3000);
					declare MSG2 = "";
					Message::SendBigMessage(Player, TextLib::Compose(_("|Imperative|Attack")), 6000, 0);
					
					switch(Player.User.Language)
					{
						case "pl": MSG2 = "$f90Znajdź punkt podatny na atak i go zdobądź by wygrać rundę.";
						default: MSG2 = "$f90Locate vulnerable access point and do the overload to win the round.";	
					} 
					Message::SendStatusMessage(Player, MSG2, 6500, 0);
				}	
				else
				{
					Player.Armor = 300;
					Player.ArmorMax = 300;
					SM::SpawnPlayer(Player, Player.CurrentClan, Map::GetPlayerSpawn("SpawnDefence", 0), 3000);
					declare MSG2 = ""; 
					Message::SendBigMessage(Player, TextLib::Compose(_("|Imperative|Defend")), 6000, 0);
					
					switch(Player.User.Language)
					{
						case "pl": MSG2 = "$f90Broń punktu podatnego na ataki do końca trwania rundy.";
						default: MSG2 = "$f90Protect vulnerable access point to end of the round.";	
					} 
					Message::SendStatusMessage(Player, MSG2, 6500, 0);
				}	
				SpawnTicket = 0;
				declare UI <=> UIManager.GetUI(Player);
				if (UI != Null) 
				{
					declare netread Net_Bought for UI = [False, False, False, False, False, False, False, False, False, False, False];
	
					if(Net_Bought[C_BoughtMoreStamina])
					{
						Player.StaminaMax = 1.0;
						Player.StaminaGain = 1.0;
						Player.SpeedPower = 1.0;
					}
					else
					{
						Player.StaminaMax = C_BasicStamina;
						Player.StaminaGain = C_BasicStamina;
						Player.SpeedPower = C_BasicSpeed;
					}
					if(Net_Bought[C_BoughtShield])
					{
						Player.ArmorMax = 400;
						Player.Armor = 400;
					}
					else if(Net_Bought[C_BoughtJuggernautSuit])
					{
						Player.ArmorMax = 600;
						Player.Armor = 600;
					}
					else
					{
						Player.Armor = 300;
						Player.ArmorMax = 300;
					}
					if(Net_Bought[C_BoughtBouncingRockets])
					{
						ActionLoad(Player, CSmMode::EActionSlot::Slot_B, G_CustomBounceRocket);
    					ActionBind(Player, CSmMode::EActionSlot::Slot_B, CSmMode::EActionInput::Weapon);
						SecondaryWeapon = 2;
					}
					else if(Net_Bought[C_BoughtElectricPistol])
					{
						ActionLoad(Player, CSmMode::EActionSlot::Slot_B, G_CustomElectricPistol);
    					ActionBind(Player, CSmMode::EActionSlot::Slot_B, CSmMode::EActionInput::Weapon);
						SecondaryWeapon = 3;
					}
					else
					{
						ActionBind(Player, CSmMode::EActionSlot::Slot_B, CSmMode::EActionInput::None);
						SetPlayerWeapon(Player, CSmMode::EWeapon::Rocket, False);
						SetPlayerAmmoMax(Player, CSmMode::EWeapon::Rocket, C_RocketsAmmo);
						Player.AmmoGain = 1.0;
						SecondaryWeapon = 1;
					}
				}	
				G_SecondaryWeapons[Player.Login] = SecondaryWeapon;
				if (UI != Null)
				{
					declare netwrite Integer[Text] Net_SecondaryWeapons for UI;
					Net_SecondaryWeapons = G_SecondaryWeapons;
				}	
			}
			else if (Player.RequestedClan == 2)
			{
				if(G_AttackingClan == 2)
				{
					SM::SpawnPlayer(Player, Player.CurrentClan, Map::GetPlayerSpawn("SpawnAttack", 0), 3000);
					declare MSG2 = "";
					Message::SendBigMessage(Player, TextLib::Compose(_("|Imperative|Attack")), 6000, 0);
					
					switch(Player.User.Language)
					{
						case "pl": MSG2 = "$9d0Znajdź punkt podatny na atak i go zdobądź by wygrać rundę.";
						default: MSG2 = "$f90Locate vulnerable access point and do the overload to win the round.";	
					} 
					Message::SendStatusMessage(Player, MSG2, 6500, 0);
				}	
				else
				{
					SM::SpawnPlayer(Player, Player.CurrentClan, Map::GetPlayerSpawn("SpawnDefence", 0), 3000);
					declare MSG2 = "";
					Message::SendBigMessage(Player, TextLib::Compose(_("|Imperative|Defend")), 6000, 0);
					
					switch(Player.User.Language)
					{
						case "pl": MSG2 = "$f90Broń punktu podatnego na ataki do końca trwania rundy.";
						default: MSG2 = "$f90Protect vulnerable access point to end of the round.";	
					} 
					Message::SendStatusMessage(Player, MSG2, 6500, 0);
				}	
				SpawnTicket = 0;
				declare UI <=> UIManager.GetUI(Player);
				if (UI != Null) 
				{
					declare netread Net_Bought for UI = [False, False, False, False, False, False, False, False, False, False, False];
			
					if(Net_Bought[C_BoughtMoreStamina])
					{
						Player.StaminaMax = 1.0;
						Player.StaminaGain = 1.0;
						Player.SpeedPower = 1.0;
					}
					else
					{
						Player.StaminaMax = C_BasicStamina;
						Player.StaminaGain = C_BasicStamina;
						Player.SpeedPower = C_BasicSpeed;
					}
					if(Net_Bought[C_BoughtShield])
					{
						Player.ArmorMax = 400;
						Player.Armor = 400;
					}
					else if(Net_Bought[C_BoughtJuggernautSuit])
					{
						Player.ArmorMax = 600;
						Player.Armor = 600;
					}
					if(Net_Bought[C_BoughtBouncingRockets])
					{
						ActionLoad(Player, CSmMode::EActionSlot::Slot_B, G_CustomBounceRocket);
    					ActionBind(Player, CSmMode::EActionSlot::Slot_B, CSmMode::EActionInput::Weapon);
						SecondaryWeapon = 2;
					}
					else if(Net_Bought[C_BoughtElectricPistol])
					{
						ActionLoad(Player, CSmMode::EActionSlot::Slot_B, G_CustomElectricPistol);
    					ActionBind(Player, CSmMode::EActionSlot::Slot_B, CSmMode::EActionInput::Weapon);
						SecondaryWeapon = 3;
					}
					else
					{
						ActionBind(Player, CSmMode::EActionSlot::Slot_B, CSmMode::EActionInput::None);
						SetPlayerWeapon(Player, CSmMode::EWeapon::Rocket, False);
						SetPlayerAmmoMax(Player, CSmMode::EWeapon::Rocket, C_RocketsAmmo);
						Player.AmmoGain = 1.0;
						SecondaryWeapon = 1;
					}
				}	
				G_SecondaryWeapons[Player.Login] = SecondaryWeapon;
				if (UI != Null)
				{
					declare netwrite Integer[Text] Net_SecondaryWeapons for UI;
					Net_SecondaryWeapons = G_SecondaryWeapons;
				}
			}
		}
	}		
}

// Timer management
if (G_RoundTime > 0) 
{
	// End of the round, attackers didn't capture checkpoint
	if (Now == EndTime) 
	{
		foreach (Player in Players)
		{
			declare SpawnTicket for Player = 0;
			SpawnTicket = 0;
		}
		SM::UnspawnAllPlayers();
		Message::CleanBigMessages();
		Message::SendBigMessage(TextLib::Compose(_("Time limit reached!")), 4000, 0);
		Victory::SetRoundWinnerIfNoWinner(3-G_AttackingClan);
		RoundClanWinner = 3-G_AttackingClan;
		MB_StopRound = True;
	}
}

// Poles management
foreach (LandmarkGauge in MapLandmarks_Gauge) 
{
	if(LandmarkGauge.Sector != Null)
	{
		if(LandmarkGauge.Tag == "Server A")
		{
			if (LandmarkGauge.Sector.PlayersIds.count > 0 && G_Capturable == 1) 
			{
				foreach (PlayerId in LandmarkGauge.Sector.PlayersIds) 
				{
					declare Player <=> Players[PlayerId];
					PlayerCountA[Player.CurrentClan] += 1;
				}
			}
		}
		if(LandmarkGauge.Tag == "Server B")
		{
			if (LandmarkGauge.Sector.PlayersIds.count > 0 && G_Capturable == 2) 
			{
				foreach (PlayerId in LandmarkGauge.Sector.PlayersIds) 
				{
					declare Player <=> Players[PlayerId];
					PlayerCountB[Player.CurrentClan] += 1;
				}
			}
		}
		if(LandmarkGauge.Tag == "Server C")
		{
			if (LandmarkGauge.Sector.PlayersIds.count > 0 && G_Capturable == 3) 
			{
				foreach (PlayerId in LandmarkGauge.Sector.PlayersIds) 
				{
					declare Player <=> Players[PlayerId];
					PlayerCountC[Player.CurrentClan] += 1;
				}
			}
		}						
	}
}

foreach (LandmarkGauge in MapLandmarks_Gauge) 
{
	if(LandmarkGauge.Sector != Null)
	{
		if(LandmarkGauge.Tag == "Server A" && G_Capturable == 1)
		{
			// Capturing
			if (PlayerCountA[G_AttackingClan] > 0 && !LandmarkGauge.Gauge.Captured) LandmarkGauge.Gauge.Speed = 1;
			else
			{
				LandmarkGauge.Gauge.ValueReal = 0.;
				LandmarkGauge.Gauge.Speed = 0;
			}	
			// Captured
			if (LandmarkGauge.Gauge.Value >= LandmarkGauge.Gauge.Max) 
			{
				LandmarkGauge.Gauge.Captured = True;
				---WhenCaptured---
			}
		}
		if(LandmarkGauge.Tag == "Server B" && G_Capturable == 2)
		{
			// Capturing
			if (PlayerCountB[G_AttackingClan] > 0 && !LandmarkGauge.Gauge.Captured) LandmarkGauge.Gauge.Speed = 1;
			else
			{
				LandmarkGauge.Gauge.ValueReal = 0.;
				LandmarkGauge.Gauge.Speed = 0;
			}
			// Captured
			if (LandmarkGauge.Gauge.Value >= LandmarkGauge.Gauge.Max) 
			{
				LandmarkGauge.Gauge.Captured = True;
				---WhenCaptured---
			}
		}
		if(LandmarkGauge.Tag == "Server C" && G_Capturable == 3)
		{
			// Capturing
			if (PlayerCountC[G_AttackingClan] > 0 && !LandmarkGauge.Gauge.Captured) LandmarkGauge.Gauge.Speed = 1;
			else
			{
				LandmarkGauge.Gauge.ValueReal = 0.;
				LandmarkGauge.Gauge.Speed = 0;
			}
			// Captured
			if (LandmarkGauge.Gauge.Value >= LandmarkGauge.Gauge.Max) 
			{
				LandmarkGauge.Gauge.Captured = True;
				---WhenCaptured---
			}
		}	
	}
}

if(G_LastProgressUpdate + 800 < Now)
{
	G_LastProgressUpdate = Now;
	Layers::Update("HUD", UpdateLayerHUD());

	G_PlayersAlive = [1 => 0, 2 => 0];
	
	foreach(Player in Players)
	{
		if(Player.Armor > 0 && Player.CurrentClan > 0) G_PlayersAlive[Player.CurrentClan] += 1;
	}	
	if(G_PlayersAlive[1] <= 0)
	{
		Victory::SetRoundWinnerIfNoWinner(2);
		RoundClanWinner = 2;
		MB_StopRound = True;
		AnnounceEliminationMessage(0, 0);
	}
	else if(G_PlayersAlive[2] <= 0)
	{
		Victory::SetRoundWinnerIfNoWinner(1);
		RoundClanWinner = 1;
		MB_StopRound = True;
		AnnounceEliminationMessage(1, 0);
	}
}

// Events
foreach (Event in PendingEvents) 
{
	// On action event
	if (Event.Type == CSmModeEvent::EType::OnActionEvent) 
	{
		if (Event.Player == Null) Discard(Event);
		else 
		{
			SwitchWeapon(Event.Player, Event.ActionInput);
			PassOn(Event);
		}		
	}
	// On player request action change
	/*else if (Event.Type == CSmModeEvent::EType::OnPlayerRequestActionChange) {
		if (Event.Player == Null) Discard(Event);
		else {
			CycleWeapon(Event.Player, Event.ActionChange);
			PassOn(Event);
		}
	}*/
	// Armor empty
	else if (Event.Type == CSmModeEvent::EType::OnArmorEmpty && Event.Victim != Null) 
	{
		if (Event.Victim.Armor > 100)
		{
			declare SpawnTicket for Event.Victim = 0;
			SpawnTicket = 1;
		}
		else
		{
			declare SpawnTicket for Event.Victim = 0;
			SpawnTicket = 0;
			declare SUI <=> UIManager.GetUI(Event.Shooter);
			if (SUI != Null)
			{
				declare netwrite Net_Cash for SUI = C_StartCash;
				Net_Cash += C_CashForKill;
			}	
			//Remove eq that player bought
			ActionBind(Event.Victim, CSmMode::EActionSlot::Slot_A, CSmMode::EActionInput::None);
			SetPlayerAmmoMax(Event.Victim, CSmMode::EWeapon::Laser, 0);
			SetPlayerAmmoMax(Event.Victim, CSmMode::EWeapon::Nucleus, 0);
			declare UI <=> UIManager.GetUI(Event.Victim);
			if (UI != Null) 
			{
				declare netwrite Net_PrimaryWeapon for UI = 0;
				Net_PrimaryWeapon = 0;
				declare netwrite Net_Bought for UI = [False, False, False, False, False, False, False, False, False, False, False];
				Net_Bought = [False, False, False, False, False, False, False, False, False, False, False];
			}
			foreach(Player in Players)
			{
				declare UI <=> UIManager.GetUI(Player);
				if (UI != Null) 
				{
					declare netwrite Integer[Text] Net_PrimaryWeapons for UI;
					Net_PrimaryWeapons[Event.Victim.Login] = 0;
				}
			}
			
			if (G_PlayersAlive[Event.Victim.CurrentClan] > 1) 
			{
				declare PLeft = G_PlayersAlive[Event.Victim.CurrentClan]-1;
				if (PLeft <= 3) AnnounceEliminationMessage(Event.Victim.CurrentClan-1, PLeft);
			}
		}	
		XmlRpc::OnArmorEmpty(Event);
		PassOn(Event);
	}
	// Damage
	else if(Event.Type == CSmModeEvent::EType::OnHit && Event.Victim != Null) 
	{
		// Discard friendly fire
		if (Event.Shooter != Null && Event.Shooter.CurrentClan == Event.Victim.CurrentClan) {
			Discard(Event);
		} 
		else 
		{
			if(Event.WeaponNum == GetWeaponNum(CSmMode::EWeapon::Laser))
			{
				declare UI <=> UIManager.GetUI(Event.Shooter);
				if(UI != Null)
				{
					// Get distance
					declare Distance = MathLib::Distance(Event.Shooter.Position, Event.Victim.Position);
					AnnounceHitDistance(Distance, Event.Shooter);
				}
				Event.Damage = 200;
				Event.ShooterPoints = 2;
			}		
			if (Event.Shooter != Event.Victim)
			{
				declare UI <=> UIManager.GetUI(Event.Shooter);
				if (UI != Null) 
				{
					declare netwrite Net_Cash for UI = C_StartCash;
					Score::AddPoints(Event.Shooter, Event.Damage/100);
					Net_Cash += C_CashForHit;
					---HeadshotFunctions---
					---AnnounceHeadshot---
				}
				if(Event.Victim.Armor - Event.Damage <= 0)
				{
					declare SpawnTicket for Event.Victim = 0;
					SpawnTicket = 0;
				}		
			}	

			XmlRpc::OnHit(Event);
			PassOn(Event);
		}
	}
	// Action Maker Events
	else if(Event.Type == CSmModeEvent::EType::OnActionCustomEvent)
	{
		if(Event.Shooter == Null || Event.Victim == Null) Discard(Event);
		// Discard friendly fire
		if (Event.Param1 == "damage" && Event.Victim != Null && Event.Shooter != Null && Event.Shooter.CurrentClan == Event.Victim.CurrentClan) Discard(Event);
		else if(Event.Param1 == "damage" && Event.Victim != Null && Event.Shooter != Null && Event.Victim != Event.Shooter) 
		{
			declare Damage = TextLib::ToInteger(Event.Param2[0]);
           	declare Points = Damage / 100;
			declare UI <=> UIManager.GetUI(Event.Shooter);
			if (UI != Null) 
			{
				declare netwrite Net_Cash for UI = C_StartCash;
            	Net_Cash += C_CashForHit;
				---HeadshotFunctions---
				---ActionMakerAnnounceHeadshot---
			}
            RemovePlayerArmor(Event.Victim, Damage, Event.Shooter, Points);
            Score::AddPoints(Event.Shooter, Points);
          	if(Event.Victim.Armor - Damage <= 0)
			{
				declare SpawnTicket for Event.Victim = 0;
				SpawnTicket = 0;
			}	
            PassOn(Event);
        }  
	}
	// On near miss
	else if(Event.Type == CSmModeEvent::EType::OnNearMiss && Event.Victim != Null) 
	{
		---OnNearMiss---
	}
	// Give Up
	else if (Event.Type == CSmModeEvent::EType::OnPlayerRequestRespawn && Event.Player != Null) 
	{
		declare Message = "";
		declare SpawnTicket for Event.Player = 0;
		SpawnTicket = 0;

		//Remove eq that player bought
		ActionBind(Event.Victim, CSmMode::EActionSlot::Slot_A, CSmMode::EActionInput::None);
		SetPlayerAmmoMax(Event.Victim, CSmMode::EWeapon::Laser, 0);
		SetPlayerAmmoMax(Event.Victim, CSmMode::EWeapon::Nucleus, 0);
		declare UI <=> UIManager.GetUI(Event.Player);
		if (UI != Null) 
		{
			declare netwrite Net_PrimaryWeapon for UI = 0;
			Net_PrimaryWeapon = 0;
			declare netwrite Net_Bought for UI = [False, False, False, False, False, False, False, False, False, False, False];
			Net_Bought = [False, False, False, False, False, False, False, False, False, False, False];
		}
		foreach(Player in Players)
		{
			declare UI <=> UIManager.GetUI(Player);
			if (UI != Null) 
			{
				declare netwrite Integer[Text] Net_PrimaryWeapons for UI;
				Net_PrimaryWeapons[Event.Player.Login] = 0;
			}
		}
		if(G_PlayersAlive[Event.Player.CurrentClan] > 1) 
		{
			declare PLeft = G_PlayersAlive[Event.Player.CurrentClan];
			if(PLeft <= 3) AnnounceEliminationMessage(Event.Player.CurrentClan-1, PLeft);
	 	}

		XmlRpc::OnPlayerRequestRespawn(Event);
		PassOn(Event);
	} 
	// Goal Captured
	else if (Event.Type == CSmModeEvent::EType::OnCapture && Event.Landmark != Null) {
		Discard(Event);
	}
	// Other events
	else {
		PassOn(Event);
	}
}
***

***EndRound***
***
Layers::Detach("Markers");
// Search for MVP
foreach(Player in Players)
{
	if(Player.Score.RoundPoints > BestRoundScore && Player.Score.RoundPoints > 0)
	{
		BestRoundScore = Player.Score.RoundPoints;
		MVP = Player;
	}	
}
if(MVP != Null && RoundClanWinner != 0)
{
	declare CurrentMVP for MVP.Score = 0;
	CurrentMVP += 1;
	ST2::SetColValue("ST_MVP", MVP.Score, "$fc0"^TextLib::ToText(CurrentMVP));
}	
Sound::PlaySound("file://Media/Sounds/FireFight/roundend.ogg", -5., 400);
MB_Sleep(1500);
SM::UnspawnAllPlayers();
MB_Sleep(1000);
UIManager.UIAll.UISequence = CUIConfig::EUISequence::EndRound;
UIManager.UIAll.MarkersXML = "";
Victory::RoundEnd();
EndTime = -1;
if(RoundClanWinner > 0)
{
	G_ClansMapPoints[RoundClanWinner] += 1;
	foreach(Player in Players)
	{
		declare UI <=> UIManager.GetUI(Player);
		if(UI == Null) continue;
		declare netwrite Net_Cash for UI = C_StartCash;
		if(Player.CurrentClan == RoundClanWinner) Net_Cash += C_CashForWin;
		else if(Player.CurrentClan == 3-RoundClanWinner) Net_Cash += C_CashForLoss;
	}
}	
Message::CleanAllMessages();
Layers::Detach("Players");
Layers::Detach("HUD");
if(MB_SectionRoundNb % 3 == 0) DisplayNotice();
UpdateHeader(G_ClansMapPoints[1], G_ClansMapPoints[2]);
AnnounceRoundWin(RoundClanWinner);
UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::ForcedVisible;
MB_Sleep(4000);
Score::RoundEnd();
if(G_ClansMapPoints[1] >= G_MapPointsLimit)
{
	ClanMapWinner = 1;
	MB_StopMap = True;
}
else if(G_ClansMapPoints[2] >= G_MapPointsLimit)
{
	ClanMapWinner = 2;
	MB_StopMap = True;
}
MB_Sleep(4000);
UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::Normal;
Message::CleanAllMessages();
if(PlayersNbTotal < 2) WaitForPlayers();
//Switch the roles
G_AttackingClan = 3 - G_AttackingClan;
***

***EndMap***
***
/*foreach (Score in Scores) 
{
	declare PrevPoints for Score = 0;
	PrevPoints = Score.Points;
	declare CurrentMVP for Score = 0;
	Score.LadderMatchScoreValue = MathLib::ToReal(Score.Points + (CurrentMVP*2));
	// Winner
	if (Score.LadderClan == ClanMapWinner) {
		Score.Points = 4;
	}
	// Looser
	else if (Score.LadderClan == 3 - ClanMapWinner) {
		Score.Points = 2;
	}
	// Other
	else {
		Score.Points = 0;
		Score.LadderMatchScoreValue = 0.;
	}
}
Ladder_SetResultsVersion(1);
Score::MatchEnd(True);
foreach (Score in Scores) {
	declare PrevPoints for Score = 0;
	Score.Points = PrevPoints;
}*/

foreach (Player in Players) {
	if(Player.CurrentClan == ClanMapWinner && Player.Score != Null) {
		declare LadderBonus for Player.Score = 0;
		declare CurrentMVP for Player.Score = 0;
		LadderBonus += CurrentMVP*6;
	}
	else if(Player.CurrentClan != ClanMapWinner && Player.Score != Null) {
		declare LadderBonus for Player.Score = 0;
		declare CurrentMVP for Player.Score = 0;
		LadderBonus -= 30 - (CurrentMVP*3);
	}
}
foreach (Score in Scores) {
	declare LadderBonus for Score = 0;
	Score.Points += LadderBonus;
}
Score::MatchEnd();
foreach (Score in Scores) {
	declare LadderBonus for Score = 0;
	Score.Points -= LadderBonus;
	//Score.RoundPoints = LadderBonus;
}
Victory::MatchEnd();
Layers::Detach("Progression");
Message::SendStatusMessage(TextLib::Compose(_("Map result: %1 %2 - %3 %4"),Teams[0].ColorizedName,TextLib::ToText(G_ClansMapPoints[1]),TextLib::ToText(G_ClansMapPoints[2]),Teams[1].ColorizedName), 6000, 0, CUIConfig::EUISound::EndRound, 0);
if (ClanMapWinner > 0) Message::SendBigMessage(TextLib::Compose(_("%1 wins the map!"), Teams[ClanMapWinner - 1].ColorizedName), 6000, 0);
else Message::SendBigMessage(TextLib::Compose(_("|Match|Draw")), 6000, 0, CUIConfig::EUISound::Silence, 0);
UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::ForcedVisible;
UIManager.UIAll.UISequence = CUIConfig::EUISequence::Outro;
MB_Sleep(6000);
UIManager.UIAll.UISequence = CUIConfig::EUISequence::Podium;
MB_Sleep(6000);
UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::Normal;
Message::CleanAllMessages();
***

***EndServer***
***
Layers::Destroy("Progression");
Layers::Destroy("ProgressBar");
Layers::Destroy("RulesReminder");
Layers::Destroy("Players");
Layers::Destroy("Shop");
CustomUI::Unload();
Layers::Destroy("Markers");
SpawnScreen::DestroyRules();
***

Void InitGoals() 
{
	foreach (LandmarkGauge in MapLandmarks_Gauge) 
	{
		if(LandmarkGauge.Sector != Null)
		{
			if(LandmarkGauge.Tag == "Server A")
			{
				LandmarkGauge.Gauge.Max		= G_PoleCaptureDuration * 1000;
				LandmarkGauge.Gauge.Value	= 0;
				LandmarkGauge.Gauge.Speed	= 0;
				LandmarkGauge.Gauge.Clan 	= 0;
				LandmarkGauge.Gauge.Captured= False;
			}
			if(LandmarkGauge.Tag == "Server B")
			{
				LandmarkGauge.Gauge.Max		= G_PoleCaptureDuration * 1000;
				LandmarkGauge.Gauge.Value	= 0;
				LandmarkGauge.Gauge.Speed	= 0;
				LandmarkGauge.Gauge.Clan 	= 0;
				LandmarkGauge.Gauge.Captured= False;
			}
			if(LandmarkGauge.Tag == "Server C")
			{
				LandmarkGauge.Gauge.Max		= G_PoleCaptureDuration * 1000;
				LandmarkGauge.Gauge.Value	= 0;
				LandmarkGauge.Gauge.Speed	= 0;
				LandmarkGauge.Gauge.Clan 	= 0;
				LandmarkGauge.Gauge.Captured= False;
			}
		}	
	}
}

Void UpdateBasesColors() {
	foreach (Base in MapBases) {
		Base.Clan = 0;
		Base.IsActive = True;
	}
	
	declare UpdatedBases = Ident[];
	
	foreach (Spawn in MapLandmarks_PlayerSpawn) 
	{
		if (Spawn.Base == Null) continue;
		
		if(G_AttackingClan == 2)
		{
			switch(Spawn.Tag)
			{
				case "SpawnAttack": Spawn.Base.Clan = 2;
				case "SpawnDefence": Spawn.Base.Clan = 1;
			}	
		}
		else
		{
			switch(Spawn.Tag)
			{
				case "SpawnAttack": Spawn.Base.Clan = 1;
				case "SpawnDefence": Spawn.Base.Clan = 2;
			}
		}
		Spawn.Base.IsActive = True;
		UpdatedBases.add(Spawn.Base.Id);
	}
	
	foreach (Pole in MapLandmarks_Gauge)
	{
		if (Pole.Base != Null) {
			if (!UpdatedBases.exists(Pole.Base.Id)) {
				Pole.Base.Clan = 3-G_AttackingClan;
				UpdatedBases.add(Pole.Base.Id);
			} else if (Pole.Base.Clan != 3-G_AttackingClan) {
				Pole.Base.Clan = G_AttackingClan;
			}
		}
	}
}

Void SwitchWeapon(CSmPlayer _Player, CSmModeEvent::EActionInput _Input) {
	declare PrimaryWeapon for _Player = 1;
	declare SecondaryWeapon for _Player = 1;
	declare CurrentWeaponSlot for _Player = 2;
	
	switch (_Input) {
		// Primary weapon
		case CSmModeEvent::EActionInput::Activable1: 
		{
			switch(PrimaryWeapon)
			{
				case 1:
				{
					SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Laser, 1);
					SetPlayerWeapon(_Player, CSmMode::EWeapon::Laser, False);
					ActionLoad(_Player, CSmMode::EActionSlot::Slot_A, NullId);
					ActionBind(_Player, CSmMode::EActionSlot::Slot_A, CSmMode::EActionInput::None);
					ActionBind(_Player, CSmMode::EActionSlot::Slot_B, CSmMode::EActionInput::None);
					_Player.AmmoGain = 0.85;
				}
				case 2:
				{
					SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Laser, 0);
					SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Nucleus, 0);
					SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Arrow, 0);
					ActionLoad(_Player, CSmMode::EActionSlot::Slot_A, G_CustomPlasmaGun);
					ActionBind(_Player, CSmMode::EActionSlot::Slot_A, CSmMode::EActionInput::Weapon);
					_Player.AmmoGain = 1.;
				}
				case 3:
				{
					SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Laser, 0);
					SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Nucleus, 0);
					SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Arrow, 0);
					ActionLoad(_Player, CSmMode::EActionSlot::Slot_A, G_CustomGrenades);
					ActionBind(_Player, CSmMode::EActionSlot::Slot_A, CSmMode::EActionInput::Weapon);
					_Player.AmmoGain = 1.;
				}
				case 4:
				{
					SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Nucleus, 2);
					SetPlayerWeapon(_Player, CSmMode::EWeapon::Nucleus, False);
					ActionLoad(_Player, CSmMode::EActionSlot::Slot_A, NullId);
					ActionBind(_Player, CSmMode::EActionSlot::Slot_A, CSmMode::EActionInput::None);
					ActionBind(_Player, CSmMode::EActionSlot::Slot_B, CSmMode::EActionInput::None);
					_Player.AmmoGain = 0.65;
				}
				case 5:
				{
					SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Laser, 0);
					SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Nucleus, 0);
					SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Arrow, 0);
					ActionLoad(_Player, CSmMode::EActionSlot::Slot_A, G_CustomShotgun);
					ActionBind(_Player, CSmMode::EActionSlot::Slot_A, CSmMode::EActionInput::Weapon);
					_Player.AmmoGain = 1.;
				}
				case 6:
				{
					SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Laser, 0);
					SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Nucleus, 0);
					SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Arrow, 0);
					ActionLoad(_Player, CSmMode::EActionSlot::Slot_A, G_CustomBlowBomb);
					ActionBind(_Player, CSmMode::EActionSlot::Slot_A, CSmMode::EActionInput::Weapon);
					_Player.AmmoGain = 1.;
				}
				default:
				{
					switch(SecondaryWeapon)
					{
						case 1:
						{
							SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Rocket, C_RocketsAmmo);
							SetPlayerWeapon(_Player, CSmMode::EWeapon::Rocket, False);
							//ActionLoad(_Player, CSmMode::EActionSlot::Slot_A, NullId);
							ActionBind(_Player, CSmMode::EActionSlot::Slot_A, CSmMode::EActionInput::None);
							ActionBind(_Player, CSmMode::EActionSlot::Slot_B, CSmMode::EActionInput::None);
							_Player.AmmoGain = 1.;
						}
						case 2:
						{
							SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Rocket, 0);
							//ActionLoad(_Player, CSmMode::EActionSlot::Slot_A, NullId);
							ActionLoad(_Player, CSmMode::EActionSlot::Slot_B, G_CustomBounceRocket);
							ActionBind(_Player, CSmMode::EActionSlot::Slot_A, CSmMode::EActionInput::None);
							ActionBind(_Player, CSmMode::EActionSlot::Slot_B, CSmMode::EActionInput::Weapon);
							_Player.AmmoGain = 1.;
						}
						case 3:
						{
							SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Rocket, 0);
							//ActionLoad(_Player, CSmMode::EActionSlot::Slot_A, NullId);
							ActionLoad(_Player, CSmMode::EActionSlot::Slot_B, G_CustomElectricPistol);
							ActionBind(_Player, CSmMode::EActionSlot::Slot_A, CSmMode::EActionInput::None);
							ActionBind(_Player, CSmMode::EActionSlot::Slot_B, CSmMode::EActionInput::Weapon);
							_Player.AmmoGain = 1.;
						}
					}	
				}
			}
			CurrentWeaponSlot = 1;
		}
		// Secondary weapon
		case CSmModeEvent::EActionInput::Activable2: 
		{
			switch(SecondaryWeapon)
			{
				case 1:
				{
					SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Rocket, C_RocketsAmmo);
					SetPlayerWeapon(_Player, CSmMode::EWeapon::Rocket, False);
					//SetPlayerAmmo(_Player, CSmMode::EWeapon::Laser, 0);
					//SetPlayerAmmo(_Player, CSmMode::EWeapon::Nucleus, 0);
					//ActionLoad(_Player, CSmMode::EActionSlot::Slot_A, NullId);
					ActionBind(_Player, CSmMode::EActionSlot::Slot_A, CSmMode::EActionInput::None);
					ActionBind(_Player, CSmMode::EActionSlot::Slot_B, CSmMode::EActionInput::None);
					_Player.AmmoGain = 1.;
				}
				case 2:
				{
					SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Rocket, 0);
					//SetPlayerAmmo(_Player, CSmMode::EWeapon::Laser, 0);
					//SetPlayerAmmo(_Player, CSmMode::EWeapon::Nucleus, 0);
					SetPlayerWeapon(_Player, CSmMode::EWeapon::Rocket, False);
					//ActionLoad(_Player, CSmMode::EActionSlot::Slot_A, NullId);
					ActionLoad(_Player, CSmMode::EActionSlot::Slot_B, G_CustomBounceRocket);
					ActionBind(_Player, CSmMode::EActionSlot::Slot_A, CSmMode::EActionInput::None);
					ActionBind(_Player, CSmMode::EActionSlot::Slot_B, CSmMode::EActionInput::Weapon);
					_Player.AmmoGain = 1.;
				}
				case 3:
				{
					SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Rocket, 0);
					//SetPlayerAmmo(_Player, CSmMode::EWeapon::Laser, 0);
					//SetPlayerAmmo(_Player, CSmMode::EWeapon::Nucleus, 0);
					SetPlayerWeapon(_Player, CSmMode::EWeapon::Rocket, False);
					//ActionLoad(_Player, CSmMode::EActionSlot::Slot_A, NullId);
					ActionLoad(_Player, CSmMode::EActionSlot::Slot_B, G_CustomElectricPistol);
					ActionBind(_Player, CSmMode::EActionSlot::Slot_A, CSmMode::EActionInput::None);
					ActionBind(_Player, CSmMode::EActionSlot::Slot_B, CSmMode::EActionInput::Weapon);
					_Player.AmmoGain = 1.;
				}
			}	
			CurrentWeaponSlot = 2;
		}
	}
}

Void DisplayNotice()
{
	foreach (Player in Players) 
	{
		declare UI <=> UIManager.GetUI(Player);
		if (UI == Null) continue;
		declare rand = MathLib::Rand(1,6);
		
		declare Text[Integer] MSG;
		declare Prefix = "$f90$s>>";
		switch(Player.User.Language)
		{
			case "pl":
			{
				MSG[1] = "Śledź maniaflash $h[maniaflash?firefight]firefight$h by uzyskać informacje o aktualizacjach";
				MSG[2] = "Tryb został stworzony przez ToRRent'a";
				MSG[3] = "Wciśnij F8 by zmodyfikować interfejs";
				MSG[4] = "Zdobywaj strefy terytorialne by odrodzić drużynę i się uleczyć";
				MSG[5] = "Jeżeli masz sugestie co do rozwoju trybu, napisz $l[http://forum.maniaplanet.com/viewtopic.php?f=10&t=28177&start=0]tutaj$l";
				MSG[6] = "Zbierz przedmiot znajdujący się na mapie by zdobyć broń główną.";
				MSG[7] = "Naciśnij M by zobaczyć/schwoać mapę pełnoekranową";
			}
			case "fr": 
			{
				MSG[1] = "Abonne-toi au Maniaflash $h[maniaflash?firefight]firefight$h pour avoir les informations concernant les mises-à-jour et les rendez-vous";
				MSG[2] = "Mode de jeu créé par ToRRent";
				MSG[3] = "Appuie sur F8 pour personnaliser l'interface";
				MSG[4] = "Capture les objectifs pour ranimer tes coéquipiers et te soigner";
				MSG[5] = "Pour toute suggestion concernant le mode de jeu, merci d'aller $l[http://forum.maniaplanet.com/viewtopic.php?f=10&t=28177&start=0]ici$l";
				MSG[6] = "Collect weapon item located on map to get primary weapon.";
				MSG[7] = "Appuie sur M pour montrer/cacher la mini-map en plein écran";
			}
			case "it": 
			{
				MSG[1] = "Segui maniaflash $h[maniaflash?firefight]firefight$h per ot tenere le informazioni sul tema di aggiornamenti e riunioni";
				MSG[2] = "Il modo è stato creato grazie a ToRRent'a";
				MSG[3] = "Digiti F8 per modificare l’interfaccia";
				MSG[4] = "catturi le zone territoriali per rinascere la squadra e curarsi";
				MSG[5] = "Se hai suggestioni rispetti allo sviluppo del modo, scrivi $l[http://forum.maniaplanet.com/viewtopic.php?f=10&t=28177&start=0]qui$l";
				MSG[6] = "Collect weapon item located on map to get primary weapon.";
				MSG[7] = "Digiti M per vedere/nascondere la mappa su tutto lo schermo";
			}
			case "de": 
			{
				MSG[1] = "Abonniere den ManiaFlash $h[maniaflash?firefight]firefight$h um Informationen über Aktualisierungen und Treffen zu erhalten";
				MSG[2] = "Spielmodus erstellt durch ToRRent";
				MSG[3] = "Drücke F8 um die Oberfläche anzupassen";
				MSG[4] = "Erobere Ziele um Teamkameraden zu erlösen und sich selbst zu heilen";
				MSG[5] = "Verbesserungsvorschläge bitte $l[http://forum.maniaplanet.com/viewtopic.php?f=10&t=28177&start=0]hier$l";
				MSG[6] = "Collect weapon item located on map to get primary weapon.";
				MSG[7] = "Minimaps anzeigen/verbergen durch Drücken von M im Vollbildmodus";
			}
			default:
			{
				MSG[1] = "Follow maniaflash $h[maniaflash?firefight]firefight$h to get informations about updates and meetings";
				MSG[2] = "Game mode was created by ToRRent";
				MSG[3] = "Press F8 to customize interface";
				MSG[4] = "Capture objectives to revive teammates and heal yourself.";
				MSG[5] = "If you have suggestion about gamemode, go $l[http://forum.maniaplanet.com/viewtopic.php?f=10&t=28177&start=0]here$l";
				MSG[6] = "Collect weapon item located on map to get primary weapon.";
				MSG[7] = "Press M to show/hide full screen map";
			}
		}

		switch(rand)
		{
			case 1: UI.SendChat(Prefix^MSG[1]);
			case 2: UI.SendChat(Prefix^MSG[2]);
			case 3: UI.SendChat(Prefix^MSG[3]);
			case 4: UI.SendChat(Prefix^MSG[4]);
			case 5: UI.SendChat(Prefix^MSG[5]);
			case 6: UI.SendChat(Prefix^MSG[6]);
		}
	}	
}

Text UpdateLayerHUD()
{
	return """
<frame hidden="1" id="Frame_Overlay">
	<label posn="-65 -70 1" text="1: -" textsize="1" halign="left" id="Label_Primary"/>
	<label posn="-65 -74 1" text="2: -" textsize="1" halign="left" id="Label_Secondary"/>
	<label posn="45 -68 1" text="0 $9f0$$" textsize="4" halign="left" id="Label_Cash"/>
</frame>
<script><!--	
main()
{
	declare Frame_Overlay <=> (Page.GetFirstChild("Frame_Overlay") as CMlFrame);
	declare Label_Primary <=> (Page.GetFirstChild("Label_Primary") as CMlLabel);
	declare Label_Secondary <=> (Page.GetFirstChild("Label_Secondary") as CMlLabel);
	declare Label_Cash <=> (Page.GetFirstChild("Label_Cash") as CMlLabel);
	while(True)
	{
		yield;
		if(InputPlayer == Null) continue;
		if(InputPlayer.Armor > 0)
		{
			Frame_Overlay.Visible = True;
			declare netread Net_Cash for UI = {{{C_StartCash}}};
			Label_Cash.Value = Net_Cash^" $9f0$$";
			declare netread Net_PrimaryWeapon for UI = 0;
			switch(Net_PrimaryWeapon)
			{
				case 1: Label_Primary.Value = "1: Laser";
				case 2: Label_Primary.Value = "1: Plasma Gun";
				case 3: Label_Primary.Value = "1: Grenades";
				case 4: Label_Primary.Value = "1: Nucleus";
				case 5: Label_Primary.Value = "1: Shotgun";
				case 6: Label_Primary.Value = "1: BlowBomb";
				default: Label_Primary.Value = "1: -";
			}
			declare netread Integer[Text] Net_SecondaryWeapons for UI;
			if(Net_SecondaryWeapons.existskey(InputPlayer.Login))
			{
				switch(Net_SecondaryWeapons[InputPlayer.Login])
				{
					case 1: Label_Secondary.Value = "2: Rockets";
					case 2: Label_Secondary.Value = "2: Bouncing Rockets";
					case 3: Label_Secondary.Value = "2: Electric Pistol";
					default: Label_Secondary.Value = "2: -";
				}
			}
			else Label_Secondary.Value = "2: -";
		}
		else Frame_Overlay.Visible = False;		
	}
}
--></script>
	""";
}

Void UpdateMarker()
{
	UIManager.UIAll.MarkersXML = "";
	foreach(Player in Players)
	{
		declare UI <=> UIManager.GetUI(Player);
		if (UI == Null) continue;
		declare PlayerManialink for Player = "";
		PlayerManialink = "";

		foreach (Goal in MapLandmarks_Gauge) 
		{
			declare PosX = Goal.Position.X;
			declare PosY = Goal.Position.Y + 0.3;
			declare PosZ = Goal.Position.Z;
			if (Goal.Tag == "Server A") 
			{
				if(Player.CurrentClan == G_AttackingClan) PlayerManialink ^= """<marker label="$oA" pos="{{{PosX}}} {{{PosY}}} {{{PosZ}}}" hudvisibility="Always" />""";
				else if(G_Capturable == 1) PlayerManialink ^= """<marker label="$oA $z- $f30Vulnerable" pos="{{{PosX}}} {{{PosY}}} {{{PosZ}}}" hudvisibility="Always" />""";
				else PlayerManialink ^= """<marker label="$oA $z- $9f0Safe" pos="{{{PosX}}} {{{PosY}}} {{{PosZ}}}" hudvisibility="Always" />""";
			} 
			else if (Goal.Tag == "Server B") 
			{
				if(Player.CurrentClan == G_AttackingClan) PlayerManialink ^= """<marker label="$oB" pos="{{{PosX}}} {{{PosY}}} {{{PosZ}}}" hudvisibility="Always" />""";
				else if(G_Capturable == 2) PlayerManialink ^= """<marker label="$oB $z- $f30Vulnerable" pos="{{{PosX}}} {{{PosY}}} {{{PosZ}}}" hudvisibility="Always" />""";
				else PlayerManialink ^= """<marker label="$oB $z- $9f0Safe" pos="{{{PosX}}} {{{PosY}}} {{{PosZ}}}" hudvisibility="Always" />""";
			}
			else if (Goal.Tag == "Server C") 
			{
				if(Player.CurrentClan == G_AttackingClan) PlayerManialink ^= """<marker label="$oC" pos="{{{PosX}}} {{{PosY}}} {{{PosZ}}}" hudvisibility="Always" />""";
				else if(G_Capturable == 3) PlayerManialink ^= """<marker label="$oC $z- $f30Vulnerable" pos="{{{PosX}}} {{{PosY}}} {{{PosZ}}}" hudvisibility="Always" />""";
				else PlayerManialink ^= """<marker label="$oC $z- $9f0Safe" pos="{{{PosX}}} {{{PosY}}} {{{PosZ}}}" hudvisibility="Always" />""";
			}
		}

		UI.MarkersXML = PlayerManialink;
	}	
}

Text UpdateLayerRulesReminder() {
	declare Text HighlightColor		= "f90";
	
	declare Text TitleText 			= TextLib::Compose(_("Welcome to %1!"), "Overload");
	
	return """
<dico>
   <language id="en">
    	<rule1>- Map contain 3 access points, only one is vulnerable.</rule1>
    	<rule2>$f70Attackers:$g Locate vulnerable point and capture to do overload.</rule2>
    	<rule3>$f70Defenders:$g Protect vulnerable point to end of the round.</rule3>
    	<rule4>- Before round, you can buy equipment in the shop.</rule4>
   </language>
   <language id="pl">
    	<rule1>- Mapa zawiera 3 punkty dostępu, tylko jeden jest podatny na atak.(vulnerable)</rule1>
    	<rule2>$f70Atakujący:$g Znajdź punkt podatny na atak i go zdobądź.</rule2>
    	<rule3>$f70Obrońcy:$g Chroń podatny na ataki punkt do końca trwania rundy</rule3>
    	<rule4>- Przed rozpoczęciem rundy, możesz kupić ekwipunek w sklepie</rule4>
   </language>
</dico>
<frame id="RulesReminderMainFrame" hidden="true" posn="0 13 100" >
	<quad posn="0 25 0" sizen="162 70" bgcolor="FFFA" image="{{{C_ImgModeDir}}}/WelcomeBg.dds" halign="center" valign="center"/>
	<label posn="-71 46 1" sizen="86 5" text="{{{TitleText}}}" textsize="4" textcolor="{{{HighlightColor}}}" style="TextValueSmallSm"/>
	<label posn="-73 39 1" sizen="146 26" textid="rule1"/>
	<label posn="-73 33 1" sizen="146 26" textid="rule2"/>
	<label posn="-73 27 1" sizen="146 26" textid="rule3"/>
	<label posn="-73 21 1" sizen="146 26" textid="rule4"/>
	<label posn="0 12 1" halign="center" text="{{{TextLib::Compose(_("Press '$<%1F1$>' to close this window."), "$"^HighlightColor)}}}" textsize="3" />
</frame>
<script><!--
	while(InputPlayer == Null) yield;
	
	if(InputPlayer.User.LadderPoints > 3000) {
		return;
	}

	declare RulesReminderMainFrame 	<=> (Page.GetFirstChild("RulesReminderMainFrame") as CMlFrame);
	
	while(True) {
		yield;
		
		RulesReminderMainFrame.Show();
		
		foreach(Event in PendingEvents) {
			switch(Event.Type){
				case CMlEvent::Type::KeyPress: {
					if(Event.CharPressed == "2424832" ) { // F1
						RulesReminderMainFrame.Visible = !RulesReminderMainFrame.Visible;
						return; // End of this behavior
					}
				}
			}
		}
	}
--></script>""";
}

// Build capture progress layer
Text UpdateLayerProgressBar()
{
	declare Text ML = "";
	ML = """
<manialink version="1" name="Strike:Real-Time Progress Bar">
<dico>
   <language id="en">
      <label0>Loading data...</label0>
      <label1>Hacking...</label1>
      <label2>Wrong point, check another one.</label2>
      <label3>It's safe, protect vulnerable access point.</label3>
	  <label4>Protect this access point.</label4>
   </language>
   <language id="pl">
      <label0>Ładowanie...</label0>
      <label1>Hakowanie...</label1>
      <label2>Zły punkt, znajdź podatny na atak.</label2>
      <label3>Ten punkt jest bezpieczny, chroń punkt podatny na ataki.</label3>
	  <label4>Protect this access point.</label4>
   </language>
</dico>
	<frame class="LibCustomUI_Module" id="FireFight_GaugeCapture">
		<frame posn="0 -46" id="Frame_Capture">
			<quad posn="0 0 2" sizen="128 20" halign="center" valign="center" image="{{{C_ImgModeDir}}}/Structure.dds" />
			<label posn="0 -2.5 3" halign="center" textsize="3" textemboss="1" textprefix="$bbb" textid="label0" id="Label_Goal" style="TextButtonBig"/>
			<label posn="0 13 3" halign="center" textsize="3" textemboss="1" style="TextCreditsTitle" textid="label1" hidden="1" textprefix="$o" id="Label_Info_1"/>
			<label posn="0 13 3" halign="center" textsize="3" textemboss="1" style="TextCreditsTitle" textid="label2" hidden="1" textprefix="$o" id="Label_Info_2"/>
			<label posn="0 13 3" halign="center" textsize="3" textemboss="1" style="TextCreditsTitle" textid="label3" hidden="1" textprefix="$o" id="Label_Info_3"/>
			<label posn="0 13 3" halign="center" textsize="3" textemboss="1" style="TextCreditsTitle" textid="label4" hidden="1" textprefix="$o" id="Label_Info_4"/>
			<gauge posn="0 8 2" sizen="124 10.4" halign="center" style="EnergyBar" drawbg="1" drawblockbg="1" id="Gauge_Capture" />
		</frame>
	</frame>	
<script><!--
#Include "MathLib" as ML
main() 
{
	declare Frame_Capture 	<=> (Page.GetFirstChild("Frame_Capture") 	as CMlFrame);
	declare Label_Capture 	<=> (Page.GetFirstChild("Label_Capture") 	as CMlLabel);
	declare Label_Info_1	<=> (Page.GetFirstChild("Label_Info_1")		as CMlLabel);
	declare Label_Info_2	<=> (Page.GetFirstChild("Label_Info_2")		as CMlLabel);
	declare Label_Info_3	<=> (Page.GetFirstChild("Label_Info_3")		as CMlLabel);
	declare Label_Info_4	<=> (Page.GetFirstChild("Label_Info_4")		as CMlLabel);
	declare Label_Goal 		<=> (Page.GetFirstChild("Label_Goal") 		as CMlLabel);
	declare Gauge_Capture 	<=> (Page.GetFirstChild("Gauge_Capture") 	as CMlGauge);
	{{{CustomUI::InjectMLInit()}}}
	while (True) 
	{
		yield;
		if (InputPlayer == Null) continue;
		if (!PageIsVisible) continue;
		
		{{{CustomUI::InjectMLLoop()}}}
		
		declare CSmPlayer TargetPlayer;
		if (GUIPlayer != Null) TargetPlayer <=> GUIPlayer;
		else TargetPlayer <=> InputPlayer;

		Label_Info_1.Hide();
		Label_Info_2.Hide();
		Label_Info_3.Hide();	
		Label_Info_4.Hide();
		
		if (TargetPlayer.SpawnStatus == CSmPlayer::ESpawnStatus::Spawned && TargetPlayer.CapturedLandmark != Null && TargetPlayer.CapturedLandmark.Gauge != Null && (TargetPlayer.CapturedLandmark.Tag == "Server A" || TargetPlayer.CapturedLandmark.Tag == "Server B" || TargetPlayer.CapturedLandmark.Tag == "Server C")) 
		{
			if (!Frame_Capture.Visible) Frame_Capture.Visible = True;
			Gauge_Capture.Ratio = TargetPlayer.CapturedLandmark.Gauge.ValueReal;
			Gauge_Capture.Clan = TargetPlayer.CurrentClan;
			Label_Goal.Value = "$dda"^ML::FloorInteger(TargetPlayer.CapturedLandmark.Gauge.ValueReal * 100.)^"%";
			if(TargetPlayer.CapturedLandmark.Gauge.Speed == 0)
			{
				if(TargetPlayer.CurrentClan != {{{G_AttackingClan}}})
				{
					switch(TargetPlayer.CapturedLandmark.Tag)
					{
						case "Server A":
						{
							if({{{G_Capturable}}} == 1)
							{
								Label_Info_1.Hide();
								Label_Info_2.Hide();
								Label_Info_3.Hide();		
								Label_Info_4.Show();
							}
							else
							{
								Label_Info_1.Hide();
								Label_Info_2.Hide();
								Label_Info_3.Show();		
								Label_Info_4.Hide();
							}
						}
						case "Server B":
						{
							if({{{G_Capturable}}} == 2)
							{
								Label_Info_1.Hide();
								Label_Info_2.Hide();
								Label_Info_3.Hide();		
								Label_Info_4.Show();
							}
							else
							{
								Label_Info_1.Hide();
								Label_Info_2.Hide();
								Label_Info_3.Show();		
								Label_Info_4.Hide();
							}
						}
						case "Server C":
						{
							if({{{G_Capturable}}} == 3)
							{
								Label_Info_1.Hide();
								Label_Info_2.Hide();
								Label_Info_3.Hide();		
								Label_Info_4.Show();
							}
							else
							{
								Label_Info_1.Hide();
								Label_Info_2.Hide();
								Label_Info_3.Show();		
								Label_Info_4.Hide();
							}
						}
					}
				}	
				else
				{
					Label_Info_1.Hide();
					Label_Info_2.Show();
					Label_Info_3.Hide();		
					Label_Info_4.Hide();
				}
			}
			else if(TargetPlayer.CapturedLandmark.Gauge.Speed > 1)
			{
				Label_Info_1.Show();
				Label_Info_2.Hide();
				Label_Info_3.Hide();		
				Label_Info_4.Hide();
			}

		} 
		else if (Frame_Capture.Visible) 
		{
			Frame_Capture.Visible = False;
		}
	}
}
--></script>
</manialink>	
""";
	
	return ML;	
}	

// Update the layer with alive players
Text UpdateLayerPlayers()
{
	declare Panels = [1 => "", 2 => ""];
	declare Text ArmorImage = C_ImgBaseDir^"ShieldWhite.dds";
	declare Clan1Color 	= Teams[0].ColorPrimary.X^" "^Teams[0].ColorPrimary.Y^" "^Teams[0].ColorPrimary.Z;
	declare Clan2Color 	= Teams[1].ColorPrimary.X^" "^Teams[1].ColorPrimary.Y^" "^Teams[1].ColorPrimary.Z;
	
	declare ModelArmorsLeft = """
<framemodel id="Framemodel_ArmorsLeft">
	<gauge posn="-4 6. 2" sizen="40 16" drawbg="0" color="0007" ratio="0.989" drawblockbg="0" />
	<gauge posn="-4 6. 1" sizen="40 16" drawbg="0" drawblockbg="0" color="{{{Clan1Color}}}F" id="Gauge_Armor" />
	<quad posn="0 -2 3" sizen="4 4" bgcolor="FFFA" halign="left" valign="center" id="Quad_Avatar" />
	<label posn="5 -0.5 3" sizen="21 6" scale="0.9" id="Label_Pseudo" />
	<label posn="29 -0.5 3" sizen="3 6" style="TextRaceChrono" textsize="2" id="Label_Armors" />
	<quad posn="33 -2.5 3" sizen="5.1 5.1" halign="left" valign="center" id="Quad_SecondaryWeapon" />
	<quad posn="37.2 -2.5 3" sizen="5.1 5.1" halign="left" valign="center" id="Quad_PrimaryWeapon" />
</framemodel>""";
	
	declare ModelArmorsRight = """
<framemodel id="Framemodel_ArmorsRight">
	<gauge posn="4 6. 2" sizen="40 16" halign="right" drawbg="0" color="0007" ratio="0.989" drawblockbg="0" />
	<gauge posn="4 6. 1" sizen="40 16" halign="right" drawbg="0" drawblockbg="0" color="{{{Clan2Color}}}F" id="Gauge_Armor" />
	<quad posn="0 -2 3" sizen="4 4" bgcolor="FFFA" halign="right" valign="center" id="Quad_Avatar" />
	<label posn="-5 -0.5 3" sizen="21 6" halign="right" scale="0.9" id="Label_Pseudo" />
	<label posn="-29 -0.5 3" sizen="3 6" halign="right" style="TextRaceChrono" textsize="2" id="Label_Armors" />
	<quad posn="-33 -2.5 3" sizen="5.1 5.1" halign="right" valign="center" id="Quad_SecondaryWeapon" />
	<quad posn="-37.2 -2.5 3" sizen="5.1 5.1" halign="right" valign="center" id="Quad_PrimaryWeapon" />
</framemodel>""";
	
	
	for (I, 0, 9) {
		Panels[1] ^= """<frameinstance posn="0 {{{-I*5.1}}}" modelid="Framemodel_ArmorsLeft" id="Frame_PlayerArmors_{{{I+1}}}" />""";
		Panels[2] ^= """<frameinstance posn="0 {{{-I*5.1}}}" modelid="Framemodel_ArmorsRight" id="Frame_PlayerArmors_{{{I+1}}}" />""";
	}
	
	declare Team1Name 	= Teams[0].ColorizedName;
	declare Team2Name 	= Teams[1].ColorizedName;
	
	return """
{{{ModelArmorsLeft}}}
{{{ModelArmorsRight}}}
<frame class="LibCustomUI_Module" id="Overload_PlayersList_1">
<frame posn="-161 70 2" id="Frame_PanelLeft">
	<format textemboss="1" textsize="2" />
	<frame posn="2 -7 1" id="Frame_PlayersList">
		{{{Panels[1]}}}
	</frame>
	<quad posn="-3 -2 0" sizen="44 5.5" style="EnergyBar" substyle="BgText"/>
	<label posn="4 -3" sizen="25 16" text="{{{Team1Name}}}" />
	<quad posn="30.5 -3 3" sizen="3 3" image="{{{ArmorImage}}}" />
	<label posn="35 -3 3" style="TextRaceChrono" textsize="2" id="Label_ArmorsLeft" />
</frame>
</frame>
<frame class="LibCustomUI_Module" id="Overload_PlayersList_2">
<frame posn="160 70 2" halign="right" id="Frame_PanelRight">
	<format textemboss="1" textsize="2" />
	<frame posn="-2 -7 1" halign="right" id="Frame_PlayersList">
		{{{Panels[2]}}}
	</frame>
	<quad posn="3 -2 0" halign="right" sizen="44 5.5" style="EnergyBar" substyle="BgText"/>
	<label posn="-4 -3" halign="right" sizen="25 16" text="{{{Team2Name}}}" />
	<quad posn="-30.5 -3 3" halign="right" sizen="3 3" image="{{{ArmorImage}}}" />
	<label posn="-35 -3 3" halign="right" style="TextRaceChrono" textsize="2" id="Label_ArmorsLeft" />
</frame>
</frame>
<script><!--
#Include "TextLib" as TL
#Include "MathLib" as ML

declare CMlFrame[Integer] Frames_Panel;
declare CMlFrame[Integer] Frames_PlayersList;
declare CMlLabel[Integer] Labels_ArmorsLeft;

Void UpdatePlayersList() {
	declare ClanPlayersArmors = [1 => Integer[Ident], 2 => Integer[Ident]];
	declare TotalArmors = [1 => 0, 2 => 0];
	
	foreach (Player in Players) {
		if (Player.Armor <= 0) continue;
		declare PArmor = 0;
		if(Player.Armor < 100) PArmor = 100;
		else PArmor = Player.Armor;
		if (!ClanPlayersArmors.existskey(Player.CurrentClan)) continue;
		ClanPlayersArmors[Player.CurrentClan][Player.Id] = PArmor;
		TotalArmors[Player.CurrentClan] += PArmor / 100;
	}
	
	ClanPlayersArmors[1] = ClanPlayersArmors[1].sort();
	ClanPlayersArmors[2] = ClanPlayersArmors[2].sort();
	
	for (ClanNb, 1, 2) {
		declare I = 1;
		declare PlayersArmors = ClanPlayersArmors[ClanNb];
		foreach (PlayerId => PlayerArmor in PlayersArmors) {
			if (!Players.existskey(PlayerId)) continue;
			declare Player <=> Players[PlayerId];
			declare Frame_PlayerArmors <=> (Frames_PlayersList[ClanNb].GetFirstChild("Frame_PlayerArmors_"^I) as CMlFrame);
			I += 1;
			if (Frame_PlayerArmors == Null) continue;
			if (Frame_PlayerArmors != Null && !Frame_PlayerArmors.Visible) Frame_PlayerArmors.Visible = True;
			declare Gauge_Armor <=> (Frame_PlayerArmors.GetFirstChild("Gauge_Armor") as CMlGauge);
			declare Quad_Avatar <=> (Frame_PlayerArmors.GetFirstChild("Quad_Avatar") as CMlQuad);
			declare Label_Pseudo <=> (Frame_PlayerArmors.GetFirstChild("Label_Pseudo") as CMlLabel);
			declare Label_Armors <=> (Frame_PlayerArmors.GetFirstChild("Label_Armors") as CMlLabel);
			declare Quad_SecondaryWeapon <=> (Frame_PlayerArmors.GetFirstChild("Quad_SecondaryWeapon") as CMlQuad);
			declare Quad_PrimaryWeapon <=> (Frame_PlayerArmors.GetFirstChild("Quad_PrimaryWeapon") as CMlQuad);
			
			declare PArmor = 0;
			if(Player.Armor < 100) PArmor = 100;
			else PArmor = Player.Armor;
			if (Player.ArmorMax > 0) 
			{
				declare Ratio = ML::ToReal(PArmor) / ML::ToReal(Player.ArmorMax);
				if (Ratio >= 1.) Ratio = 0.989; ///< Avoid the bright white in the bar when ratio = 1.
				Gauge_Armor.SetRatio(Ratio);
			}
			else
				Gauge_Armor.SetRatio(0.);
			Quad_Avatar.ChangeImageUrl("file://Avatars/"^Player.Login^"/Default");
			Label_Pseudo.Value = Player.Name;
			Label_Armors.Value = TL::ToText(PArmor/100);

			declare netread Integer[Text] Net_SecondaryWeapons for UI;	
			if(Net_SecondaryWeapons.existskey(Player.Login))
			{
				switch(Net_SecondaryWeapons[Player.Login])
				{
					case 1: Quad_SecondaryWeapon.ChangeImageUrl("{{{C_ImgModeDir}}}/IconWeaponRocket.dds");
					case 2: Quad_SecondaryWeapon.ChangeImageUrl("{{{C_ImgModeDir}}}/IconWeaponBRocket.dds");
					case 3: Quad_SecondaryWeapon.ChangeImageUrl("{{{C_ImgModeDir}}}/IconWeaponElectricPistol.dds");
					default: Quad_SecondaryWeapon.ChangeImageUrl("{{{C_ImgModeDir}}}/IconWeaponRocket.dds");
				}	
			}
			else Quad_SecondaryWeapon.ChangeImageUrl("{{{C_ImgModeDir}}}/IconWeaponRocket.dds");

			declare netread Integer[Text] Net_PrimaryWeapons for UI;	
			if(Net_PrimaryWeapons.existskey(Player.Login))
			{
				switch(Net_PrimaryWeapons[Player.Login])
				{
					case 1: Quad_PrimaryWeapon.ChangeImageUrl("{{{C_ImgModeDir}}}/IconWeaponLaser.dds");
					case 2: Quad_PrimaryWeapon.ChangeImageUrl("{{{C_ImgModeDir}}}/IconWeaponPlasmaGun.dds");
					case 3: Quad_PrimaryWeapon.ChangeImageUrl("{{{C_ImgModeDir}}}/IconWeaponGrenades.dds");
					case 4: Quad_PrimaryWeapon.ChangeImageUrl("{{{C_ImgModeDir}}}/IconWeaponNucleus.dds");
					case 5: Quad_PrimaryWeapon.ChangeImageUrl("{{{C_ImgModeDir}}}/IconWeaponShotgun.dds");
					case 6: Quad_PrimaryWeapon.ChangeImageUrl("{{{C_ImgModeDir}}}/IconWeaponBlowBomb.dds");
					default: Quad_PrimaryWeapon.ChangeImageUrl("");
				}	
			}
			else Quad_PrimaryWeapon.ChangeImageUrl("");
		}
		for (J, I, Frames_PlayersList[ClanNb].Controls.count) {
			declare Frame_PlayerArmors <=> (Frames_PlayersList[ClanNb].GetFirstChild("Frame_PlayerArmors_"^J) as CMlFrame);
			if (Frame_PlayerArmors != Null && Frame_PlayerArmors.Visible) Frame_PlayerArmors.Visible = False;
		}
		
		if (TotalArmors[ClanNb] > 0) {
			if (!Labels_ArmorsLeft[ClanNb].Visible) Labels_ArmorsLeft[ClanNb].Visible = True;
			Labels_ArmorsLeft[ClanNb].Value = TL::ToText(TotalArmors[ClanNb]);
		} else {
			if (Labels_ArmorsLeft[ClanNb].Visible) Labels_ArmorsLeft[ClanNb].Visible = False;
		}
	}
	
}

main() {
	Frames_Panel[1] <=> (Page.GetFirstChild("Frame_PanelLeft") as CMlFrame);
	Frames_Panel[2] <=> (Page.GetFirstChild("Frame_PanelRight") as CMlFrame);
	for (I, 1, 2) {
		Frames_PlayersList[I]	<=> (Frames_Panel[I].GetFirstChild("Frame_PlayersList") as CMlFrame);
		Labels_ArmorsLeft[I]	<=> (Frames_Panel[I].GetFirstChild("Label_ArmorsLeft")	as CMlLabel);
	}
	
	foreach (Player in Players) {
		declare PrevArmor for Player = -1;
		PrevArmor = -1;
	}
	{{{CustomUI::InjectMLInit()}}}
	
	while (True) {
		sleep(750);
		
		if (!PageIsVisible || InputPlayer == Null) continue;
		
		{{{CustomUI::InjectMLLoop()}}}
		UpdatePlayersList();
	}
}
--></script>""";
}

Void EnableBuyZone(Integer _TimeToChoose) 
{
	declare Boolean CountdownPlayed = False;
	declare PreRoundEndTime = Now + _TimeToChoose;
	UIManager.UIAll.CountdownEndTime = PreRoundEndTime;
	foreach (Player in Players)
	{
		declare UI <=> UIManager.GetUI(Player);
		if (UI == Null) continue;
		declare netwrite Net_ShopBill for UI = 0;
		Net_ShopBill = 0;
		Layers::Attach("Shop", Player);
	}	

	while (PreRoundEndTime > Now && !ServerShutdownRequested && !MatchEndRequested) 
	{
		MB_Sleep(500);

		if(PreRoundEndTime-1000 < Now && !CountdownPlayed)
		{
			Sound::PlaySound("file://Media/Sounds/FireFight/countdown.ogg", -5., 0);
			CountdownPlayed = True;	
		}
		foreach (Player in Players) 
		{
			if(Player.IsFakePlayer) G_SecondaryWeapons[Player.Login] = 1;
			declare UI <=> UIManager.GetUI(Player);
			if (UI == Null) continue;
			// If the player changed clan during the class selection
			if (Player.RequestedClan != Player.CurrentClan) 
			{
				Layers::Detach("Shop", Player);
				SetPlayerClan(Player, Player.RequestedClan);
				Layers::Attach("Shop", Player);
			}
			/*declare SecondaryWeapon for Player = 1;
			G_SecondaryWeapons[Player.Login] = SecondaryWeapon;*/
		}
	}	
	
	foreach (Player in Players) 
	{
		declare UI <=> UIManager.GetUI(Player);
		if (UI == Null) continue;
		declare netwrite Integer[Text] Net_SecondaryWeapons for UI;
		Net_SecondaryWeapons = G_SecondaryWeapons;
		Layers::Detach("Shop", Player);
		declare netwrite Net_Cash for UI = C_StartCash;
		declare netread Net_ShopBill for UI = C_StartCash;
		Net_Cash -= Net_ShopBill;
	}	
	
Layers::Update("HUD", UpdateLayerHUD());
MB_Sleep(2000);
}

Void WaitForPlayers() 
{
	UIManager.UIAll.UISequence = CUIConfig::EUISequence::Playing;
	
	UIManager.UIAll.BigMessageSound = CUIConfig::EUISound::Warning;
	StartTime = Now;
	
	// Shutdown the poles during warmup
	foreach (Goal in MapLandmarks_Gauge) {
		Goal.Gauge.Clan = 0;
		Goal.Gauge.Speed = 0;
		Goal.Gauge.Value = 0;
		Goal.Gauge.Max = 1000;
		Goal.Gauge.Captured = False;
	}

	MB_CurrentSection = "WarmUp";
	
	while (ClansNbPlayers[1] < 1 || ClansNbPlayers[2] < 1 && (!ServerShutdownRequested && !MatchEndRequested)) {
		MB_Yield();
		Users_SetNbFakeUsers(G_BlueBot, G_RedBot);
		
		// Let the server sleep if there's no players on it
		if (PlayersNbTotal <= 0) continue;

		SM::UnspawnPlayersChangingClan();
		foreach(Player in Players) 
		{
			if (Player.SpawnStatus == CSmPlayer::ESpawnStatus::NotSpawned) 
			{
				declare Spawn <=> Map::GetPlayerSpawn("SpawnDefence", 0);
				if (Spawn != Null) SM::SpawnPlayer(Player, Player.RequestedClan, Spawn);
				ActionLoad(Player, CSmMode::EActionSlot::Slot_A, NullId);
				ActionLoad(Player, CSmMode::EActionSlot::Slot_B, NullId);
				ActionBind(Player, CSmMode::EActionSlot::Slot_A, CSmMode::EActionInput::None);
				ActionBind(Player, CSmMode::EActionSlot::Slot_B, CSmMode::EActionInput::None);
				SetPlayerWeapon(Player, CSmMode::EWeapon::Rocket, False);
				SetPlayerAmmoMax(Player, CSmMode::EWeapon::Rocket, C_RocketsAmmo);
			}
		}
		
		foreach (Player in Players) 
		{
			declare UI <=> UIManager.GetUI(Player);
			if (UI == Null) continue;
			declare MSG = "";
			switch(Player.User.Language)
			{
				case "pl": MSG = "Do gry potrzeba przynajmniej 2 graczy";
				case "fr": MSG = "2 joueurs nécessaire pour jouer";
				case "ru": MSG = "Требуется 2 игрока для начала игры";
				case "it": MSG = "Per giocare bisogna almeno 2 giocatori";
				case "de": MSG = "Es müssen 2 Spieler zum Spielen da sein.";
				default: MSG = "2 players needed to play";
			}
			UI.StatusMessage = MSG;
		}	
	}
	
	SM::UnspawnAllPlayers();
	StartTime = -1;
	UIManager.UIAll.BigMessage = "";
	UIManager.UIAll.StatusMessage = "";
	UIManager.UIAll.UISequence = CUIConfig::EUISequence::EndRound;
	MB_CurrentSection = "StartRound";
	
	// ---------------------------------- //
	// Update the players clublinks
	if (S_ForceClublinkTeam1 == "" && S_ForceClublinkTeam2 == "") Clublink::DefineTeamAuto();
	else Clublink::DefineTeamFromUrl(S_ForceClublinkTeam1, S_ForceClublinkTeam2);	
}

// Calculates skalar of two vectors
Real Private_Skalar(Vec3 _Vec1, Vec3 _Vec2) {
	return _Vec1[0]*_Vec2[0] + _Vec1[1]*_Vec2[1] + _Vec1[2]*_Vec2[2];
}

// Update the layer - Shop
Text UpdateLayerShop() {
	if(ServerShutdownRequested || MatchEndRequested)
	{
		MB_StopMap = True;
		return "";
	}	
	declare Text ML = "";
	ML = """
<dico>
   <language id="en">
   	  <shop>Shop</shop>
      <buy1>More Stamina</buy1>
      <buy2>Bouncing Rockets</buy2>
      <buy3>Electric Pistol</buy3>
      <buy4>Plasma Gun</buy4>
      <buy5>Shotgun</buy5>
      <buy6>Laser</buy6>
      <buy7>Nucleus</buy7>
      <buy8>Blow Bomb</buy8>
      <buy9>Burning grenades</buy9>
      <buy10>4 armors instead 3</buy10>
      <buy11>6 armors instead 3</buy11>
      <rewards>Cash rewards</rewards>
	  <hit>Hit:</hit>
	  <head>Headshot hit:</head>
	  <kill>Elimination:</kill>
	  <capture>Capture:</capture>
	  <win>Win:</win>
	  <loss>Loss:</loss>
      <primary>Buy primary Weapon</primary>
      <sec>Buy secondary Weapon</sec>
      <abi>Buy Abilities</abi>
      <rule1>- Use your money to buy equipment.</rule1>
      <rule2>- You can buy only one secondary weapon and one primary weapon.</rule2>
      <rule3>- If you not buy secondary weapon, you will play with 3 rockets.</rule3>
      <rule4>- If you will die, then all equipment will lost.</rule4>
   </language>
   <language id="pl">
   	  <shop>Sklep</shop>
      <buy1>Lepsza kondycja</buy1>
      <buy2>Rakiety odbijalne</buy2>
      <buy3>Pistolet elektryczny</buy3>
      <buy4>Karabin plazmowy</buy4>
      <buy5>Shotgun</buy5>
      <buy6>Laser</buy6>
      <buy7>Nucleus</buy7>
      <buy8>Bomba</buy8>
      <buy9>Płonące Granaty</buy9>
      <buy10>4 pancerze zamiast 3</buy10>
      <buy11>6 pancerzy zamiast 3</buy11>
      <rewards>Jak zdobyć hajs?</rewards>
	  <hit>Trafienie:</hit>
	  <head>Traf. (Headshot):</head>
	  <kill>Eliminacja:</kill>
	  <capture>Zdobycz:</capture>
	  <win>Zwycięstwo:</win>
	  <loss>Porażka:</loss>
      <primary>Kup broń główną</primary>
      <sec>Kup broń podręczną</sec>
      <abi>Kup zdolności</abi>
      <rule1>- Użyj pieniędzy by kupić wyposażenie.</rule1>
      <rule2>- Możesz kupić tylko jedną broń zapasową i jedną broń główną.</rule2>
      <rule3>- Jeżeli nie kupisz broni podręcznej, dostaniesz 3 zwykłe rakiety.</rule3>
      <rule4>- Jeżeli zginiesz, stracisz ekwipunek.</rule4>
   </language>
</dico>
<script><!--
#Include "TextLib" as TL
main() 
{
	declare L_Buy1 <=> (Page.GetFirstChild("L_buy1") as CMlLabel);
	declare L_Buy2 <=> (Page.GetFirstChild("L_buy2") as CMlLabel);
	declare L_Buy3 <=> (Page.GetFirstChild("L_buy3") as CMlLabel);
	declare L_Buy4 <=> (Page.GetFirstChild("L_buy4") as CMlLabel);
	declare L_Buy5 <=> (Page.GetFirstChild("L_buy5") as CMlLabel);
	declare L_Buy6 <=> (Page.GetFirstChild("L_buy6") as CMlLabel);
	declare L_Buy7 <=> (Page.GetFirstChild("L_buy7") as CMlLabel);
	declare L_Buy8 <=> (Page.GetFirstChild("L_buy8") as CMlLabel);
	declare L_Buy9 <=> (Page.GetFirstChild("L_buy9") as CMlLabel);
	declare L_Buy10 <=> (Page.GetFirstChild("L_buy10") as CMlLabel);
	declare L_Buy11 <=> (Page.GetFirstChild("L_buy11") as CMlLabel);
	declare B_Buy1 <=> (Page.GetFirstChild("B_buy1") as CMlLabel);
	declare B_Buy2 <=> (Page.GetFirstChild("B_buy2") as CMlLabel);
	declare B_Buy3 <=> (Page.GetFirstChild("B_buy3") as CMlLabel);
	declare B_Buy4 <=> (Page.GetFirstChild("B_buy4") as CMlLabel);
	declare B_Buy5 <=> (Page.GetFirstChild("B_buy5") as CMlLabel);
	declare B_Buy6 <=> (Page.GetFirstChild("B_buy6") as CMlLabel);
	declare B_Buy7 <=> (Page.GetFirstChild("B_buy7") as CMlLabel);
	declare B_Buy8 <=> (Page.GetFirstChild("B_buy8") as CMlLabel);
	declare B_Buy9 <=> (Page.GetFirstChild("B_buy9") as CMlLabel);
	declare B_Buy10 <=> (Page.GetFirstChild("B_buy10") as CMlLabel);
	declare B_Buy11 <=> (Page.GetFirstChild("B_buy11") as CMlLabel);
	declare L_Cash <=> (Page.GetFirstChild("L_Cash") as CMlLabel);
	
	declare PreventLoop = 0;
	
	while (True) 
	{
		yield;

		if (InputPlayer == Null) continue;
		declare ShopPrices = {{{C_ShopPrices}}};
		declare CanBuy = [True, True, True, True, True, True, True, True, True, True, True];
		declare netwrite Net_Bought for UI = [False, False, False, False, False, False, False, False, False, False, False];
		declare netread Net_Cash for UI = {{{C_StartCash}}};
		declare netwrite Net_ShopBill for UI = 0;
		if({{{MB_SectionRoundNb}}} == 1 && PreventLoop == 0)
		{
			PreventLoop += 1;
			Net_Bought = [False, False, False, False, False, False, False, False, False, False, False];
			CanBuy = [True, True, True, True, True, True, True, True, True, True, True];
		}	
		L_Cash.SetText(TL::Compose(_("$8a0%1 $f90$$"), TL::ToText(Net_Cash - Net_ShopBill)));
		
		if(Net_Bought[0])
		{
			B_Buy1.Hide();
			L_Buy1.Show();
			L_Buy1.SetText("$9f0Bought");
			CanBuy[0] = False;
		}	
		else if(Net_Cash - Net_ShopBill < ShopPrices[1])
		{
			L_Buy1.Show();
			L_Buy1.SetText(TL::Compose(_("$f90Need %1$$"), TL::ToText(ShopPrices[1] - Net_Cash + Net_ShopBill)));
			B_Buy1.Hide();
			CanBuy[0] = False;
		}	
		else
		{
			B_Buy1.SetText("Buy ("^ShopPrices[1]^"$$)");
			L_Buy1.Hide();
			CanBuy[0] = True;
		}	
		
		if(Net_Bought[1])
		{
			B_Buy2.Hide();
			L_Buy2.Show();
			L_Buy2.SetText("$9f0Bought");
			CanBuy[1] = False;
		}	
		else if(Net_Cash - Net_ShopBill < ShopPrices[2])
		{
			L_Buy2.Show();
			L_Buy2.SetText(TL::Compose(_("$f90Need %1$$"), TL::ToText(ShopPrices[2] - Net_Cash+ Net_ShopBill)));
			B_Buy2.Hide();
			CanBuy[1] = False;
		}	
		else
		{
			B_Buy2.SetText("Buy ("^ShopPrices[2]^"$$)");
			L_Buy2.Hide();
			CanBuy[1] = True;
		}	
		
		if(Net_Bought[2])
		{
			B_Buy3.Hide();
			L_Buy3.Show();
			L_Buy3.SetText("$9f0Bought");
			CanBuy[2] = False;
		}	
		else if(Net_Cash - Net_ShopBill < ShopPrices[3])
		{
			L_Buy3.Show();
			L_Buy3.SetText(TL::Compose(_("$f90Need %1$$"), TL::ToText(ShopPrices[3]- Net_Cash + Net_ShopBill)));
			B_Buy3.Hide();
			CanBuy[2] = False;
		}	
		else
		{
			B_Buy3.SetText("Buy ("^ShopPrices[3]^"$$)");
			L_Buy3.Hide();
			CanBuy[2] = True;
		}

		if(Net_Bought[3])
		{
			B_Buy4.Hide();
			L_Buy4.Show();
			L_Buy4.SetText("$9f0Bought");
			CanBuy[3] = False;
		}	
		else if(Net_Cash - Net_ShopBill < ShopPrices[4])
		{
			L_Buy4.Show();
			L_Buy4.SetText(TL::Compose(_("$f90Need %1$$"), TL::ToText(ShopPrices[4] - Net_Cash + Net_ShopBill)));
			B_Buy4.Hide();
			CanBuy[3] = False;
		}	
		else
		{
			B_Buy4.SetText("Buy ("^ShopPrices[4]^"$$)");
			L_Buy4.Hide();
			CanBuy[3] = True;
		}

		if(Net_Bought[4])
		{
			B_Buy5.Hide();
			L_Buy5.Show();
			L_Buy5.SetText("$9f0Bought");
			CanBuy[4] = False;
		}	
		else if(Net_Cash - Net_ShopBill < ShopPrices[5])
		{
			L_Buy5.Show();
			L_Buy5.SetText(TL::Compose(_("$f90Need %1$$"), TL::ToText(ShopPrices[5] - Net_Cash + Net_ShopBill)));
			B_Buy5.Hide();
			CanBuy[4] = False;
		}	
		else
		{
			B_Buy5.SetText("Buy ("^ShopPrices[5]^"$$)");
			L_Buy5.Hide();
			CanBuy[4] = True;
		}

		if(Net_Bought[5])
		{
			B_Buy6.Hide();
			L_Buy6.Show();
			L_Buy6.SetText("$9f0Bought");
			CanBuy[5] = False;
		}	
		else if(Net_Cash - Net_ShopBill < ShopPrices[6])
		{
			L_Buy6.Show();
			L_Buy6.SetText(TL::Compose(_("$f90Need %1$$"), TL::ToText(ShopPrices[6] - Net_Cash + Net_ShopBill)));
			B_Buy6.Hide();
			CanBuy[5] = False;
		}	
		else
		{
			B_Buy6.SetText("Buy ("^ShopPrices[6]^"$$)");
			L_Buy6.Hide();
			CanBuy[5] = True;
		}

		if(Net_Bought[6])
		{
			B_Buy7.Hide();
			L_Buy7.Show();
			L_Buy7.SetText("$9f0Bought");
			CanBuy[6] = False;
		}	
		else if(Net_Cash - Net_ShopBill < ShopPrices[7])
		{
			L_Buy7.Show();
			L_Buy7.SetText(TL::Compose(_("$f90Need %1$$"), TL::ToText(ShopPrices[7] - Net_Cash + Net_ShopBill)));
			B_Buy7.Hide();
			CanBuy[6] = False;
		}	
		else
		{
			B_Buy7.SetText("Buy ("^ShopPrices[7]^"$$)");
			L_Buy7.Hide();
			CanBuy[6] = True;
		}

		if(Net_Bought[7])
		{
			B_Buy8.Hide();
			L_Buy8.Show();
			L_Buy8.SetText("$9f0Bought");
			CanBuy[7] = False;
		}	
		else if(Net_Cash - Net_ShopBill < ShopPrices[8])
		{
			L_Buy8.Show();
			L_Buy8.SetText(TL::Compose(_("$f90Need %1$$"), TL::ToText(ShopPrices[8] - Net_Cash + Net_ShopBill)));
			B_Buy8.Hide();
			CanBuy[7] = False;
		}	
		else
		{
			B_Buy8.SetText("Buy ("^ShopPrices[8]^"$$)");
			L_Buy8.Hide();
			CanBuy[7] = True;
		}

		if(Net_Bought[8])
		{
			B_Buy9.Hide();
			L_Buy9.Show();
			L_Buy9.SetText("$9f0Bought");
			CanBuy[8] = False;
		}	
		else if(Net_Cash - Net_ShopBill < ShopPrices[9])
		{
			L_Buy9.Show();
			L_Buy9.SetText(TL::Compose(_("$f90Need %1$$"), TL::ToText(ShopPrices[9] - Net_Cash + Net_ShopBill)));
			B_Buy9.Hide();
			CanBuy[8] = False;
		}	
		else
		{
			B_Buy9.SetText("Buy ("^ShopPrices[9]^"$$)");
			L_Buy9.Hide();
			CanBuy[8] = True;
		}
		// Shields, If you buy 3 shields, then you shouldn't get access to 1 armor option
		if(Net_Bought[10])
		{
			B_Buy10.Hide();
			L_Buy10.Hide();
			CanBuy[9] = False;
		}
		else
		{
			if(Net_Bought[9])
			{
				B_Buy10.Hide();
				L_Buy10.Show();
				L_Buy10.SetText("$9f0Bought");
				CanBuy[9] = False;
			}	
			else if(Net_Cash - Net_ShopBill < ShopPrices[10])
			{
				L_Buy10.Show();
				L_Buy10.SetText(TL::Compose(_("$f90Need %1$$"), TL::ToText(ShopPrices[10] - Net_Cash + Net_ShopBill)));
				B_Buy10.Hide();	
				CanBuy[9] = False;
			}	
			else
			{
				B_Buy10.SetText("Buy ("^ShopPrices[10]^"$$)");
				L_Buy10.Hide();
				CanBuy[9] = True;
			}
		}	

		if(Net_Bought[10])
		{
			B_Buy11.Hide();
			L_Buy11.Show();
			L_Buy11.SetText("$9f0Bought");
			CanBuy[10] = False;
		}	
		else if(Net_Cash - Net_ShopBill < ShopPrices[11])
		{
			L_Buy11.Show();
			L_Buy11.SetText(TL::Compose(_("$f90Need %1$$"), TL::ToText(ShopPrices[11] - Net_Cash + Net_ShopBill)));
			B_Buy11.Hide();
			CanBuy[10] = False;
		}	
		else
		{
			B_Buy11.SetText("Buy ("^ShopPrices[11]^"$$)");
			L_Buy11.Hide();
			CanBuy[10] = True;
		}

		foreach (Event in PendingEvents) 
		{
			switch (Event.Type) 
			{
				case CMlEvent::Type::MouseClick: 
				{
					if(Event.ControlId == "B_buy1" && CanBuy[0])
					{
						Net_Bought[0] = True;
						Net_ShopBill += ShopPrices[1];
					}	
					if(Event.ControlId == "B_buy2" && CanBuy[1])
					{
						Net_Bought[1] = True; 
						Net_ShopBill += ShopPrices[2];
					}	
					if(Event.ControlId == "B_buy3" && CanBuy[2])
					{
						Net_Bought[2] = True;
						Net_ShopBill += ShopPrices[3];
					}	
					if(Event.ControlId == "B_buy4" && CanBuy[3])
					{
						Net_Bought[3] = True;
						Net_ShopBill += ShopPrices[4];
					}	
					if(Event.ControlId == "B_buy5" && CanBuy[4])
					{
						Net_Bought[4] = True;
						Net_ShopBill += ShopPrices[5];
					}	
					if(Event.ControlId == "B_buy6" && CanBuy[5])
					{
						Net_Bought[5] = True;
						Net_ShopBill += ShopPrices[6];
					}	
					if(Event.ControlId == "B_buy7" && CanBuy[6]) 
					{
						Net_Bought[6] = True;
						Net_ShopBill += ShopPrices[7];
					}	
					if(Event.ControlId == "B_buy8" && CanBuy[7])
					{
						Net_Bought[7] = True;
						Net_ShopBill += ShopPrices[8];
					}	
					if(Event.ControlId == "B_buy9" && CanBuy[8])
					{
						Net_Bought[8] = True;
						Net_ShopBill += ShopPrices[9];
					}	
					if(Event.ControlId == "B_buy10" && CanBuy[9])
					{
						Net_Bought[9] = True;
						Net_ShopBill += ShopPrices[10];
					}	
					if(Event.ControlId == "B_buy11" && CanBuy[10])
					{
						Net_Bought[10] = True;
						Net_ShopBill += ShopPrices[11];
					}	
				}
			}
		}
	}
}
--></script>
<frame>
	<quad posn="0 -5 0" sizen="220 154" image="{{{C_ImgModeDir}}}/bigboard-center.dds" halign="center" valign="center"/>
	<label posn="0 56 1" sizen="50 11" textid="shop" halign="center" valign="top" style="TextButtonNav" textsize="9"/>
	<label posn="0 37 1" sizen="57 9" text="$8a00$f90 $$" textsize="6" style="BgMainMenuTitleHeader" halign="center" valign="bottom" id="L_Cash"/>
	<label posn="-102 57 1" sizen="56 5" text="{{{TextLib::Compose(_("Round %1"), TextLib::ToText(MB_SectionRoundNb))}}}"/>
	<label posn="-102 50 1" sizen="61 5" text="{{{TextLib::Compose(_("|Imperative|Attack"))}}}: {{{Teams[G_AttackingClan-1].ColorizedName}}}"/>
	<label posn="-102 43 1" sizen="61 5" text="{{{TextLib::Compose(_("|Imperative|Defend"))}}}: {{{Teams[3-G_AttackingClan-1].ColorizedName}}}"/>
	<label posn="72 57 1" sizen="54 5" textid="rewards" textcolor="f90" halign="center" textsize="2"/>
	<format textsize="2" scale="0.7"/>
	<frame posn="30 52 1">
		<label posn="10 0 1" sizen="20 5" textid="hit"/>
		<label posn="38 0 1" sizen="10 5" text="$9F0{{{C_CashForHit}}}" halign="right"/>
		<label posn="10 -5 1" sizen="20 5" textid="kill" />
		<label posn="38 -5 1" sizen="10 5" text="$9F0{{{C_CashForKill}}}" halign="right"/>
		<label posn="10 -10 1" sizen="20 5" textid="capture"/>
		<label posn="38 -10 1" sizen="10 5" text="$9F0{{{C_CashForCapture}}}" halign="right"/>
		<label posn="40 0 1" sizen="20 5" textid="head"/>
		<label posn="70 0 1" sizen="10 5" text="$9F0{{{TextLib::ToText(C_CashForHeadshotHit+C_CashForHit)}}}" halign="right"/>
		<label posn="40 -5 1" sizen="20 5" textid="win"/>
		<label posn="70 -5 1" sizen="10 5" text="$9F0{{{C_CashForWin}}}" halign="right"/>
		<label posn="40 -10 1" sizen="20 5" textid="loss"/>
		<label posn="70 -10 1" sizen="10 5" text="$9F0{{{C_CashForLoss}}}" halign="right"/>
	</frame>
	<quad posn="-102 36 1" sizen="204 1" bgcolor="CCC7"/>
	<quad posn="-47 -42 1" sizen="149 1" bgcolor="CCC7"/>
	<quad posn="-48 35 1" sizen="1 103" bgcolor="CCC7"/>
	<quad posn="-101 -10 1" sizen="54 1" bgcolor="CCC7"/>
	<label posn="25 27 0" sizen="111 5" textid="primary" style="TextButtonNav" halign="center" valign="center" textsize="3"/>
	<label posn="-76 30 0" sizen="48 5" textid="sec" style="TextButtonNav" halign="center" valign="center" textsize="2"/>
	<label posn="-76 -15 0" sizen="48 5" textid="abi" style="TextButtonNav" halign="center" valign="center" textsize="2"/>
	<frame posn="-103 2 1" id="Frame_BRocket">
		<quad posn="27 16 0" sizen="50 16" bgcolor="FFFA" style="EnergyBar" substyle="EnergyBar" halign="center" valign="center"/>
		<quad posn="12 16 1" sizen="12 12" bgcolor="FFFA" image="{{{C_ImgModeDir}}}/IconWeaponBRocket.dds" halign="center" valign="center"/>
		<label posn="34 20 0" sizen="29 6" textid="buy2" textsize="2" halign="center" valign="center2"/>
		<label posn="20 17 1" text="Buy ({{{C_ShopPrices[2]}}}$$)" style="CardButtonSmallS" scriptevents="1" id="B_buy2"/>
		<label posn="24 15 1" sizen="22 6" valign="center" text="$9f0Bought" hidden="1" id="L_buy2"/>
	</frame>
	<frame posn="-103 -15 1" id="Frame_EPistol">
		<quad posn="27 16 0" sizen="50 16" bgcolor="FFFA" style="EnergyBar" substyle="EnergyBar" halign="center" valign="center"/>
		<quad posn="12 16 1" sizen="12 12" bgcolor="FFFA" image="{{{C_ImgModeDir}}}/IconWeaponElectricPistol.dds" halign="center" valign="center"/>
		<label posn="34 20 0" sizen="29 6" textid="buy3" textsize="2" halign="center" valign="center2"/>
		<label posn="20 17 1" text="Buy ({{{C_ShopPrices[3]}}}$$)" style="CardButtonSmallS" scriptevents="1" id="B_buy3"/>
		<label posn="24 15 1" sizen="22 6" valign="center" text="$9f0Bought" hidden="1" id="L_buy3"/>
	</frame>
	<frame posn="-103 -43 1" id="Frame_Stamina">
		<quad posn="27 16 0" sizen="50 16" bgcolor="FFFA" style="EnergyBar" substyle="EnergyBar" halign="center" valign="center"/>
		<quad posn="12 16 1" sizen="12 12" bgcolor="FFFA" image="{{{C_ImgModeDir}}}/IconActionRun.tga" halign="center" valign="center"/>
		<label posn="34 20 0" sizen="29 6" textid="buy1" textsize="2" halign="center" valign="center2"/>
		<label posn="20 17 1" text="Buy ({{{C_ShopPrices[1]}}}$$)" style="CardButtonSmallS" scriptevents="1" id="B_buy1"/>
		<label posn="24 15 1" sizen="22 6" valign="center" text="$9f0Bought" hidden="1" id="L_buy1"/>
	</frame>
	<frame posn="-103 -60 1" id="Frame_Shield">
		<quad posn="27 16 0" sizen="50 16" bgcolor="FFFA" style="EnergyBar" substyle="EnergyBar" halign="center" valign="center"/>
		<quad posn="12 16 1" sizen="12 12" bgcolor="FFFA" image="{{{C_ImgModeDir}}}/IconShield.dds" halign="center" valign="center"/>
		<label posn="34 20 0" sizen="29 6" textid="buy10" textsize="2" halign="center" valign="center2"/>
		<label posn="20 17 1" text="Buy ({{{C_ShopPrices[10]}}}$$)" style="CardButtonSmallS" scriptevents="1" id="B_buy10"/>
		<label posn="24 15 1" sizen="22 6" valign="center" text="$9f0Bought" hidden="1" id="L_buy10"/>
	</frame>
	<frame posn="-103 -77 1" id="Frame_Shields">
		<quad posn="27 16 0" sizen="50 16" bgcolor="FFFA" style="EnergyBar" substyle="EnergyBar" halign="center" valign="center"/>
		<quad posn="12 16 1" sizen="12 12" bgcolor="FFFA" image="{{{C_ImgModeDir}}}/IconShield.dds" halign="center" valign="center"/>
		<label posn="34 20 0" sizen="29 6" textid="buy11" textsize="2" halign="center" valign="center2"/>
		<label posn="20 17 1" text="Buy ({{{C_ShopPrices[11]}}}$$)" style="CardButtonSmallS" scriptevents="1" id="B_buy11"/>
		<label posn="24 15 1" sizen="22 6" valign="center" text="$9f0Bought" hidden="1" id="L_buy11"/>
	</frame>
	<frame posn="-35 -5 1" id="Frame_PlasmaGun">
		<quad posn="27 16 0" sizen="50 16" bgcolor="FFFA" style="EnergyBar" substyle="EnergyBar" halign="center" valign="center"/>
		<quad posn="12 16 1" sizen="12 12" bgcolor="FFFA" image="{{{C_ImgModeDir}}}/IconWeaponPlasmaGun.dds" halign="center" valign="center"/>
		<label posn="34 20 0" sizen="29 6" textid="buy4" textsize="2" halign="center" valign="center2"/>
		<label posn="20 17 1" text="Buy ({{{C_ShopPrices[4]}}}$$)" style="CardButtonSmallS" scriptevents="1" id="B_buy4"/>
		<label posn="24 15 1" sizen="22 6" valign="center" text="$9f0Bought" hidden="1" id="L_buy4"/>
	</frame>
	<frame posn="-35 -25 1" id="Frame_Shotgun">
		<quad posn="27 16 0" sizen="50 16" bgcolor="FFFA" style="EnergyBar" substyle="EnergyBar" halign="center" valign="center"/>
		<quad posn="12 16 1" sizen="12 12" bgcolor="FFFA" image="{{{C_ImgModeDir}}}/IconWeaponShotgun.dds" halign="center" valign="center"/>
		<label posn="34 20 0" sizen="29 6" textid="buy5" textsize="2" halign="center" valign="center2"/>
		<label posn="20 17 1" text="Buy ({{{C_ShopPrices[5]}}}$$)" style="CardButtonSmallS" scriptevents="1" id="B_buy5"/>
		<label posn="24 15 1" sizen="22 6" valign="center" text="$9f0Bought" hidden="1" id="L_buy5"/>
	</frame>
	<frame posn="-35 -45 1" id="Frame_Laser">
		<quad posn="27 16 0" sizen="50 16" bgcolor="FFFA" style="EnergyBar" substyle="EnergyBar" halign="center" valign="center"/>
		<quad posn="12 16 1" sizen="12 12" bgcolor="FFFA" image="{{{C_ImgModeDir}}}/IconWeaponLaser.dds" halign="center" valign="center"/>
		<label posn="34 20 0" sizen="29 6" textid="buy6" textsize="2" halign="center" valign="center2"/>
		<label posn="20 17 1" text="Buy ({{{C_ShopPrices[6]}}}$$)" style="CardButtonSmallS" scriptevents="1" id="B_buy6"/>
		<label posn="24 15 1" sizen="22 6" valign="center" text="$9f0Bought" hidden="1" id="L_buy6"/>
	</frame>
	<frame posn="30 -5 1" id="Frame_Nucleus">
		<quad posn="27 16 0" sizen="50 16" bgcolor="FFFA" style="EnergyBar" substyle="EnergyBar" halign="center" valign="center"/>
		<quad posn="12 16 1" sizen="12 12" bgcolor="FFFA" image="{{{C_ImgModeDir}}}/IconWeaponNucleus.dds" halign="center" valign="center"/>
		<label posn="34 20 0" sizen="29 6" textid="buy7" textsize="2" halign="center" valign="center2"/>
		<label posn="20 17 1" text="Buy ({{{C_ShopPrices[7]}}}$$)" style="CardButtonSmallS" scriptevents="1" id="B_buy7"/>
		<label posn="24 15 1" sizen="22 6" valign="center" text="$9f0Bought" hidden="1" id="L_buy7"/>
	</frame>
	<frame posn="30 -25 1" id="Frame_BlowBomb">
		<quad posn="27 16 0" sizen="50 16" bgcolor="FFFA" style="EnergyBar" substyle="EnergyBar" halign="center" valign="center"/>
		<quad posn="12 16 1" sizen="12 12" bgcolor="FFFA" image="{{{C_ImgModeDir}}}/IconWeaponBlowBomb.dds" halign="center" valign="center"/>
		<label posn="34 20 0" sizen="29 6" textid="buy8" textsize="2" halign="center" valign="center2"/>
		<label posn="20 17 1" text="Buy ({{{C_ShopPrices[8]}}}$$)" style="CardButtonSmallS" scriptevents="1" id="B_buy8"/>
		<label posn="24 15 1" sizen="22 6" valign="center" text="$9f0Bought" hidden="1" id="L_buy8"/>
	</frame>
	<frame posn="30 -45 1" id="Frame_Grenades">
		<quad posn="27 16 0" sizen="50 16" bgcolor="FFFA" style="EnergyBar" substyle="EnergyBar" halign="center" valign="center"/>
		<quad posn="12 16 1" sizen="12 12" bgcolor="FFFA" image="{{{C_ImgModeDir}}}/IconWeaponGrenades.dds" halign="center" valign="center"/>
		<label posn="34 20 0" sizen="29 6" textid="buy9" textsize="2" halign="center" valign="center2"/>
		<label posn="20 17 1" text="Buy ({{{C_ShopPrices[9]}}}$$)" style="CardButtonSmallS" scriptevents="1" id="B_buy9"/>
		<label posn="24 15 1" sizen="22 6" valign="center" text="$9f0Bought" hidden="1" id="L_buy9"/>
	</frame>
	<label posn="-46 -45 0" sizen="148 5" textid="rule1" style="TextButtonNav"/>
	<label posn="-46 -51 0" sizen="148 5" textid="rule2" style="TextButtonNav"/>
	<label posn="-46 -57 0" sizen="148 5" textid="rule3" style="TextButtonNav"/>
	<label posn="-46 -63 0" sizen="148 5" textid="rule4" style="TextButtonNav"/>
</frame>
""";
	
	return ML;
}

//Functions from LoadoutsTitle

Void UpdateHeader(Integer _Clan1Points, Integer _Clan2Points) 
{
	UIManager.UIAll.OverlayScoreSummary = True;
	declare PlayerClan1Id = NullId;
	declare PlayerClan2Id = NullId;
	
	foreach (Player in Players) {
		if (PlayerClan1Id == NullId && Player.CurrentClan == 1) PlayerClan1Id = Player.Id;
		if (PlayerClan2Id == NullId && Player.CurrentClan == 2) PlayerClan2Id = Player.Id;
		if (PlayerClan1Id != NullId && PlayerClan2Id != NullId) break;
	}
	
	if (PlayerClan1Id != NullId) UIManager.UIAll.ScoreSummary_Player1 = PlayerClan1Id;
	else UIManager.UIAll.ScoreSummary_Player1 = NullId;
	if (PlayerClan2Id != NullId) UIManager.UIAll.ScoreSummary_Player2 = PlayerClan2Id;
	else UIManager.UIAll.ScoreSummary_Player2 = NullId;
	UIManager.UIAll.ScoreSummary_Points1		= _Clan1Points;
	//UIManager.UIAll.ScoreSummary_MatchPoints1	= ClanScores[1];
	UIManager.UIAll.ScoreSummary_Points2		= _Clan2Points;
	//UIManager.UIAll.ScoreSummary_MatchPoints2	= ClanScores[2];
}

Void UpdateSTFooter()
{
	ST2::SetFooterText(TextLib::Compose(_("Round: %1 | Points to win: %2 | Attacking: %3"), TextLib::ToText(MB_SectionRoundNb), TextLib::ToText(G_MapPointsLimit), Teams[G_AttackingClan-1].ColorizedName));
	ModeStatusMessage = TextLib::Compose(_("RULES: Locate vulnerable point and do overload to win the round.\nRound $9f0%1$g Score: $<%2%3$>:$<%4%5$>"), TextLib::ToText(MB_SectionRoundNb), Teams[0].ColorText, TextLib::ToText(G_ClansMapPoints[1]), Teams[1].ColorText, TextLib::ToText(G_ClansMapPoints[2]));
}	

Void AnnounceHitDistance(Real _Distance, CSmPlayer _Player)
{
	declare UI <=> UIManager.GetUI(_Player);
	if(UI == Null) return;
	declare Distance = MathLib::NearestInteger(_Distance * 10) / 10.0;
	Message::SendStatusMessage(_Player, TextLib::Compose(_("%1m hit!"), TextLib::ToText(Distance)), 2500, 1);
	UI.SendNotice(TextLib::Compose(_("%1m hit!"), TextLib::ToText(Distance)), CUIConfig::ENoticeLevel::Default, Null, CUIConfig::EAvatarVariant::Default, CUIConfig::EUISound::Silence, 0);
}

Void AnnounceRoundWin(Integer _Winner)
{
	if(_Winner > 0)
	{
		foreach(Player in Players)
		{
			declare MSG = "";
			switch(Player.User.Language)
			{
				case "pl": MSG = "wygrali rundę.";
				case "fr": MSG = "gagne la manche.";
				case "it": MSG = "Hanno vinto il turno.";
				case "de": MSG = "gewinnt die Runde.";
				default: MSG = "wins the round.";
			}
			Message::SendBigMessage(Player, TextLib::Compose(_("%1 %2"), Teams[_Winner-1].ColorizedName, MSG), 6500, 0, CUIConfig::EUISound::Silence, 2);
		}
		foreach(Spectator in Spectators)
		{
			declare MSG = "";
			switch(Spectator.User.Language)
			{
				case "pl": MSG = "wygrali rundę.";
				case "fr": MSG = "gagne la manche.";
				case "it": MSG = "Hanno vinto il turno.";
				case "de": MSG = "gewinnt die Runde.";
				default: MSG = "wins the round.";
			}
			Message::SendBigMessage(Spectator, TextLib::Compose(_("%1 %2"), Teams[_Winner-1].ColorizedName, MSG), 6500, 0, CUIConfig::EUISound::Silence, 2);
		}
	}	
	else Message::SendBigMessage(TextLib::Compose(_("|Match|Draw")), 6500, 0, CUIConfig::EUISound::Silence, 0);
}

Void AnnounceEliminationMessage(Integer _ClanNb, Integer _LeftPlayers)
{
	declare Sound = CUIConfig::EUISound::TieBreakPoint;
	if(_LeftPlayers <= 0)
	{
		foreach(Player in Players)
		{
			declare MSG = "";
			switch(Player.User.Language)
			{
				case "pl": MSG = "wyeliminowani!";
				case "fr": MSG = "éliminé !";
				case "ru": MSG = "уничтожена!";
				case "it": MSG = "eliminati!!";
				case "de": MSG = "eliminiert!";
				default: MSG = "eliminated!";
			}
			Message::SendBigMessage(Player, TextLib::Compose(_("%1 %2"), Teams[_ClanNb].ColorizedName, MSG), 5000, 1, CUIConfig::EUISound::VictoryPoint, 0);
		}
		foreach(Spectator in Spectators)
		{
			declare MSG = "";
			switch(Spectator.User.Language)
			{
				case "pl": MSG = "wyeliminowani!";
				case "fr": MSG = "éliminé !";
				case "ru": MSG = "уничтожена!";
				case "it": MSG = "eliminati!";
				case "de": MSG = "eliminiert!";
				default: MSG = "eliminated!";
			}
			Message::SendBigMessage(Spectator, TextLib::Compose(_("%1 %2"), Teams[_ClanNb].ColorizedName, MSG), 5000, 1, CUIConfig::EUISound::VictoryPoint, 0);
		}
	}
	else if (_LeftPlayers == 1)
	{
		foreach(Player in Players)
		{
			declare MSG = "";
			switch(Player.User.Language)
			{
				case "pl": MSG = "Ostatni żyjący!";
				case "fr": MSG = "Dernier homme en vie !";
				case "ru": MSG = "Остался Последним!";
				case "it": MSG = "Ultimo vivente!";
				case "de": MSG = "Mann gegen Mann, der letzte gewinnt!";
				default: MSG = "Last Man Standing!";
			}
			Message::SendStatusMessage(Player, TextLib::Compose(_("%1: %2"),Teams[_ClanNb].ColorizedName, MSG), 4000, 0, Sound, 0);
		}
		foreach(Spectator in Spectators)
		{
			declare MSG = "";
			switch(Spectator.User.Language)
			{
				case "pl": MSG = "Ostatni żyjący!";
				case "fr": MSG = "Dernier homme en vie !";
				case "ru": MSG = "Остался Последним!";
				case "it": MSG = "Ultimo vivente!";
				case "de": MSG = "Mann gegen Mann, der letzte gewinnt!";
				default: MSG = "Last Man Standing!";
			}
			Message::SendStatusMessage(Spectator, TextLib::Compose(_("%1: %2"),Teams[_ClanNb].ColorizedName, MSG), 4000, 0, Sound, 0);
		}
		Sound::PlaySound("file://Media/Sounds/FireFight/lastman.ogg", -8., 300);
	}
	else
	{
		foreach(Player in Players)
		{
			declare MSG = "";
			switch(Player.User.Language)
			{
				case "pl": MSG = "Pozostało %1 żywych w zespole %2";
				case "fr": MSG = "%1 joueurs restant dans %2";
				case "ru": MSG = "%1 игроков перешли в %2";
				case "it": MSG = "Sono rimasti %1 viventi nella squadra %2";
				case "de": MSG = "%1 Spieler übrig in %2";
				default: MSG = "%1 players left in %2";
			}
			Message::SendStatusMessage(Player, TextLib::Compose(MSG,TextLib::ToText(_LeftPlayers), Teams[_ClanNb].ColorizedName), 3000, 0, Sound, 0);
		}
		foreach(Spectator in Spectators)
		{
			declare MSG = "";
			switch(Spectator.User.Language)
			{
				case "pl": MSG = "Pozostało %1 żywych w zespole %2";
				case "fr": MSG = "%1 joueurs restant dans %2";
				case "ru": MSG = "%1 игроков перешли в %2";
				case "it": MSG = "Sono rimasti %1 viventi nella squadra %2";
				case "de": MSG = "%1 Spieler übrig in %2";
				default: MSG = "%1 players left in %2";
			}
			Message::SendStatusMessage(Spectator, TextLib::Compose(MSG,TextLib::ToText(_LeftPlayers), Teams[_ClanNb].ColorizedName), 3500, 0, Sound, 0);
		}
	}	
}