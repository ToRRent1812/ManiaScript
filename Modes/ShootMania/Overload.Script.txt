// Search and hack with dolars to get better weapon
#Extends "Modes/Shootmania/ShopCore.Script.txt"

#Const CompatibleMapTypes	"OverloadArena"
#Const Version				"2014-10-08"
#Const ScriptName			"Overload.Script.txt"

#Include "MathLib" as MathLib
#Include "TextLib" as TextLib
#Include "Libs/ST.Script.txt" as ST
#Include "Libs/Nadeo/Victory.Script.txt" as Victory
#Include "Libs/Nadeo/CustomUI.Script.txt" as CustomUI
#Include "Libs/Nadeo/ShootMania/SM.Script.txt" as SM
#Include "Libs/Nadeo/ShootMania/Map.Script.txt" as Map
#Include "Libs/Nadeo/ShootMania/Score.Script.txt" as Score
#Include "Libs/Nadeo/ShootMania/SpawnScreen.Script.txt" as SpawnScreen

#Setting S_RoundTime			105		as _("Round time in seconds")
#Setting S_PoleCaptureDuration	5		as _("Hacking time in seconds")

// Clublinks settings
#Setting S_UsePlayerClublinks	False	as _("Use players clublinks")	// Use the players clublinks, or otherwise use the default teams
#Setting S_ForceClublinkTeam1	""		as "<hidden>"	// Force the Clublink of team 1 (format: http://www.example.com/MyTeam.Club.xml)
#Setting S_ForceClublinkTeam2	""		as "<hidden>"	// Force the Clublink of team 2 (format: http://www.example.com/MyTeam.Club.xml)

#Const Description  _("RULES: Locate vulnerable point and do the overload to win the round.")

#Const C_BlueBot 				0
#Const C_RedBot 				0

declare Integer[Integer]			G_ClansMapPoints;		// Number of points cumulated on one map for each clan
declare Integer[Integer]			G_PlayersAlive;			// How many players are alive in specific team
declare Integer						G_Capturable; 			// Which checkpoint is capturable
declare Integer 					G_AttackingClan;		// Which clan is attacking
declare Integer 					G_LastProgressUpdate;	// Time of the last progrresion layer update
declare Integer 					G_LastSettingsUpdate; 	// Time of the last setting layer update
declare Integer 					G_LastTempUpdate;

// Globals caches the settings
declare Integer 					G_RoundTime;
declare Integer 					G_PoleCaptureDuration;
declare Integer 					G_MapPointsLimit;
declare Integer 					G_BuyTime;

***LogVersion***
***
MB_LogVersion(ScriptName, Version);
MB_LogVersion(SM::GetScriptName(), SM::GetScriptVersion());
MB_LogVersion(Map::GetScriptName(), Map::GetScriptVersion());
MB_LogVersion(CustomUI::GetScriptName(), CustomUI::GetScriptVersion());
MB_LogVersion(Score::GetScriptName(), Score::GetScriptVersion());
MB_LogVersion(Layers::GetScriptName(), Layers::GetScriptVersion());
MB_LogVersion(Message::GetScriptName(), Message::GetScriptVersion());
MB_LogVersion(SpawnScreen::GetScriptName(), SpawnScreen::GetScriptVersion());
MB_LogVersion(Rank::GetScriptName(), Rank::GetScriptVersion());
MB_LogVersion(ST::GetScriptName(), ST::GetScriptVersion());
MB_LogVersion(Toss::GetScriptName(), Toss::GetScriptVersion());
***

***InitServer***
***
MB_UseSectionRound		= True;
MB_UseSectionTurn		= False;
MB_UsePlayerClublinks	= S_UsePlayerClublinks;
***

***StartServer***
***
UseClans			= True;
UseProtectClanmates	= False;
UseLaserSkewering	= False;
UseAmmoBonusOnHit	= False;
UsePlayerTagging 	= True;

if(S_RoundTime < 30) G_RoundTime = 30;
else G_RoundTime = S_RoundTime;

if(S_PoleCaptureDuration < 2) G_PoleCaptureDuration = 2;
else G_PoleCaptureDuration = S_PoleCaptureDuration;

if(S_MapPointsLimit < 1) G_MapPointsLimit = 1;
else G_MapPointsLimit = S_MapPointsLimit;

if(S_BuyTime < 10) G_BuyTime = 10;
else G_BuyTime = S_BuyTime;

declare ModeName = "Overload";
declare ModeObjectives = TextLib::Compose(_("$<%1Access points: $>There are 3 Access points, only one is vulnerable.\n$<%1Attackers: $>Find vulnerable Access point and hack to win the round.\n$<%1Defenders: $>Protect vulnerable point by %2 sec. or eliminate attackers to win the round"), "$"^SpawnScreen::GetModeColor(), TextLib::ToText(S_RoundTime));
declare ModeConditions = TextLib::Compose(_("$<%11. $>A game is divided in rounds.\n$<%12. $>The first team with %2 points wins the map.\n$<%13. $>Before round you can buy equipment using money.\n$<%14. $>You can earn money by hit, headshot, kill, capture, win and loss."), "$"^SpawnScreen::GetModeColor(), TextLib::ToText(S_MapPointsLimit+1));

SpawnScreen::AddSubsection(_("Type"), _("Team versus Team"), 0.);
SpawnScreen::AddSubsection(_("Objectives"), ModeObjectives, 20.);
SpawnScreen::AddSubsection(_("Conditions"), ModeConditions, 55.);
SpawnScreen::CreatePrettyRules(ModeName);
ModeStatusMessage = _("RULES: Locate vulnerable point and do the overload to win the round.");
SM::SetupDefaultVisibility();

// Init movable elements
CustomUI::Load();
CustomUI::Add("PlayersList_1", <-160., 67.>, <46., 90.>, "top", "left");
CustomUI::Add("PlayersList_2", <160., 67.>, <46., 90.>, "top", "right");
CustomUI::Add("Overload_GaugeCapture", <0., -45.>, <130., 20.>, "center", "center");
CustomUI::Build();

// Create layers
Layers::Create("ProgressBar"); // Specific capture progress
Layers::Create("Markers"); // markers layer
Layers::Create("HUD"); // Hud layer when player is spawned
Layers::Create("CapturableInfo"); // Additional layer with informations during buying
Layers::Create("RulesReminder", UpdateLayerRulesReminder());
Layers::SetType("Markers", CUILayer::EUILayerType::Markers);
Layers::SetType("RulesReminder", CUILayer::EUILayerType::CutScene);
Layers::Attach("RulesReminder");
***					

***WhenCaptured***
***
if(LandmarkGauge.Sector.PlayersIds.count > 0)
{
	foreach (PlayerId in LandmarkGauge.Sector.PlayersIds) 
	{
		if (Players.existskey(PlayerId) && Players[PlayerId].Score != Null) 
		{
			declare CurrentCapGoals for Players[PlayerId].Score = 0;
			CurrentCapGoals += 1;
			declare UI <=> UIManager.GetUI(Players[PlayerId]);
			if(UI != Null)
			{
				declare netwrite Net_RoundRewards for UI = 0;
				Net_RoundRewards += C_CashForCapture;
			}	
			Score::AddPoints(Players[PlayerId], 5);	
		}
	}
}
Message::CleanBigMessages();
foreach(Player in Players)
{
	declare MSG = "";
	switch(Player.User.Language)
	{
		case "pl": MSG = TextLib::Compose(_("$<%1$> zhakowali punkt dostępu!"), Teams[G_AttackingClan-1].ColorizedName);
		default: MSG = TextLib::Compose(_("$<%1$> hacked the Access point!"), Teams[G_AttackingClan-1].ColorizedName);
	} 
	Message::SendBigMessage(Player, MSG, 3500, 0);
}	
foreach(Spectator in Spectators)
{
	declare MSG = "";
	switch(Spectator.User.Language)
	{
		case "pl": MSG = TextLib::Compose(_("$<%1$> zhakowali punkt dostępu!"), Teams[G_AttackingClan-1].ColorizedName);
		default: MSG = TextLib::Compose(_("$<%1$> hacked the Access point!"), Teams[G_AttackingClan-1].ColorizedName);
	} 
	Message::SendBigMessage(Spectator, MSG, 4000, 0);
}
Mode::PlaySound(CUIConfig::EUISound::Capture, 0);
RoundClanWinner = G_AttackingClan;
MB_StopRound = True;
***

***StartMatch***
***
// Reset clan scores
ClanScores[1] = 0;
ClanScores[2] = 0;
***

***InitMap***
***
declare Integer		ClanMapWinner;		// Clan who win the map
***

***StartMap***
***
// RANK
Rank::Load();
if(Rank::IsServerRanked(True)) ModeStatusMessage = _("RULES: Locate vulnerable point and do the overload to win the round.\nThis server is $f90RANKED");
else ModeStatusMessage = _("RULES: Locate vulnerable point and do the overload to win the round.\nThis server is $f30UNRANKED");
UIManager.UIAll.MarkersXML = "";
UIManager.UIAll.ScreenIn3dHideVersus = False;
UIManager.UIAll.ScreenIn3dHideScoreSummary = True;
G_ClansMapPoints	= [1 => 0, 2 => 0];
G_Capturable 		= 0;
G_AttackingClan 	= 1;
ClanMapWinner		= 0;
// RANK
foreach(Score in Scores)
{
	declare CurrentCapGoals for Score = 0;
	CurrentCapGoals = 0;
	declare CurrentMVP for Score = 0;
	CurrentMVP = 0;
	declare CurrentAcc for Score = 0;
	CurrentAcc = 0;
	declare StartAtRound for Score = 0;
	StartAtRound = 0;
	declare Laziness for Score = 0;
	Laziness = 0;
	declare Fired for Score = 0;
	Fired = 0;
	declare Hits for Score = 0;
	Hits = 0;
	declare CurrentKills for Score = 0;
	CurrentKills = 0;
	declare CurrentDeaths for Score = 0;
	CurrentDeaths = 0;

}
// Init scores
Score::MatchBegin();

// Init players
foreach (Player in Players)
{
	SetPlayerClan(Player, Player.RequestedClan);
	declare UI <=> UIManager.GetUI(Player);
	if(UI == Null) continue;
	declare netwrite Net_ServerWantReset for UI = False;
	Net_ServerWantReset = True;
}	

// Update the players clublinks
if (S_ForceClublinkTeam1 == "" && S_ForceClublinkTeam2 == "") Clublink::DefineTeamAuto();
else Clublink::DefineTeamFromUrl(S_ForceClublinkTeam1, S_ForceClublinkTeam2);
Clublink::SyncUpdate();

// Init UI
SM::SetupDefaultVisibility();
Message::CleanAllMessages();
ST::Load();
Clublink::Attach();
Clublink::SetSponsorsDisplay(False);
SC_UpdateHeader(G_ClansMapPoints[1], G_ClansMapPoints[2]);

// Debug
Users_SetNbFakeUsers(C_BlueBot, C_RedBot);

SM::UnspawnAllPlayers();
SC_WaitForPlayers();
***

***InitRound***
***
declare Integer RoundClanWinner;// Team, who win the round
declare Integer TempGoalNb;		// To stop looping
declare Integer BestRoundScore;	// The best RoundPoints score in round
declare CSmPlayer MVP;			// The best player in round
declare Integer Announce;		// Temp variable to prevent looping message
***

***StartRound***
***
TempGoalNb 				= 0;
RoundClanWinner 		= 0;
BestRoundScore 			= 0;
Announce				= 0;
MVP 					= Null;
G_LastProgressUpdate 	= 0;
G_LastSettingsUpdate 	= 0;
G_LastTempUpdate 		= 0;
G_Capturable 			= MathLib::Rand(1, 3);
Mode::Synchro_DoBarrier();
UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::Normal;
Victory::RoundBegin();
Score::RoundBegin();
InitGoals();
UIManager.UIAll.MarkersXML = "";
// If this is the first round on the map, launch players presentation and toss
if (MB_SectionRoundNb == 1) 
{
	SC_UpdateHeader(G_ClansMapPoints[1], G_ClansMapPoints[2]);
	MB_PlayersPresentationSequence(2500);

	MB_UseIntro = True;
	G_AttackingClan = SC_DoTheToss(0);
	ST::Build();
	ST::UpdateST(1, MB_SectionRoundNb, G_MapPointsLimit, S_FinalRoundExceptDraw);
}
UIManager.UIAll.UISequence = CUIConfig::EUISequence::EndRound;
UIManager.UIAll.UISequence_CanSkipIntroMT = True;
Message::CleanAllMessages();
Mode::PlaySound(CUIConfig::EUISound::StartRound, 0);
SC_UpdateHeader(G_ClansMapPoints[1], G_ClansMapPoints[2]);
UpdateBasesColors();
if(ServerShutdownRequested || MatchEndRequested) break;
Layers::Update("CapturableInfo", UpdateLayerCapturable(G_Capturable));
Layers::Attach("CapturableInfo");
SC_EnableBuyZone(G_BuyTime*1000, G_AttackingClan);
Layers::Detach("CapturableInfo");

// Init players and spawn ticket
foreach (Player in AllPlayers) 
{
	declare SpawnTicket for Player = 0;
	SpawnTicket = 1;
	ActionLoad(Player, CSmMode::EActionSlot::Slot_A, NullId);
	ActionBind(Player, CSmMode::EActionSlot::Slot_A, CSmMode::EActionInput::None);
	declare PrimaryWeapon for Player = 0;
	PrimaryWeapon = 0;
	declare UI <=> UIManager.GetUI(Player);
	if (UI != Null) 
	{ 
		declare netwrite Integer[Text] Net_PrimaryWeapons for UI;
		Net_PrimaryWeapons[Player.Login] = 0;
	}
	declare HasChangedClan for Player = False;
	declare NewSpectator for Player = False;
	SetPlayerClan(Player, Player.RequestedClan);
	HasChangedClan = False;
	NewSpectator = True;
}

foreach (Spectator in Spectators) {
	declare NewSpectator for Spectator = False;
	NewSpectator = False;
}

// Init spectator mode
foreach (Player in AllPlayers) 
{
	declare UI <=> UIManager.GetUI(Player);
	if (UI == Null) continue;
	Layers::Attach("HUD", Player);
	if (Player.RequestsSpectate) 
	{
		declare SpawnTicket for Player = 0;
		SpawnTicket = 0;
		UI.SpectatorForceCameraType = -1;
		UI.SpectatorForcedClan = -1;
	} 
	else 
	{
		UI.SpectatorForceCameraType = 1;
		UI.SpectatorForcedClan = Player.CurrentClan;
	}
}

// Update the players clublinks
if (S_ForceClublinkTeam1 == "" && S_ForceClublinkTeam2 == "") Clublink::DefineTeamAuto();
else Clublink::DefineTeamFromUrl(S_ForceClublinkTeam1, S_ForceClublinkTeam2);
Clublink::SyncUpdate();
CustomUI::Attach();
UIManager.UIAll.UISequence = CUIConfig::EUISequence::Playing;
Layers::Update("ProgressBar", UpdateLayerProgressBar());
Layers::Attach("ProgressBar");
Layers::Attach("Markers");
Layers::Update("HUD", UpdateLayerHUD());
UpdateMarker();
ST::UpdateST(1, MB_SectionRoundNb, G_MapPointsLimit, S_FinalRoundExceptDraw);
//MB_Log("G_Capturable = "^G_Capturable);

SC_SetRoundTimer(G_RoundTime);
***

***OnNewSpectator***
***
declare UI <=> UIManager.GetUI(Spectator);
if (UI != Null) {
	UI.SpectatorForcedClan		= -1;
	UI.SpectatorForceCameraType	= -1;
	//Layers::Detach("Shop", Spectator);
}
declare SpawnTicket for Spectator = 0;
SpawnTicket = 0;
***

***Yield***
***
Message::Loop();

foreach (Event in PendingEvents) 
{
	if(Event.Type == CSmModeEvent::EType::OnPlayerAdded)
	{
		if(Event.Player == Null) Discard(Event);
			
		/*declare Kicked = False;

		if(Rank::GetUserRank(Event.Player.User) < S_MinimumTierToPlay) Kicked = Admin_KickUser(Event.Player.User, TextLib::Compose(_("You need to have %1 or better to play on this server."), Rank::GetLevelName(S_MinimumTierToPlay)));
		if(Rank::GetUserRank(Event.Player.User) > S_MaximumTierToPlay) Kicked = Admin_KickUser(Event.Player.User, TextLib::Compose(_("Players with higher rank than %1 can't play on this server."), Rank::GetLevelName(S_MaximumTierToPlay)));
*/
		declare UI <=> UIManager.GetUI(Event.Player);
		if (UI != Null) 
		{
			UI.SpectatorForcedClan		= Event.Player.CurrentClan;
			UI.SpectatorForceCameraType	= 1;
			declare CurrentAcc for Event.Player.Score = 0;
			CurrentAcc = 0;
			declare Fired for Event.Player.Score = 0;
			Fired = 0;
			declare Hits for Event.Player.Score = 0;
			Hits = 0;
			declare CurrentKills for Event.Player.Score = 0;
			CurrentKills = 0;
			declare CurrentDeaths for Event.Player.Score = 0;
			CurrentDeaths = 0;
			declare CurrentCapGoals for Event.Player.Score = 0;
			CurrentCapGoals = 0;
			declare CurrentMVP for Event.Player.Score = 0;
			CurrentMVP = 0;
			declare StartAtRound for Event.Player.Score = 0;
			StartAtRound = MB_SectionRoundNb;
			declare netwrite Net_PrimWpn for UI = 0;
			Net_PrimWpn = 0;
			declare netwrite Net_SecWpn for UI = 0;
			Net_SecWpn = 0;
			declare netwrite Net_RoundRewards for UI = 0;
			Net_RoundRewards = 0;
		}
		PassOn(Event);
	}
}		
***

***PlayLoop***
***
declare PlayerCountA = [1 => 0, 2 => 0];
declare PlayerCountB = [1 => 0, 2 => 0];
declare PlayerCountC = [1 => 0, 2 => 0];
if(G_LastSettingsUpdate + 2000 < Now)
{
	G_LastSettingsUpdate = Now;

	ST::UpdateST(1, MB_SectionRoundNb, G_MapPointsLimit, S_FinalRoundExceptDraw);

	if(S_RoundTime < 20) G_RoundTime = 20;
	else G_RoundTime = S_RoundTime;

	if(S_PoleCaptureDuration < 2) G_PoleCaptureDuration = 2;
	else G_PoleCaptureDuration = S_PoleCaptureDuration;

	if(S_MapPointsLimit < 1) G_MapPointsLimit = 1;
	else G_MapPointsLimit = S_MapPointsLimit;
	
	if(PlayersNbTotal < 2) MB_StopRound = True;
}

// Unspawn and mark players changing clan
foreach (Player in Players) {
	if (!Player.IsFakePlayer && Player.SpawnStatus == CSmPlayer::ESpawnStatus::Spawned) {
		// if the player wants to change clan, then remove him from the current clan
		// it will be added to the correct clan at next respawn.
		if (Player.CurrentClan != 0 && Player.RequestedClan != Player.CurrentClan) {
			UnspawnPlayer(Player);
			declare HasChangedClan for Player = False;
			HasChangedClan = True;
			Layers::Detach("HUD", Player);
		}
	}
	if(!Player.IsFakePlayer && Player.RequestsSpectate)
	{
		declare NewSpectator for Player = False;
		NewSpectator = True;
		Layers::Detach("HUD", Player);
	}
}

// Don't let players going spectate respawn afterward
foreach (Spectator in Spectators) 
{
	declare NewSpectator for Spectator = False;
	if (NewSpectator) NewSpectator = False;
}
// Spawning players
if(RoundClanWinner == 0)
{
	foreach (Player in Players)
	{
		declare HasChangedClan for Player = False;
		declare NewSpectator for Player = True;
		if (Player.SpawnStatus == CSmPlayer::ESpawnStatus::NotSpawned && !HasChangedClan)
		{
			declare SecondaryWeapon for Player = 1;
			declare PrimaryWeapon for Player = 0;
			declare SpawnTicket for Player = 0;
			if(SpawnTicket <= 0) continue;
			if (Player.CurrentClan != 1 && Player.CurrentClan != 2) SetPlayerClan(Player, Player.RequestedClan);
			if (Player.RequestedClan == 1)
			{
				if(G_AttackingClan == 1)
				{
					Player.Armor = 300;
					Player.ArmorMax = 300;
					SM::SpawnPlayer(Player, Player.CurrentClan, Map::GetPlayerSpawn("SpawnAttack", 0), 3000);
					declare MSG2 = "";
					Message::SendBigMessage(Player, TextLib::Compose(_("|Imperative|Attack")), 7000, 0);
					
					switch(Player.User.Language)
					{
						case "pl": MSG2 = "$9d0Znajdź punkt podatny na atak i go zdobądź by wygrać rundę.";
						default: MSG2 = "$9d0Locate vulnerable Access point and do the overload to win the round.";	
					} 
					Message::SendStatusMessage(Player, MSG2, 7000, 0);
				}	
				else
				{
					Player.Armor = 300;
					Player.ArmorMax = 300;
					SM::SpawnPlayer(Player, Player.CurrentClan, Map::GetPlayerSpawn("SpawnDefence", 0), 3000);
					declare MSG2 = ""; 
					Message::SendBigMessage(Player, TextLib::Compose(_("|Imperative|Defend")), 7000, 0);
					
					switch(Player.User.Language)
					{
						case "pl": MSG2 = "$9d0Broń punktu podatnego na ataki do końca trwania rundy.";
						default: MSG2 = "$9d0Protect vulnerable Access point to end of the round.";	
					} 
					Message::SendStatusMessage(Player, MSG2, 7000, 0);
				}	
				SC_AddPlayerEQ(Player);
			}
			else if (Player.RequestedClan == 2)
			{
				if(G_AttackingClan == 2)
				{
					SM::SpawnPlayer(Player, Player.CurrentClan, Map::GetPlayerSpawn("SpawnAttack", 0), 3000);
					declare MSG2 = "";
					Message::SendBigMessage(Player, TextLib::Compose(_("|Imperative|Attack")), 7000, 0);
					
					switch(Player.User.Language)
					{
						case "pl": MSG2 = "$9d0Znajdź punkt podatny na atak i go zdobądź by wygrać rundę.";
						default: MSG2 = "$9d0Locate vulnerable Access point and do the overload to win the round.";	
					} 
					Message::SendStatusMessage(Player, MSG2, 7000, 0);
				}	
				else
				{
					SM::SpawnPlayer(Player, Player.CurrentClan, Map::GetPlayerSpawn("SpawnDefence", 0), 3000);
					declare MSG2 = "";
					Message::SendBigMessage(Player, TextLib::Compose(_("|Imperative|Defend")), 7000, 0);
					
					switch(Player.User.Language)
					{
						case "pl": MSG2 = "$9d0Broń punktu podatnego na ataki do końca trwania rundy.";
						default: MSG2 = "$9d0Protect vulnerable Access point to end of the round.";	
					} 
					Message::SendStatusMessage(Player, MSG2, 7000, 0);
				}	
				SC_AddPlayerEQ(Player);
			}
		}
	}		
}

// Timer management
if (G_RoundTime > 0) 
{
	// End of the round, attackers didn't capture checkpoint
	if (Now == EndTime) 
	{
		SM::UnspawnAllPlayers();
		Message::CleanBigMessages();
		Message::SendBigMessage(TextLib::Compose(_("Time limit reached!")), 4000, 0);
		Victory::SetRoundWinnerIfNoWinner(3-G_AttackingClan);
		RoundClanWinner = 3-G_AttackingClan;
		MB_StopRound = True;
	}
}

// Poles management
foreach (LandmarkGauge in MapLandmarks_Gauge) 
{
	if(LandmarkGauge.Sector != Null)
	{
		switch(LandmarkGauge.Tag)
		{
			case "Server A":
			{
				if (LandmarkGauge.Sector.PlayersIds.count > 0 && G_Capturable == 1) 
				{
					foreach (PlayerId in LandmarkGauge.Sector.PlayersIds) 
					{
						declare Player <=> Players[PlayerId];
						PlayerCountA[Player.CurrentClan] += 1;
					}
				}
			}
			case "Server B":
			{
				if (LandmarkGauge.Sector.PlayersIds.count > 0 && G_Capturable == 2) 
				{
					foreach (PlayerId in LandmarkGauge.Sector.PlayersIds) 
					{
						declare Player <=> Players[PlayerId];
						PlayerCountB[Player.CurrentClan] += 1;
					}
				}
			}
			case "Server C":
			{
				if (LandmarkGauge.Sector.PlayersIds.count > 0 && G_Capturable == 3) 
				{
					foreach (PlayerId in LandmarkGauge.Sector.PlayersIds) 
					{
						declare Player <=> Players[PlayerId];
						PlayerCountC[Player.CurrentClan] += 1;
					}
				}
			}
		}						
	}
}

foreach (LandmarkGauge in MapLandmarks_Gauge) 
{
	if(LandmarkGauge.Sector != Null)
	{
		if(LandmarkGauge.Tag == "Server A" && G_Capturable == 1)
		{
			// Capturing
			if (PlayerCountA[G_AttackingClan] > PlayerCountA[3-G_AttackingClan] && !LandmarkGauge.Gauge.Captured) LandmarkGauge.Gauge.Speed = PlayerCountA[G_AttackingClan];
			else LandmarkGauge.Gauge.Speed = 0;
			// Captured
			if (LandmarkGauge.Gauge.Value >= LandmarkGauge.Gauge.Max) 
			{
				LandmarkGauge.Gauge.Captured = True;
				---WhenCaptured---
			}
		}
		if(LandmarkGauge.Tag == "Server B" && G_Capturable == 2)
		{
			// Capturing
			if (PlayerCountB[G_AttackingClan] > PlayerCountB[3-G_AttackingClan] && !LandmarkGauge.Gauge.Captured) LandmarkGauge.Gauge.Speed = PlayerCountB[G_AttackingClan];
			else LandmarkGauge.Gauge.Speed = 0;
			// Captured
			if (LandmarkGauge.Gauge.Value >= LandmarkGauge.Gauge.Max) 
			{
				LandmarkGauge.Gauge.Captured = True;
				---WhenCaptured---
			}
		}
		if(LandmarkGauge.Tag == "Server C" && G_Capturable == 3)
		{
			// Capturing
			if (PlayerCountC[G_AttackingClan] > PlayerCountC[3-G_AttackingClan] && !LandmarkGauge.Gauge.Captured) LandmarkGauge.Gauge.Speed = PlayerCountC[G_AttackingClan];
			else LandmarkGauge.Gauge.Speed = 0;
			// Captured
			if (LandmarkGauge.Gauge.Value >= LandmarkGauge.Gauge.Max) 
			{
				LandmarkGauge.Gauge.Captured = True;
				---WhenCaptured---
			}
		}	
	}
}

if(G_LastProgressUpdate + 1000 < Now)
{
	G_LastProgressUpdate = Now;
	//Layers::Update("HUD", UpdateLayerHUD());

	G_PlayersAlive = [1 => 0, 2 => 0];
	
	foreach(Player in Players)
	{
		if(Player.Armor > 0 && Player.CurrentClan > 0) G_PlayersAlive[Player.CurrentClan] += 1;
		// Read or Init player statistics
		declare Fired for Player.Score = 0;
		declare Hits for Player.Score = 0;
		declare CurrentAcc for Player.Score = 0;
		if(Fired > 0) CurrentAcc = 100 * Hits / Fired;
		else CurrentAcc = 0;
		if(CurrentAcc > 100) CurrentAcc = MathLib::Rand(91, 98);
		if(CurrentAcc < 0) CurrentAcc = MathLib::Rand(91, 98);
		declare UI <=> UIManager.GetUI(Player);
		if(UI == Null) continue;
		if(!(Layers::IsMissing("Shop", Player))) Layers::Detach("Shop", Player);
	}	
	if(G_PlayersAlive[G_AttackingClan] <= 0)
	{
		Victory::SetRoundWinnerIfNoWinner(3-G_AttackingClan);
		RoundClanWinner = 3-G_AttackingClan;
		MB_StopRound = True;
		SC_AnnounceEliminationMessage(G_AttackingClan-1, 0);
	}
	else if(G_PlayersAlive[3-G_AttackingClan] <= 0 && Announce < 1)
	{
		Announce += 1;
		Message::SendBigMessage(TextLib::Compose(_("All defenders eliminated, capture the goal!")), 10000, 0, CUIConfig::EUISound::PhaseChange, 0);
		// Init spectator mode
		foreach (Player in AllPlayers) 
		{
			declare UI <=> UIManager.GetUI(Player);
			if (UI == Null) continue;
			UI.SpectatorForceCameraType = -1;
			UI.SpectatorForcedClan = -1;
		}	
	}
}

// Events
foreach (Event in PendingEvents) 
{
	switch(Event.Type)
	{
		case CSmModeEvent::EType::OnShoot:
		{
			if(Event.Shooter != Null)
			{
				declare Fired for Event.Shooter.Score = 0;
				Fired += 1;
			}
			else Discard(Event);
		}
		// Weapon switch via mouse scroll
		case CSmModeEvent::EType::OnPlayerRequestActionChange: 
		{
			if (Event.Player != Null) 
			{
				SC_CycleWeapon(Event.Player, Event.ActionChange);
				PassOn(Event);
			}
			else Discard(Event);
		}
		// On near miss
		case CSmModeEvent::EType::OnNearMiss:
		{
			---OnNearMiss---
		}
		case CSmModeEvent::EType::OnActionEvent:
		{
			if (Event.Player != Null)
			{
				SC_SwitchWeapon(Event.Player, Event.ActionInput);
				PassOn(Event);
			}
			else Discard(Event);
		}
		case CSmModeEvent::EType::OnArmorEmpty:
		{
			if(Event.Victim != Null && Event.Shooter != Null)
			{
				if (Event.Victim.Armor > 100)
				{
					declare SpawnTicket for Event.Victim = 0;
					SpawnTicket = 1;
				}
				else
				{
					Layers::Detach("HUD", Event.Victim);
					declare SpawnTicket for Event.Victim = 0;
					SpawnTicket = 0;
					declare CurrentKills for Event.Shooter.Score = 0;
					CurrentKills += 1;
					declare CurrentDeaths for Event.Victim.Score = 0;
					CurrentDeaths += 1;
					declare SUI <=> UIManager.GetUI(Event.Shooter);
					if (SUI != Null)
					{
						declare netwrite Net_RoundRewards for SUI = 0;
						Net_RoundRewards += C_CashForKill;
					}
					declare UI <=> UIManager.GetUI(Event.Victim);
					if (UI != Null) 
					{
						declare netwrite Net_ServerWantReset for UI = False;
						Net_ServerWantReset = True;
					}
					foreach(Player in Players)
					{
						declare UI <=> UIManager.GetUI(Player);
						if (UI != Null) 
						{
							declare netwrite Integer[Text] Net_PrimaryWeapons for UI;
							Net_PrimaryWeapons[Event.Victim.Login] = 0;
						}
					}
			
					if (G_PlayersAlive[Event.Victim.CurrentClan] > 1) 
					{
						declare PLeft = G_PlayersAlive[Event.Victim.CurrentClan]-1;
						if (PLeft <= 3) SC_AnnounceEliminationMessage(Event.Victim.CurrentClan-1, PLeft);
					}
				}	
				XmlRpc::OnArmorEmpty(Event);
				PassOn(Event);
			}
			else Discard(Event);	
		}
		case CSmModeEvent::EType::OnHit:
		{
			if(Event.Victim != Null && Event.Shooter != Null)
			{
				// Discard friendly fire
				if (Event.Shooter.CurrentClan == Event.Victim.CurrentClan) Discard(Event);
				else 
				{
					if(Event.WeaponNum == GetWeaponNum(CSmMode::EWeapon::Laser))
					{
						// Get distance
						declare Distance = MathLib::Distance(Event.Shooter.Position, Event.Victim.Position);
						SC_AnnounceHitDistance(Distance, Event.Shooter);
					}		
					if (Event.Shooter != Event.Victim)
					{
						declare Hits for Event.Shooter.Score = 0;
						Hits += 1;
						declare UI <=> UIManager.GetUI(Event.Shooter);
						if (UI != Null) 
						{
							declare netwrite Net_RoundRewards for UI = 0;
							Score::AddPoints(Event.Shooter, Event.Damage/100);
							Net_RoundRewards += C_CashForHit;
							---HeadshotFunctions---
							---AnnounceHeadshot---
						}
						if(Event.Victim.Armor - Event.Damage <= 0)
						{
							declare SpawnTicket for Event.Victim = 0;
							SpawnTicket = 0;
						}		
					}	
					XmlRpc::OnHit(Event);
					PassOn(Event);
				}
			}
			else Discard(Event);	
		}
		case CSmModeEvent::EType::OnActionCustomEvent:
		{
			if(Event.Victim != Null && Event.Shooter != Null)
			{
				// Discard friendly fire
				if (Event.Param1 == "damage" && Event.Shooter.CurrentClan == Event.Victim.CurrentClan) Discard(Event);
				else if(Event.Param1 == "damage" && Event.Victim != Event.Shooter) 
				{
					declare Damage = TextLib::ToInteger(Event.Param2[0]);
           			declare Points = Damage / 100;
					if(Damage < 100)
					{
						Points = 1;
						Damage = 100;
					}	
					declare Hits for Event.Shooter.Score = 0;
					Hits += 1;
					declare UI <=> UIManager.GetUI(Event.Shooter);
					if (UI != Null) 
					{
						declare netwrite Net_RoundRewards for UI = 0;
            			Net_RoundRewards += C_CashForHit;
						---HeadshotFunctions---
						---ActionMakerAnnounceHeadshot---
					}
           	 		RemovePlayerArmor(Event.Victim, Damage, Event.Shooter, Points);
           	 		Score::AddPoints(Event.Shooter, Points);
          			if(Event.Victim.Armor - Damage <= 0)
					{
						declare SpawnTicket for Event.Victim = 0;
						SpawnTicket = 0;
					}	
            		PassOn(Event);
       			}
			}
  			else Discard(Event);
		}
		case CSmModeEvent::EType::OnPlayerRequestRespawn:
		{
			if(Event.Player == Null) Discard(Event);
			declare Message = "";
			declare SpawnTicket for Event.Player = 0;
			SpawnTicket = 0;
			declare CurrentDeaths for Event.Player.Score = 0;
			CurrentDeaths += 1;
			Layers::Detach("HUD", Event.Player);

			declare UI <=> UIManager.GetUI(Event.Player);
			if (UI != Null) 
			{
				declare netwrite Net_ServerWantReset for UI = False;
				Net_ServerWantReset = True;
			}
			foreach(Player in Players)
			{
				declare UI <=> UIManager.GetUI(Player);
				if (UI != Null) 
				{
					declare netwrite Integer[Text] Net_PrimaryWeapons for UI;
					Net_PrimaryWeapons[Event.Player.Login] = 0;
				}
			}
			if(G_PlayersAlive[Event.Player.CurrentClan] > 1) 
			{
				declare PLeft = G_PlayersAlive[Event.Player.CurrentClan];
				if(PLeft <= 3) SC_AnnounceEliminationMessage(Event.Player.CurrentClan-1, PLeft);
	 		}

			XmlRpc::OnPlayerRequestRespawn(Event);
			PassOn(Event);
		}
		case CSmModeEvent::EType::OnCapture: Discard(Event);
		//default: PassOn(Event);
	}
}
***

***EndRound***
***
Layers::Detach("Markers");
UIManager.UIAll.MarkersXML = "";
// Search for MVP
foreach(Player in Players)
{
	if(Player.Score.RoundPoints > BestRoundScore && Player.Score.RoundPoints > 0)
	{
		BestRoundScore = Player.Score.RoundPoints;
		MVP = Player;
	}
	declare UI <=> UIManager.GetUI(Player);
	if (UI == Null) continue;
	UI.MarkersXML = "";
	Layers::Detach("HUD", Player);
}
if(MVP != Null && RoundClanWinner != 0)
{
	declare CurrentMVP for MVP.Score = 0;
	CurrentMVP += 1;
}
MB_Sleep(1500);
SM::UnspawnAllPlayers();
MB_Sleep(1000);
ST::UpdateST(1, MB_SectionRoundNb, G_MapPointsLimit, S_FinalRoundExceptDraw);
UIManager.UIAll.UISequence = CUIConfig::EUISequence::EndRound;
UIManager.UIAll.MarkersXML = "";
Victory::RoundEnd();
EndTime = -1;
//Give money for win/loss
if(RoundClanWinner > 0)
{
	G_ClansMapPoints[RoundClanWinner] += 1;
	foreach(Player in Players)
	{
		declare Laziness for Player.Score = 0;
		if(Player.Score.RoundPoints <= 5) Laziness -= 1;
		declare UI <=> UIManager.GetUI(Player);
		if(UI == Null) continue;
		declare netwrite Net_RoundRewards for UI = 0;
		if(Player.CurrentClan == RoundClanWinner) Net_RoundRewards += C_CashForWin;
		else if(Player.CurrentClan == 3-RoundClanWinner) Net_RoundRewards += C_CashForLoss;
	}
}	
Message::CleanAllMessages();
SC_UpdateHeader(G_ClansMapPoints[1], G_ClansMapPoints[2]);
SC_AnnounceRoundWin(RoundClanWinner);
if(RoundClanWinner > 0 && MVP != Null) Message::SendStatusMessage(TextLib::Compose(_("$fc0MVP:$g $<%1$>"), MVP.Name), 6500, 0, CUIConfig::EUISound::Silence, 1);
UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::ForcedVisible;
MB_Sleep(4000);
Score::RoundEnd();
if(MB_SectionRoundNb == G_MapPointsLimit*2)
{
	if(G_ClansMapPoints[1] > G_ClansMapPoints[2])
	{
		ClanMapWinner = 1;
		MB_StopMap = True;
	}
	else if(G_ClansMapPoints[2] > G_ClansMapPoints[1])
	{
		ClanMapWinner = 2;
		MB_StopMap = True;
	}
	else
	{
		if(!S_FinalRoundExceptDraw)
		{
			ClanMapWinner = 0;
			MB_StopMap = True;
		}
		else
		{
			G_MapPointsLimit = G_ClansMapPoints[1]+1;
		}
	}
}
if(G_ClansMapPoints[1] > G_MapPointsLimit)
{
	ClanMapWinner = 1;
	MB_StopMap = True;
}
else if(G_ClansMapPoints[2] > G_MapPointsLimit)
{
	ClanMapWinner = 2;
	MB_StopMap = True;
}
if(MB_SectionRoundNb == G_MapPointsLimit)
{
	G_AttackingClan = 3 - G_AttackingClan;
	---AnnounceHalfTime---
}
else if(MB_SectionRoundNb == G_MapPointsLimit*2 && S_FinalRoundExceptDraw && ClanMapWinner == 0)
{
	G_AttackingClan = 3 - G_AttackingClan;
	---AnnounceFinalRound---
}
MB_Sleep(5000);
UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::Normal;
Message::CleanAllMessages();
if(PlayersNbTotal < 2) SC_WaitForPlayers();
***

***EndMap***
***
Victory::MatchEnd();
Message::SendStatusMessage(TextLib::Compose(_("Map result: %1 %2 - %3 %4"),Teams[0].ColorizedName,TextLib::ToText(G_ClansMapPoints[1]),TextLib::ToText(G_ClansMapPoints[2]),Teams[1].ColorizedName), 6000, 0, CUIConfig::EUISound::EndRound, 0);
if (ClanMapWinner > 0) Message::SendBigMessage(TextLib::Compose(_("%1 wins the map!"), Teams[ClanMapWinner - 1].ColorizedName), 6000, 0);
else Message::SendBigMessage(TextLib::Compose(_("|Match|Draw")), 6000, 0, CUIConfig::EUISound::Silence, 0);
UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::ForcedVisible;
MB_Sleep(6000);
UIManager.UIAll.UISequence = CUIConfig::EUISequence::Podium;
Rank::EndMap(MB_SectionRoundNb, G_ClansMapPoints[1], G_ClansMapPoints[2]);
ST::UpdateST(2, MB_SectionRoundNb, G_MapPointsLimit, S_FinalRoundExceptDraw);
MB_Sleep(6000);
foreach(Player in AllPlayers)
{
	declare UI <=> UIManager.GetUI(Player);
	if (UI != Null) 
	{
		declare Fired for Player.Score = 0;
		declare Hits for Player.Score = 0;
		declare CurrentKills for Player.Score = 0;
		declare CurrentDeaths for Player.Score = 0;
		declare CurrentCapGoals for Player.Score = 0;
		// Collect data to stats page if server is ranked
		if(Rank::IsServerRanked(False) && PlayersNbTotal >= 4)
		{
			declare persistent Overload_AllKills 		for Player.User = 0;
			declare persistent Overload_AllDeaths 		for Player.User = 0;
			declare persistent Overload_AllFired 		for Player.User = 0;
			declare persistent Overload_AllHits		 	for Player.User = 0;
			declare persistent Overload_AllGoals 		for Player.User = 0;
			declare persistent Overload_MapsPlayed 		for Player.User = 0;
			Overload_AllKills += CurrentKills;
			Overload_AllDeaths += CurrentDeaths;
			Overload_AllFired += Fired;
			Overload_AllHits += Hits;
			Overload_AllGoals += CurrentCapGoals;
			Overload_MapsPlayed += 1;
		}
		declare CurrentAcc for Player.Score = 0;
		CurrentAcc = 0;
		Fired = 0;
		Hits = 0;
		CurrentKills = 0;
		CurrentDeaths = 0;
		CurrentCapGoals = 0;
		declare CurrentMVP for Player.Score = 0;
		CurrentMVP = 0;
		declare StartAtRound for Player.Score = 0;
		StartAtRound = 0;
		declare netwrite Net_PrimWpn for UI = 0;
		Net_PrimWpn = 0;
		declare netwrite Net_SecWpn for UI = 0;
		Net_SecWpn = 0;
		declare netwrite Net_RoundRewards for UI = 0;
		Net_RoundRewards = 0;
	}
}
UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::Normal;
ST::Unload();
Rank::Detach();
Message::CleanAllMessages();
SC_VoteForNextMap();
***

***EndServer***
***
ST::Unload();
Rank::Unload();
Layers::Destroy("ProgressBar");
Layers::Destroy("RulesReminder");
Layers::Destroy("HUD");
CustomUI::Unload();
Layers::Destroy("Markers");
SpawnScreen::DestroyRules();
***

Void InitGoals() 
{
	foreach (LandmarkGauge in MapLandmarks_Gauge) 
	{
		if(LandmarkGauge.Sector != Null)
		{
			switch(LandmarkGauge.Tag)
			{
				case "Server A":
				{
					LandmarkGauge.Gauge.Max		= G_PoleCaptureDuration * 1000;
					LandmarkGauge.Gauge.Value	= 0;
					LandmarkGauge.Gauge.Speed	= 0;
					LandmarkGauge.Gauge.Clan 	= 0;
					LandmarkGauge.Gauge.Captured= False;
				}
				case "Server B":
				{
					LandmarkGauge.Gauge.Max		= G_PoleCaptureDuration * 1000;
					LandmarkGauge.Gauge.Value	= 0;
					LandmarkGauge.Gauge.Speed	= 0;
					LandmarkGauge.Gauge.Clan 	= 0;
					LandmarkGauge.Gauge.Captured= False;
				}
				case "Server C":
				{
					LandmarkGauge.Gauge.Max		= G_PoleCaptureDuration * 1000;
					LandmarkGauge.Gauge.Value	= 0;
					LandmarkGauge.Gauge.Speed	= 0;
					LandmarkGauge.Gauge.Clan 	= 0;
					LandmarkGauge.Gauge.Captured= False;
				}
			}
		}	
	}
}

Void UpdateBasesColors() {
	foreach (Base in MapBases) {
		Base.Clan = 0;
		Base.IsActive = True;
	}
	
	declare UpdatedBases = Ident[];
	
	foreach (Spawn in MapLandmarks_PlayerSpawn) 
	{
		if (Spawn.Base == Null) continue;
		
		if(G_AttackingClan == 2)
		{
			switch(Spawn.Tag)
			{
				case "SpawnAttack": Spawn.Base.Clan = 2;
				case "SpawnDefence": Spawn.Base.Clan = 1;
			}	
		}
		else
		{
			switch(Spawn.Tag)
			{
				case "SpawnAttack": Spawn.Base.Clan = 1;
				case "SpawnDefence": Spawn.Base.Clan = 2;
			}
		}
		Spawn.Base.IsActive = True;
		UpdatedBases.add(Spawn.Base.Id);
	}
	
	foreach (Pole in MapLandmarks_Gauge)
	{
		if (Pole.Base != Null) {
			if (!UpdatedBases.exists(Pole.Base.Id)) {
				Pole.Base.Clan = 3-G_AttackingClan;
				UpdatedBases.add(Pole.Base.Id);
			} else if (Pole.Base.Clan != 3-G_AttackingClan) {
				Pole.Base.Clan = G_AttackingClan;
			}
		}
	}
}

Text UpdateLayerHUD()
{
	return """
<manialink version="1" name="Overload:Player HUD">
<frame hidden="1" id="Frame_Overlay">
	<label posn="-65 -70 1" text="1: -" textsize="1" halign="left" id="Label_Primary"/>
	<label posn="-65 -74 1" text="2: -" textsize="1" halign="left" id="Label_Secondary"/>
	<label posn="52 -70 1" text="0" textsize="4" halign="right" style="TextRaceChrono" id="Label_Cash"/>
	<label posn="58 -70 1" text="$9f0$$" textsize="4" halign="right"/>
	<label posn="0 -62 1" text="Function" style="TextTitle3" textsize="3" halign="center" id="Label_Role"/>
</frame>
<script><!--	
main()
{
	declare Frame_Overlay <=> (Page.GetFirstChild("Frame_Overlay") as CMlFrame);
	declare Label_Primary <=> (Page.GetFirstChild("Label_Primary") as CMlLabel);
	declare Label_Secondary <=> (Page.GetFirstChild("Label_Secondary") as CMlLabel);
	declare Label_Cash <=> (Page.GetFirstChild("Label_Cash") as CMlLabel);
	declare Label_Role <=> (Page.GetFirstChild("Label_Role") as CMlLabel);
	while(True)
	{
		yield;
		if(InputPlayer == Null) continue;
		if(InputPlayer.Armor > 0)
		{			
			Frame_Overlay.Visible = True;
			declare netwrite Net_Cash for UI = {{{S_StartCash}}};
			declare netread Net_RoundRewards for UI = 0;
			Label_Cash.Value = Net_Cash+Net_RoundRewards^"";
			if(InputPlayer.CurrentClan == {{{G_AttackingClan}}}) Label_Role.SetText(_("|Imperative|Attack"));
			else Label_Role.SetText(_("|Imperative|Defend")); 

			declare netread Integer[Text] Net_PrimaryWeapons for UI;
			if(Net_PrimaryWeapons.existskey(InputPlayer.Login))
			{
				switch(Net_PrimaryWeapons[InputPlayer.Login])
				{
					case 1: Label_Primary.Value = "1: Laser";
					case 2: Label_Primary.Value = "1: Plasma Gun";
					case 3: Label_Primary.Value = "1: Grenades";
					case 4: Label_Primary.Value = "1: Nucleus";
					case 5: Label_Primary.Value = "1: Shotgun";
					case 6: Label_Primary.Value = "1: Blow Bomb";
					default: Label_Primary.Value = "1: -";
				}
			}	
			declare netread Integer[Text] Net_SecondaryWeapons for UI;
			if(Net_SecondaryWeapons.existskey(InputPlayer.Login))
			{
				switch(Net_SecondaryWeapons[InputPlayer.Login])
				{
					case 1: Label_Secondary.Value = "2: Rockets";
					case 2: Label_Secondary.Value = "2: Bouncing Rockets";
					case 3: Label_Secondary.Value = "2: Electric Pistol";
					default: Label_Secondary.Value = "2: -";
				}
			}
			else Label_Secondary.Value = "2: -";
		}
		else Frame_Overlay.Visible = False;		
	}
}
--></script>
</manialink>
	""";
}

Void UpdateMarker()
{
	foreach(Player in Players)
	{
		declare UI <=> UIManager.GetUI(Player);
		if (UI == Null) continue;
		declare PlayerManialink for Player = "";
		PlayerManialink = "";

		foreach (Goal in MapLandmarks_Gauge) 
		{
			declare PosX = Goal.Position.X;
			declare PosY = Goal.Position.Y + 0.3;
			declare PosZ = Goal.Position.Z;
			if (Goal.Tag == "Server A") 
			{
				if(Player.CurrentClan == G_AttackingClan) PlayerManialink ^= """<marker label="$oA" pos="{{{PosX}}} {{{PosY}}} {{{PosZ}}}" hudvisibility="Always" />""";
				else if(G_Capturable == 1) PlayerManialink ^= """<marker label="$oA $z- $f30Vulnerable" pos="{{{PosX}}} {{{PosY}}} {{{PosZ}}}" hudvisibility="Always" />""";
				else PlayerManialink ^= """<marker label="$oA $z- $9f0Safe" pos="{{{PosX}}} {{{PosY}}} {{{PosZ}}}" hudvisibility="Always" />""";
			} 
			else if (Goal.Tag == "Server B") 
			{
				if(Player.CurrentClan == G_AttackingClan) PlayerManialink ^= """<marker label="$oB" pos="{{{PosX}}} {{{PosY}}} {{{PosZ}}}" hudvisibility="Always" />""";
				else if(G_Capturable == 2) PlayerManialink ^= """<marker label="$oB $z- $f30Vulnerable" pos="{{{PosX}}} {{{PosY}}} {{{PosZ}}}" hudvisibility="Always" />""";
				else PlayerManialink ^= """<marker label="$oB $z- $9f0Safe" pos="{{{PosX}}} {{{PosY}}} {{{PosZ}}}" hudvisibility="Always" />""";
			}
			else if (Goal.Tag == "Server C") 
			{
				if(Player.CurrentClan == G_AttackingClan) PlayerManialink ^= """<marker label="$oC" pos="{{{PosX}}} {{{PosY}}} {{{PosZ}}}" hudvisibility="Always" />""";
				else if(G_Capturable == 3) PlayerManialink ^= """<marker label="$oC $z- $f30Vulnerable" pos="{{{PosX}}} {{{PosY}}} {{{PosZ}}}" hudvisibility="Always" />""";
				else PlayerManialink ^= """<marker label="$oC $z- $9f0Safe" pos="{{{PosX}}} {{{PosY}}} {{{PosZ}}}" hudvisibility="Always" />""";
			}
		}

		UI.MarkersXML = PlayerManialink;
	}
	foreach(Spectator in Spectators)
	{
		declare UI <=> UIManager.GetUI(Spectator);
		if (UI == Null) continue;
		declare PlayerManialink for Spectator = "";
		PlayerManialink = "";

		foreach (Goal in MapLandmarks_Gauge) 
		{
			declare PosX = Goal.Position.X;
			declare PosY = Goal.Position.Y + 0.3;
			declare PosZ = Goal.Position.Z;
			if (Goal.Tag == "Server A") 
			{
				if(G_Capturable == 1) PlayerManialink ^= """<marker label="$oA $z- $f30Vulnerable" pos="{{{PosX}}} {{{PosY}}} {{{PosZ}}}" hudvisibility="Always" />""";
				else PlayerManialink ^= """<marker label="$oA $z- $9f0Safe" pos="{{{PosX}}} {{{PosY}}} {{{PosZ}}}" hudvisibility="Always" />""";
			} 
			else if (Goal.Tag == "Server B") 
			{
				if(G_Capturable == 2) PlayerManialink ^= """<marker label="$oB $z- $f30Vulnerable" pos="{{{PosX}}} {{{PosY}}} {{{PosZ}}}" hudvisibility="Always" />""";
				else PlayerManialink ^= """<marker label="$oB $z- $9f0Safe" pos="{{{PosX}}} {{{PosY}}} {{{PosZ}}}" hudvisibility="Always" />""";
			}
			else if (Goal.Tag == "Server C") 
			{
				if(G_Capturable == 3) PlayerManialink ^= """<marker label="$oC $z- $f30Vulnerable" pos="{{{PosX}}} {{{PosY}}} {{{PosZ}}}" hudvisibility="Always" />""";
				else PlayerManialink ^= """<marker label="$oC $z- $9f0Safe" pos="{{{PosX}}} {{{PosY}}} {{{PosZ}}}" hudvisibility="Always" />""";
			}
		}

		UI.MarkersXML = PlayerManialink;
	}
}

Text UpdateLayerRulesReminder() {
	declare Text HighlightColor		= "f90";
	
	declare Text TitleText 			= TextLib::Compose(_("Welcome to %1!"), "Overload");
	
	return """
<manialink version="1" name="Overload:Rules Reminder">
<dico>
   <language id="en">
    	<rule1>- Map contain 3 Access points, only one is vulnerable.</rule1>
    	<rule2>$f70Attackers:$g Locate vulnerable point and capture to do overload.</rule2>
    	<rule3>$f70Defenders:$g Protect vulnerable point to end of the round.</rule3>
    	<rule4>- Before round, you can buy equipment in the shop.</rule4>
   </language>
   <language id="pl">
    	<rule1>- Mapa zawiera 3 punkty dostępu, tylko jeden jest podatny na atak.(vulnerable)</rule1>
    	<rule2>$f70Atakujący:$g Znajdź punkt podatny na atak i go zdobądź.</rule2>
    	<rule3>$f70Obrońcy:$g Chroń podatny na ataki punkt do końca trwania rundy</rule3>
    	<rule4>- Przed rozpoczęciem rundy, możesz kupić ekwipunek w sklepie</rule4>
   </language>
</dico>
<frame id="RulesReminderMainFrame" hidden="true" posn="0 13 100" >
	<quad posn="0 25 0" sizen="162 70" bgcolor="FFFA" image="{{{C_ImgModeDir}}}/WelcomeBg.dds" halign="center" valign="center"/>
	<label posn="-71 46 1" sizen="86 5" text="{{{TitleText}}}" textsize="4" textcolor="{{{HighlightColor}}}" style="TextValueSmallSm"/>
	<label posn="-73 39 1" sizen="146 26" textid="rule1"/>
	<label posn="-73 33 1" sizen="146 26" textid="rule2"/>
	<label posn="-73 27 1" sizen="146 26" textid="rule3"/>
	<label posn="-73 21 1" sizen="146 26" textid="rule4"/>
	<label posn="0 12 1" halign="center" text="{{{TextLib::Compose(_("Press '$<%1F1$>' to close this window."), "$"^HighlightColor)}}}" textsize="3" />
</frame>
<script><!--
	while(InputPlayer == Null) yield;

	declare RulesReminderMainFrame 	<=> (Page.GetFirstChild("RulesReminderMainFrame") as CMlFrame);
	
	while(True) {
		yield;
		
		RulesReminderMainFrame.Show();
		
		foreach(Event in PendingEvents) {
			switch(Event.Type){
				case CMlEvent::Type::KeyPress: {
					if(Event.CharPressed == "2424832" ) { // F1
						RulesReminderMainFrame.Visible = !RulesReminderMainFrame.Visible;
						return; // End of this behavior
					}
				}
			}
		}
	}
--></script>
</manialink>
""";
}

// Build capture progress layer
Text UpdateLayerProgressBar()
{
	declare Text ML = "";
	ML = """
<manialink version="1" name="Overload:Real-Time Progress Bar">
<dico>
   <language id="en">
      <label0>Loading data...</label0>
      <label1>Hacking...</label1>
      <label2>Wrong point, check another one.</label2>
      <label3>It's safe, protect vulnerable Access point.</label3>
	  <label4>Protect this Access point.</label4>
	  <label5>Blocked...</label5>
   </language>
   <language id="pl">
      <label0>Ładowanie...</label0>
      <label1>Hakowanie...</label1>
      <label2>Zły punkt, znajdź podatny na atak.</label2>
      <label3>Ten punkt jest bezpieczny, chroń punkt podatny na ataki.</label3>
	  <label4>Broń tego punktu przed atakami.</label4>
	  <label5>Sporne...</label5>
   </language>
</dico>
	<frame class="LibCustomUI_Module" id="Overload_GaugeCapture">
		<frame posn="0 -46" id="Frame_Capture">
			<quad posn="0 0 2" sizen="128 20" halign="center" valign="center" image="{{{C_ImgModeDir}}}/Structure.dds" />
			<label posn="0 -2.5 3" halign="center" textsize="3" textemboss="1" textprefix="$bbb" textid="label0" id="Label_Goal" style="TextButtonBig"/>
			<label posn="0 13 3" halign="center" textsize="3" textemboss="1" style="TextCreditsTitle" textid="label1" hidden="1" textprefix="$o" id="Label_Info_1"/>
			<label posn="0 13 3" halign="center" textsize="3" textemboss="1" style="TextCreditsTitle" textid="label2" hidden="1" textprefix="$o" id="Label_Info_2"/>
			<label posn="0 13 3" halign="center" textsize="3" textemboss="1" style="TextCreditsTitle" textid="label3" hidden="1" textprefix="$o" id="Label_Info_3"/>
			<label posn="0 13 3" halign="center" textsize="3" textemboss="1" style="TextCreditsTitle" textid="label4" hidden="1" textprefix="$o" id="Label_Info_4"/>
			<label posn="0 13 3" halign="center" textsize="3" textemboss="1" style="TextCreditsTitle" textid="label5" hidden="1" textprefix="$o" id="Label_Info_5"/>
			<gauge posn="0 8 2" sizen="124 10.4" halign="center" style="EnergyBar" drawbg="1" drawblockbg="1" id="Gauge_Capture" />
		</frame>
	</frame>	
<script><!--
#Include "MathLib" as ML
main() 
{
	declare Frame_Capture 	<=> (Page.GetFirstChild("Frame_Capture") 	as CMlFrame);
	declare Label_Info_1	<=> (Page.GetFirstChild("Label_Info_1")		as CMlLabel);
	declare Label_Info_2	<=> (Page.GetFirstChild("Label_Info_2")		as CMlLabel);
	declare Label_Info_3	<=> (Page.GetFirstChild("Label_Info_3")		as CMlLabel);
	declare Label_Info_4	<=> (Page.GetFirstChild("Label_Info_4")		as CMlLabel);
	declare Label_Info_5	<=> (Page.GetFirstChild("Label_Info_5")		as CMlLabel);
	declare Label_Goal 		<=> (Page.GetFirstChild("Label_Goal") 		as CMlLabel);
	declare Gauge_Capture 	<=> (Page.GetFirstChild("Gauge_Capture") 	as CMlGauge);
	{{{CustomUI::InjectMLInit()}}}
	while (True) 
	{
		yield;
		if (InputPlayer == Null) continue;
		if (!PageIsVisible) continue;
		
		{{{CustomUI::InjectMLLoop()}}}
		
		Label_Info_1.Hide();
		Label_Info_2.Hide();
		Label_Info_3.Hide();	
		Label_Info_4.Hide();
		Label_Info_5.Hide();
		
		if (InputPlayer.SpawnStatus == CSmPlayer::ESpawnStatus::Spawned && InputPlayer.CapturedLandmark != Null && InputPlayer.CapturedLandmark.Gauge != Null && (InputPlayer.CapturedLandmark.Tag == "Server A" || InputPlayer.CapturedLandmark.Tag == "Server B" || InputPlayer.CapturedLandmark.Tag == "Server C")) 
		{
			if (!Frame_Capture.Visible) Frame_Capture.Visible = True;
			Gauge_Capture.Ratio = InputPlayer.CapturedLandmark.Gauge.ValueReal;
			Gauge_Capture.Clan = InputPlayer.CurrentClan;
			Label_Goal.Value = "$dda"^ML::FloorInteger(InputPlayer.CapturedLandmark.Gauge.ValueReal * 100.)^"%";
			if(InputPlayer.CapturedLandmark.Gauge.Speed == 0)
			{
				if(InputPlayer.CurrentClan != {{{G_AttackingClan}}})
				{
					switch(InputPlayer.CapturedLandmark.Tag)
					{
						case "Server A":
						{
							if({{{G_Capturable}}} == 1)
							{
								Label_Info_1.Hide();
								Label_Info_2.Hide();
								Label_Info_3.Hide();		
								Label_Info_4.Show();
								Label_Info_5.Hide();
							}
							else
							{
								Label_Info_1.Hide();
								Label_Info_2.Hide();
								Label_Info_3.Show();		
								Label_Info_4.Hide();
								Label_Info_5.Hide();
							}
						}
						case "Server B":
						{
							if({{{G_Capturable}}} == 2)
							{
								Label_Info_1.Hide();
								Label_Info_2.Hide();
								Label_Info_3.Hide();		
								Label_Info_4.Show();
								Label_Info_5.Hide();
							}
							else
							{
								Label_Info_1.Hide();
								Label_Info_2.Hide();
								Label_Info_3.Show();		
								Label_Info_4.Hide();
								Label_Info_5.Hide();
							}
						}
						case "Server C":
						{
							if({{{G_Capturable}}} == 3)
							{
								Label_Info_1.Hide();
								Label_Info_2.Hide();
								Label_Info_3.Hide();		
								Label_Info_4.Show();
								Label_Info_5.Hide();
							}
							else
							{
								Label_Info_1.Hide();
								Label_Info_2.Hide();
								Label_Info_3.Show();		
								Label_Info_4.Hide();
								Label_Info_5.Hide();
							}
						}
					}
				}	
				else
				{
					switch(InputPlayer.CapturedLandmark.Tag)
					{
						case "Server A":
						{
							if({{{G_Capturable}}} == 1)
							{
								Label_Info_1.Hide();
								Label_Info_2.Hide();
								Label_Info_3.Hide();		
								Label_Info_4.Hide();
								Label_Info_5.Show();
							}
							else
							{
								Label_Info_1.Hide();
								Label_Info_2.Show();
								Label_Info_3.Hide();		
								Label_Info_4.Hide();
								Label_Info_5.Hide();
							}
						}
						case "Server B":
						{
							if({{{G_Capturable}}} == 2)
							{
								Label_Info_1.Hide();
								Label_Info_2.Hide();
								Label_Info_3.Hide();		
								Label_Info_4.Hide();
								Label_Info_5.Show();
							}
							else
							{
								Label_Info_1.Hide();
								Label_Info_2.Show();
								Label_Info_3.Hide();		
								Label_Info_4.Hide();
								Label_Info_5.Hide();
							}
						}
						case "Server C":
						{
							if({{{G_Capturable}}} == 3)
							{
								Label_Info_1.Hide();
								Label_Info_2.Hide();
								Label_Info_3.Hide();		
								Label_Info_4.Hide();
								Label_Info_5.Show();
							}
							else
							{
								Label_Info_1.Hide();
								Label_Info_2.Show();
								Label_Info_3.Hide();		
								Label_Info_4.Hide();
								Label_Info_5.Hide();
							}
						}
					}
				}
			}
			else if(InputPlayer.CapturedLandmark.Gauge.Speed > 1)
			{
				Label_Info_1.Show();
				Label_Info_2.Hide();
				Label_Info_3.Hide();		
				Label_Info_4.Hide();
			}

		} 
		else if (Frame_Capture.Visible) 
		{
			Frame_Capture.Visible = False;
		}
	}
}
--></script>
</manialink>	
""";
	
	return ML;	
}

Text GetLetterFromNumber(Integer _Number)
{
	declare Result = "";
	switch(_Number)
	{
		case 1: Result = "$o$fa0A";
		case 2: Result = "$o$fa0B";
		case 3: Result = "$o$fa0C";
		default: Result = "";
	}
	return Result;
}

Text UpdateLayerCapturable(Integer _Capturable)
{
	return """
<manialink version="1" name="Overload:Capturable Info Panel">
<dico>
   <language id="en">
    	<info>Access point vulnerable in this round</info>
   </language>
   <language id="pl">
    	<info>Punkt podatny na ataki w tej rundzie</info>
   </language>
</dico>
<frame posn="0 -75 0" id="Frame_Cap" hidden="1">
	<label posn="0 2 0" sizen="110 5" halign="center" style="TextTitle3" textid="info" textsize="4" />
	<label posn="0 -5 0" halign="center" text="{{{GetLetterFromNumber(_Capturable)}}}" textsize="9" />
</frame>
<script><!--
main()
{
	declare Frame_Cap <=> (Page.GetFirstChild("Frame_Cap") 	as CMlFrame);
	while(True)
	{
		yield;
		if (InputPlayer == Null) continue;
		if (!PageIsVisible) continue;
		
		if(InputPlayer.CurrentClan == {{{G_AttackingClan}}}) Frame_Cap.Hide();
		else Frame_Cap.Show();
	}
	
}
--></script>
</manialink>
""";
}