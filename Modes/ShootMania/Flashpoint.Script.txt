#Extends "Modes/Shootmania/LoadoutsTools.Script.txt"

#Const CompatibleMapTypes	"FlashpointArena"
#Const Version				"2014-08-16"
#Const ScriptName			"Flashpoint.Script.txt"

#Include "MathLib" as MathLib
#Include "TextLib" as TextLib
//#Include "Libs/Vote.Script.txt" as Draft
#Include "Libs/MiniMap2.Script.txt" as MiniMap
//#Include "Libs/Nadeo/Layers2.Script.txt" as Layers
//#Include "Libs/Nadeo/Message.Script.txt" as Message
#Include "Libs/Nadeo/Victory.Script.txt" as Victory
//#Include "Libs/Nadeo/Sound.Script.txt" as Sound
#Include "Libs/Nadeo/CustomUI.Script.txt" as CustomUI
#Include "Libs/Nadeo/ShootMania/SM.Script.txt" as SM
#Include "Libs/Nadeo/ShootMania/Map.Script.txt" as Map
#Include "Libs/Nadeo/ShootMania/Score.Script.txt" as Score
#Include "Libs/Nadeo/ShootMania/SpawnScreen.Script.txt" as SpawnScreen

#Setting S_RoundTime			180		as _("Basic round time")
#Setting S_RoundTimeBonus		20		as _("Round time bonus when someone captured the goal")
#Setting S_PoleCaptureDuration	2		as _("Basic duration of the pole capture")
#Setting S_CheckpointDuration	60 		as _("Duration of energy checkpoint decapture")
#Setting S_TicketReduction		5		as _("How much percent of energy cost spawn ticket")
/*#Setting S_MapPointsLimit		3		as _("Number of rounds to make half-time")
#Setting S_ClassSelectionTime	15		as _("Time to choose basic loadout before round")
#Setting S_FinalRoundExceptDraw	False	as _("Use additional round to determine map winner")*/
#Setting S_PlayerArmor 			5 		as _("Number of armors per player")
#Setting S_ObjectDetector		40 		as _("Objects markers detection distance (0 to disable)")
#Setting S_ItemSpawnTime		30 		as _("Number of seconds to spawn items after pick-up")
#Setting S_BlueBot 				0 		as _("Number of blue test bots")
#Setting S_RedBot 				0 		as _("Number of red test bots")
//#Setting S_UseNextMapVote		True	as "<hidden>"		
// Clublinks settings
#Setting S_UsePlayerClublinks	False	as _("Use players clublinks")	// Use the players clublinks, or otherwise use the default teams
#Setting S_ForceClublinkTeam1	""		as "<hidden>"	// Force the Clublink of team 1 (format: http://www.example.com/MyTeam.Club.xml)
#Setting S_ForceClublinkTeam2	""		as "<hidden>"	// Force the Clublink of team 2 (format: http://www.example.com/MyTeam.Club.xml)

/*#Const C_ImgBaseDir				"file://Media/Manialinks/Shootmania/Common/"
#Const C_ImgModeDir				"file://Media/Manialinks/Shootmania/Common/FireFight"*/

/*#Const C_RocketsAmmo			4 // rockets
#Const C_BRocketsAmmo			3 // bouncing rockets
#Const C_PistolAmmo 			6 // Electric Pistol

#Const C_StaminaWith1Weapon 	1.0
#Const C_SpeedWith1Weapon 		1.0
#Const C_StaminaWith2Weapons 	0.7
#Const C_SpeedWith2Weapons 		0.9*/

#Const C_Object [
	"Laser"			=> "Laser",
	"PlasmaGun"		=> "PlasmaGun",
	"Grenades"		=> "Grenades",
	"Nucleus"		=> "Nucleus",
	"Shotgun"		=> "Shotgun",
	"BlowBomb"		=> "BlowBomb"
]

#Const Description  _("RULES:\n- Every team has energy supply that gives instant respawns\n- Capture middle zone to gain free respawns and eliminate enemies to win the round.\n- Controlled zone can be stolen by the opposing team.")

declare Integer[Integer]			G_ClansMapPoints;		// Number of points cumulated on one map for each clan
declare Ident[]						G_SpawnList1;			// Spawns with tag Spawn1
declare Ident[]						G_SpawnList2;			// Spawns with tag Spawn2
declare CSmMapLandmark[Integer]		G_SpawnList;			// All spawns
declare Integer[Integer] 			G_ZoneClanList; 		// Which clan control specific zone
declare Integer						G_NbPolesB;				// Number of poles in Zone B
declare Boolean[Integer]			G_InstantRespawns;
declare Integer[Text]				G_SecondaryWeapons;		// Current player secondary weapons
declare Integer[Text]				G_PrimaryWeapons;		// Current player secondary weapons
declare Integer 					G_LastProgressUpdate;	// Time of the last progrresion layer update
declare Integer 					G_LastSettingsUpdate; 	// Time of the last setting layer update
declare Integer 					G_LastTempUpdate;
declare Boolean[Integer]			G_DecaptureAnnouncment;
declare Integer[Integer]			G_PlayersAlive;

// Globals caches the settings
declare Integer 					G_RoundTime;
declare Integer 					G_RoundTimeBonus;
declare Integer 					G_PoleCaptureDuration;
declare Integer 					G_CheckpointDuration;
declare Integer 					G_MapPointsLimit;
declare Integer 					G_ClassSelectionTime;
declare Integer 					G_ObjectDetector;
declare Integer 					G_BlueBot;
declare Integer 					G_RedBot;

declare Ident[Text] 				G_ObjectId;				// Ids of the objects
declare Ident 						G_CustomBounceRocket;
declare Ident 						G_CustomGrenades;
declare Ident 						G_CustomPlasmaGun;
declare Ident 						G_CustomElectricPistol;
declare Ident 						G_CustomShotgun;
declare Ident 						G_CustomBlowBomb;

***LogVersion***
***
MB_LogVersion(ScriptName, Version);
MB_LogVersion(SM::GetScriptName(), SM::GetScriptVersion());
MB_LogVersion(Map::GetScriptName(), Map::GetScriptVersion());
MB_LogVersion(CustomUI::GetScriptName(), CustomUI::GetScriptVersion());
MB_LogVersion(Score::GetScriptName(), Score::GetScriptVersion());
MB_LogVersion(Layers::GetScriptName(), Layers::GetScriptVersion());
MB_LogVersion(SpawnScreen::GetScriptName(), SpawnScreen::GetScriptVersion());
***

***InitServer***
***
MB_UseSectionRound		= True;
MB_UseSectionTurn		= False;
MB_UsePlayerClublinks	= S_UsePlayerClublinks;
***

***StartServer***
***
UseClans			= True;
UseProtectClanmates	= False;
UseLaserSkewering	= False;
UseAmmoBonusOnHit	= False;
UsePlayerTagging 	= True;
UseMinimap 			= True;

if(S_RoundTime < 20) G_RoundTime = 20;
else G_RoundTime = S_RoundTime;

if(S_RoundTimeBonus < 0) G_RoundTimeBonus = 0;
else G_RoundTimeBonus = S_RoundTimeBonus;

if(S_PoleCaptureDuration < 1) G_PoleCaptureDuration = 1;
else G_PoleCaptureDuration = S_PoleCaptureDuration;

if(S_CheckpointDuration < 10) G_CheckpointDuration = 10;
else G_CheckpointDuration = S_CheckpointDuration;

if(S_MapPointsLimit < 1) G_MapPointsLimit = 1;
else G_MapPointsLimit = S_MapPointsLimit;

if(S_ClassSelectionTime < 5) G_ClassSelectionTime = 5;
else G_ClassSelectionTime = S_ClassSelectionTime;

if(S_ObjectDetector < 0) G_ObjectDetector = 0;
else G_ObjectDetector = S_ObjectDetector;

if(S_BlueBot <= 0) G_BlueBot = 0;
else G_BlueBot = S_BlueBot;

if(S_RedBot < 0) G_RedBot = 0;
else G_RedBot = S_RedBot;

declare ModeName = "Flashpoint";
declare ModeObjectives = TextLib::Compose(_("$<%11. $>The goal of this mode is to clear area from enemies by reducing energy from enemy gate.\n$<%12. $>A game is divided in rounds.\n$<%13. $>The first team with %2 points wins the match."), "$"^SpawnScreen::GetModeColor(), TextLib::ToText(S_MapPointsLimit+1));
declare ModeConditions = TextLib::Compose(_("$<%11. $>Energy in gate gives instant respawns.\n$<%12. $>You can reduce energy by eliminating enemies(Spawn ticket costs %2%% of energy) or by gate decapturing.\n$<%13. $>You can carry 2 weapons. Primary weapon you can find on map by collecting weapon item. The secondary you are choosing before round.\n$<%14. $>Capture middle zone of goals to gain free spawn tickets."), "$"^SpawnScreen::GetModeColor(), TextLib::ToText(S_TicketReduction));

SpawnScreen::AddSubsection(_("Type"), _("Team versus Team"), 0.);
SpawnScreen::AddSubsection(_("Objectives"), ModeObjectives, 20.);
SpawnScreen::AddSubsection(_("Conditions"), ModeConditions, 60.);
SpawnScreen::CreatePrettyRules(ModeName);
ModeStatusMessage = _("RULES:\n- Every team has energy supply that gives instant respawns\n- Capture middle zone to gain free respawns and eliminate enemies to win the round.\n- Controlled zone can be stolen by the opposing team.");
SM::SetupDefaultVisibility();

CustomUI::Load();
CustomUI::Add("Flashpoint_PlayersList_1", <-160., 67.>, <46., 90.>, "top", "left");
CustomUI::Add("Flashpoint_PlayersList_2", <160., 67.>, <46., 90.>, "top", "right");
CustomUI::Build();
MiniMap::Load();
// Create layers
Layers::Create("Progression"); // Zone Capture progress
Layers::Create("Markers"); // markers layer
Layers::Create("HUD"); // Hud layer when player is spawned
Layers::Create("RulesReminder", UpdateLayerRulesReminder());
Layers::SetType("Markers", CUILayer::EUILayerType::Markers);
Layers::SetType("RulesReminder", CUILayer::EUILayerType::CutScene);
Layers::Attach("RulesReminder");

// Init Actions
ActionList_Begin();
G_CustomBounceRocket 				= ActionList_Add("BRocket.Action.Gbx");
G_CustomPlasmaGun					= ActionList_Add("PlasmaGun.Action.Gbx");
G_CustomGrenades 					= ActionList_Add("Grenades.Action.Gbx");
G_CustomElectricPistol 				= ActionList_Add("ElectricPistol.Action.Gbx");
G_CustomShotgun 					= ActionList_Add("Shotgun.Action.Gbx");
G_CustomBlowBomb 					= ActionList_Add("BlowBomb.Action.Gbx");
ActionList_End();

// Init Items
ItemList_Begin();
G_ObjectId[C_Object["Laser"]]		= ItemList_Add("PickUpFF/Laser.Item.gbx");
G_ObjectId[C_Object["PlasmaGun"]]	= ItemList_Add("PickUpFF/PlasmaGun.Item.gbx");
G_ObjectId[C_Object["Grenades"]]	= ItemList_Add("PickUpFF/Grenades.Item.gbx");
G_ObjectId[C_Object["Nucleus"]]		= ItemList_Add("PickUpFF/Nucleus.Item.gbx");
G_ObjectId[C_Object["Shotgun"]]		= ItemList_Add("PickUpFF/Shotgun.Item.gbx");
G_ObjectId[C_Object["BlowBomb"]]	= ItemList_Add("PickUpFF/BlowBomb.Item.gbx");
ItemList_End();

// Init scores table
ST2::SetStyle("LibST_SMBaseTeams");
ST2::SetStyle("LibST_SMBasePoints");
ST2::SetStyle("LibST_SMWithLegends");
//ST2::SetSize(<197., -1.>, <190., -1.>, <190., -1.>);
ST2::SetSize(<197., -1.>, <190., -1.>, <190., -1.>);
ST2::SetBackgroundImage("file://Media/Manialinks/Shootmania/ScoresTable/bg-storm.dds", <0., 5.>, <240., 98.>);
ST2::SetTeamImage(1, "file://Media/Manialinks/Shootmania/ScoresTable/teamversus-left.dds", <0., 3.8>, <120.0, 25.>);
ST2::SetTeamImage(2, "file://Media/Manialinks/Shootmania/ScoresTable/teamversus-right.dds", <0., 3.8>, <120.0, 25.>);
ST2::SetFormat(2, 6);
MB_SetScoresTableStyleFromXml(S_ScoresTableStylePath);
ST2::CreateCol("ST_MVP", _("MVP"), "$fc0", 4.5, 95.);
ST2::SetColTextAlign("ST_MVP", CMlControl::AlignHorizontal::HCenter);
ST2::SetColTextAlign("LibST_SMPoints", CMlControl::AlignHorizontal::HCenter);
ST2::SetColTextAlign("LibST_SMRoundPoints", CMlControl::AlignHorizontal::HCenter);
ST2::SetColLegend("LibST_SMRoundPoints", _("Round"));
ST2::SetColLegend("LibST_SMPoints", _("Score"));
ST2::SetColWidth("LibST_Name", 20.);
ST2::SetColWidth("LibST_SMRoundPoints", 4.5);
ST2::SetColWidth("LibST_SMPoints", 6.);
ST2::Build("SM");
***	

***StartMatch***
***
// Reset clan scores
ClanScores[1] = 0;
ClanScores[2] = 0;
***

***InitMap***
***
declare Integer		ClanMapWinner;		// Clan who win the map
MB_UseIntro = True;
***

***StartMap***
***
UIManager.UIAll.MarkersXML = "";
UIManager.UIAll.ScreenIn3dHideVersus = False;
UIManager.UIAll.ScreenIn3dHideScoreSummary = False;
G_ClansMapPoints	= [1 => 0, 2 => 0];
G_ZoneClanList 		= [1 => 0, 2 => 0, 3 => 0];
G_SecondaryWeapons.clear();
G_PrimaryWeapons.clear();
ClanMapWinner		= 0;
G_NbPolesB			= 0;
// reset custom scores table data
foreach(Score in Scores)
{
	declare CurrentMVP for Score = 0;
	CurrentMVP = 0;
}
InitSpawns();

// Init scores
Score::MatchBegin();
ST2::ClearScores();

// Init players
foreach (Player in Players) SetPlayerClan(Player, Player.RequestedClan);

// Update the players clublinks
if (S_ForceClublinkTeam1 == "" && S_ForceClublinkTeam2 == "") Clublink::DefineTeamAuto();
else Clublink::DefineTeamFromUrl(S_ForceClublinkTeam1, S_ForceClublinkTeam2);
Clublink::SyncUpdate();

// Init UI
SM::SetupDefaultVisibility();
Message::CleanAllMessages();
if(S_UsePlayerClublinks) Clublink::Attach();
else Clublink::Detach();
Clublink::SetSponsorsDisplay(False);
LT_UpdateHeader(G_ClansMapPoints[1], G_ClansMapPoints[2]);

// Debug
Users_SetNbFakeUsers(G_BlueBot, G_RedBot);

SM::UnspawnAllPlayers();
WaitForPlayers();
***

***InitRound***
***
declare Ident FirstOnGoal; 		// The first player on pole
declare Integer RoundClanWinner;// Team, who win the round
declare Integer TempGoalNb;		// To stop looping
declare Integer BestRoundScore;	// The best RoundPoints score in round
declare CSmPlayer MVP;			// The best player in round
***

***StartRound***
***
FirstOnGoal = NullId;
TempGoalNb = 0;
RoundClanWinner = 0;
BestRoundScore = 0;
MVP = Null;
if(LT_IsAfterHalfTime()) G_ZoneClanList = [1 => 2, 2 => 0, 3 => 1];
else G_ZoneClanList = [1 => 1, 2 => 0, 3 => 2];
G_InstantRespawns = [1 => True, 2 => True];
G_PlayersAlive = [1 => 0, 2 => 0];
G_LastProgressUpdate = 0;
G_LastSettingsUpdate = 0;
G_LastTempUpdate = 0;
G_DecaptureAnnouncment = [1 => False, 2 => False];
G_SecondaryWeapons.clear();
G_PrimaryWeapons.clear();
Mode::Synchro_DoBarrier();
UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::Normal;
Victory::RoundBegin();
Score::RoundBegin();
LT_UpdateSTFooter();
InitGoals();
InitSpawns();
// If this is the first round and turn on the map, launch the players presentation
if (MB_SectionRoundNb == 1) 
{
	LT_UpdateHeader(G_ClansMapPoints[1], G_ClansMapPoints[2]);
	MB_PlayersPresentationSequence(2500);
}
Message::CleanAllMessages();
UIManager.UIAll.UISequence = CUIConfig::EUISequence::EndRound;
Mode::PlaySound(CUIConfig::EUISound::StartRound, 0);
LT_UpdateHeader(G_ClansMapPoints[1], G_ClansMapPoints[2]);
UpdateBasesColors();
if(ServerShutdownRequested || MatchEndRequested) break;
Layers::Update("Progression", UpdateLayerProgression(1));
UIManager.UIAll.MarkersXML = "";
SelectClasses(G_ClassSelectionTime*1000);
//LT_InitPlayersLists();

// Load Items
ObjectDestroyAll();
foreach (MapLandmark in MapLandmarks_ObjectAnchor) 
{
	declare ObjectSpawned for MapLandmark = False;
	declare ObjectNextSpawn for MapLandmark = Now;
	ObjectSpawned = False;
	ObjectNextSpawn = Now + 3000;
}

// Init players and spawn ticket
foreach (Player in AllPlayers) 
{
	declare SpawnTicket for Player = 0;
	SpawnTicket = 1;
	ActionLoad(Player, CSmMode::EActionSlot::Slot_A, NullId);
	ActionBind(Player, CSmMode::EActionSlot::Slot_A, CSmMode::EActionInput::None);
	declare PrimaryWeapon for Player = 0;
	PrimaryWeapon = 0;
	declare UI <=> UIManager.GetUI(Player);
	if (UI != Null) 
	{ 
		declare netwrite Integer[Text] Net_PrimaryWeapons for UI;
		Net_PrimaryWeapons[Player.Login] = 0;
	}
	declare HasChangedClan for Player = False;
	declare NewSpectator for Player = False;
	SetPlayerClan(Player, Player.RequestedClan);
	if (UI != Null)
	{
		declare SpawnArmor for Player = 100;
		SpawnArmor = S_PlayerArmor * 100;
		Player.ArmorMax = SpawnArmor;	
	}
	HasChangedClan = False;
	NewSpectator = True;
}

foreach (Spectator in Spectators) {
	declare SpawnArmor for Spectator = 100;
	declare NewSpectator for Spectator = False;
	SpawnArmor = 0;
	NewSpectator = False;
}

// Init spectator mode
foreach (Player in AllPlayers) 
{
	declare UI <=> UIManager.GetUI(Player);
	if (UI == Null) continue;
	
	if (Player.RequestsSpectate) 
	{
		declare SpawnTicket for Player = 0;
		SpawnTicket = 0;
		UI.SpectatorForceCameraType = -1;
		UI.SpectatorForcedClan = -1;
	} 
	else 
	{
		UI.SpectatorForceCameraType = 1;
		UI.SpectatorForcedClan = Player.CurrentClan;
	}
}

// Update the players clublinks
if (S_ForceClublinkTeam1 == "" && S_ForceClublinkTeam2 == "") Clublink::DefineTeamAuto();
else Clublink::DefineTeamFromUrl(S_ForceClublinkTeam1, S_ForceClublinkTeam2);
Clublink::SyncUpdate();
if(S_UsePlayerClublinks == True) Clublink::Attach();
else Clublink::Detach();
CustomUI::Attach();
UIManager.UIAll.UISequence = CUIConfig::EUISequence::Playing;
Layers::Update("Progression", UpdateLayerProgression(0));
Layers::Attach("Progression");
Layers::Attach("Markers");
Layers::Update("HUD", UpdateLayerHUD());
Layers::Attach("HUD");
LT_ShowPlayersLists();
MiniMap::Attach();
UpdateMarker();

// Set the timers
LT_SetRoundTimer(G_RoundTime);
***

***OnNewPlayer***
***
declare UI <=> UIManager.GetUI(Player);
if (UI != Null) 
{
	UI.SpectatorForcedClan		= Player.CurrentClan;
	UI.SpectatorForceCameraType	= 1;
	Layers::Attach("Progression", Player);
	LT_UpdatePlayersLists();
	declare CurrentMVP for Player.Score = 0;
	declare SpawnArmor for Player = 100;
	SpawnArmor = S_PlayerArmor * 100;
	Player.ArmorMax = SpawnArmor;
	declare netwrite Net_PrimaryWeapon for UI = 0;
	Net_PrimaryWeapon = 0;
}
***

***OnNewSpectator***
***
declare UI <=> UIManager.GetUI(Spectator);
if (UI != Null) {
	UI.SpectatorForcedClan		= -1;
	UI.SpectatorForceCameraType	= -1;
	Layers::Attach("Progression", Spectator);
	LT_AttachPlayersLists(Spectator);
}
declare SpawnTicket for Spectator = 100;
SpawnTicket = 0;
***

***Yield***
***
Message::Loop();
***

***PlayLoop***
***
declare PlayerCountA = [1 => 0, 2 => 0];
declare PlayerCountB = [1 => 0, 2 => 0];
declare PlayerCountC = [1 => 0, 2 => 0];

if(G_LastTempUpdate + 25 < Now) // There is a loop bug when at the same time, two zones have been captured
{
	G_LastTempUpdate = Now;
	if(TempGoalNb > 0) TempGoalNb = 0;
}
if(G_LastSettingsUpdate + 2000 < Now)
{
	G_LastSettingsUpdate = Now;
	if(S_RoundTime < 20) G_RoundTime = 20;
	else G_RoundTime = S_RoundTime;

	if(S_RoundTimeBonus < 0) G_RoundTimeBonus = 0;
	else G_RoundTimeBonus = S_RoundTimeBonus;

	if(S_PoleCaptureDuration < 1) G_PoleCaptureDuration = 1;
	else G_PoleCaptureDuration = S_PoleCaptureDuration;

	if(S_CheckpointDuration < 10) G_CheckpointDuration = 10;
	else G_CheckpointDuration = S_CheckpointDuration;

	if(!S_FinalRoundExceptDraw || MB_SectionRoundNb != S_MapPointsLimit*2+1)
	{
		if(S_MapPointsLimit < 1)
		{
			G_MapPointsLimit = 1;
			LT_UpdateSTFooter();
		}	
		else
		{
			G_MapPointsLimit = S_MapPointsLimit;
			LT_UpdateSTFooter();
		}
	}		

	if(S_ClassSelectionTime < 5) G_ClassSelectionTime = 5;
	else G_ClassSelectionTime = S_ClassSelectionTime;
	
	if(S_ObjectDetector < 0) G_ObjectDetector = 0;
	else G_ObjectDetector = S_ObjectDetector;
	
	if(S_BlueBot < 0) G_BlueBot = 0;
	else G_BlueBot = S_BlueBot;

	if(S_RedBot < 0) G_RedBot = 0;
	else G_RedBot = S_RedBot;
	
	Users_SetNbFakeUsers(G_BlueBot, G_RedBot);
	
	if(PlayersNbTotal < 2) MB_StopRound = True;
}

// Unspawn and mark players changing clan
foreach (Player in Players) {
	if (!Player.IsFakePlayer && Player.SpawnStatus == CSmPlayer::ESpawnStatus::Spawned) {
		// if the player wants to change clan, then remove him from the current clan
		// it will be added to the correct clan at next respawn.
		if (Player.CurrentClan != 0 && Player.RequestedClan != Player.CurrentClan) {
			UnspawnPlayer(Player);
			declare HasChangedClan for Player = False;
			HasChangedClan = True;
		}
	}
	if(!Player.IsFakePlayer && Player.RequestsSpectate)
	{
		declare NewSpectator for Player = False;
		NewSpectator = True;
		LT_DetachWeaponSelection(Player);
	}
}

// Don't let players going spectate respawn afterward
foreach (Spectator in Spectators) 
{
	declare SpawnArmor for Spectator = 100;
	declare NewSpectator for Spectator = False;
	SpawnArmor = 0;
	if (NewSpectator) NewSpectator = False;
}
// Spawning players
if(RoundClanWinner == 0)
{
	foreach (Player in Players)
	{
		declare HasChangedClan for Player = False;
		declare NewSpectator for Player = True;
		if (Player.SpawnStatus == CSmPlayer::ESpawnStatus::NotSpawned && !HasChangedClan)
		{
			declare SecondaryWeapon for Player = 1;
			declare SpawnTicket for Player = 0;
			if(SpawnTicket <= 0) continue;
			declare SpawnArmor for Player = 100;
			if (SpawnArmor < 100) SpawnArmor = 100;
			if (SpawnArmor > Player.ArmorMax) SpawnArmor = Player.ArmorMax;
			if (Player.CurrentClan != 1 && Player.CurrentClan != 2) SetPlayerClan(Player, Player.RequestedClan);
			if (Player.RequestedClan == 1 && SpawnArmor > 0)
			{
				declare SpawnId = NullId;
				if(LT_IsAfterHalfTime()) SpawnId = G_SpawnList2[MathLib::Rand(0, G_SpawnList2.count - 1)];	
				else SpawnId = G_SpawnList1[MathLib::Rand(0, G_SpawnList1.count - 1)];
				if (SpawnId != NullId)
				{
					SM::SpawnPlayer(Player, Player.CurrentClan, SpawnArmor, MapLandmarks_PlayerSpawn[SpawnId].PlayerSpawn, 3000);
					SpawnTicket = 0;
					declare MSG = "";
					switch(Player.User.Language)
					{
						case "pl": MSG = "$fd0Zredukuj energię rywali do 0 przez eliminacje lub zdobywanie bramy!";
						default: MSG = "$fd0Reduce energy to 0% by eliminating or decapturing gate!";
					} 
					Message::SendStatusMessage(Player, MSG, 5000, 0);
					declare UI <=> UIManager.GetUI(Player);
					if (UI != Null) 
					{
						declare netread Net_SecondaryWeapon for UI = 1;
						switch(Net_SecondaryWeapon)
						{
							case 1:
							{
								ActionBind(Player, CSmMode::EActionSlot::Slot_B, CSmMode::EActionInput::None);
								SetPlayerWeapon(Player, CSmMode::EWeapon::Rocket, False);
								SetPlayerAmmoMax(Player, CSmMode::EWeapon::Rocket, C_RocketsAmmo);
								Player.StaminaMax = C_StaminaWith1Weapon;
								Player.StaminaGain = C_StaminaWith1Weapon;
								Player.SpeedPower = C_SpeedWith1Weapon;
								Player.AmmoGain = 1.0;
								SecondaryWeapon = 1;
							}
							case 2:
							{
								// Action MAKER
								ActionLoad(Player, CSmMode::EActionSlot::Slot_B, G_CustomBounceRocket);
    							ActionBind(Player, CSmMode::EActionSlot::Slot_B, CSmMode::EActionInput::Weapon);
								Player.StaminaMax = C_StaminaWith1Weapon;
								Player.StaminaGain = C_StaminaWith1Weapon;
								Player.SpeedPower = C_SpeedWith1Weapon;
								SecondaryWeapon = 2;
							}
							case 3:
							{
								// Action MAKER
								ActionLoad(Player, CSmMode::EActionSlot::Slot_B, G_CustomElectricPistol);
    							ActionBind(Player, CSmMode::EActionSlot::Slot_B, CSmMode::EActionInput::Weapon);
								Player.StaminaMax = C_StaminaWith1Weapon;
								Player.StaminaGain = C_StaminaWith1Weapon;
								Player.SpeedPower = C_SpeedWith1Weapon;
								SecondaryWeapon = 3;
							}
							default: //basic
							{
								ActionBind(Player, CSmMode::EActionSlot::Slot_B, CSmMode::EActionInput::None);
								SetPlayerWeapon(Player, CSmMode::EWeapon::Rocket, False);
								SetPlayerAmmoMax(Player, CSmMode::EWeapon::Rocket, C_RocketsAmmo);
								Player.StaminaMax = C_StaminaWith1Weapon;
								Player.StaminaGain = C_StaminaWith1Weapon;
								Player.SpeedPower = C_SpeedWith1Weapon;
								Player.AmmoGain = 1.0;
								SecondaryWeapon = 1;
							}
						}
						G_SecondaryWeapons[Player.Login] = SecondaryWeapon;
						declare netwrite Integer[Text] Net_SecondaryWeapons for UI;
						Net_SecondaryWeapons = G_SecondaryWeapons;
					}
					else
					{
						SetPlayerWeapon(Player, CSmMode::EWeapon::Rocket, False);
						SetPlayerAmmoMax(Player, CSmMode::EWeapon::Rocket, C_RocketsAmmo);
						Player.StaminaMax = C_StaminaWith1Weapon;
						Player.StaminaGain = C_StaminaWith1Weapon;
						Player.SpeedPower = C_SpeedWith1Weapon;
						Player.AmmoGain = 1.0;
						SecondaryWeapon = 1;
					}	
					Player.Armor = SpawnArmor;
					Player.ArmorMax = SpawnArmor;
				}
				else log(Now^">Wrong map, check spawn tags");	
			}
			else if (Player.RequestedClan == 2 && SpawnArmor > 0)
			{
				declare SpawnId = NullId;
				if(LT_IsAfterHalfTime()) SpawnId = G_SpawnList1[MathLib::Rand(0, G_SpawnList1.count - 1)];
				else SpawnId = G_SpawnList2[MathLib::Rand(0, G_SpawnList2.count - 1)];
				if (SpawnId != NullId) 
				{
					SM::SpawnPlayer(Player, Player.CurrentClan, SpawnArmor, MapLandmarks_PlayerSpawn[SpawnId].PlayerSpawn, 3000);
					SpawnTicket = 0;
					declare MSG = "";
					switch(Player.User.Language)
					{
						case "pl": MSG = "$fd0Zredukuj energię rywali do 0 przez eliminacje lub zdobywanie bramy!";
						default: MSG = "$fd0Reduce energy to 0% by eliminating or decapturing gate!";
					}
					Message::SendStatusMessage(Player, MSG, 5000, 0);
					declare UI <=> UIManager.GetUI(Player);
					if (UI != Null) 
					{
						declare netread Net_SecondaryWeapon for UI = 1;
						switch (Net_SecondaryWeapon) 
						{
							case 1: //Soldier
							{
								ActionBind(Player, CSmMode::EActionSlot::Slot_B, CSmMode::EActionInput::None);
								SetPlayerWeapon(Player, CSmMode::EWeapon::Rocket, False);
								SetPlayerAmmoMax(Player, CSmMode::EWeapon::Rocket, C_RocketsAmmo);
								Player.StaminaMax = C_StaminaWith1Weapon;
								Player.StaminaGain = C_StaminaWith1Weapon;
								Player.SpeedPower = C_SpeedWith1Weapon;
								Player.AmmoGain = 1.0;
								SecondaryWeapon = 1;
							}
							case 2: // Ninja
							{
								// Action MAKER
								ActionLoad(Player, CSmMode::EActionSlot::Slot_B, G_CustomBounceRocket);
    							ActionBind(Player, CSmMode::EActionSlot::Slot_B, CSmMode::EActionInput::Weapon);
								Player.StaminaMax = C_StaminaWith1Weapon;
								Player.StaminaGain = C_StaminaWith1Weapon;
								Player.SpeedPower = C_SpeedWith1Weapon;
								SecondaryWeapon = 2;
							}
							case 3: // Commando
							{
								// Action MAKER
								ActionLoad(Player, CSmMode::EActionSlot::Slot_B, G_CustomElectricPistol);
    							ActionBind(Player, CSmMode::EActionSlot::Slot_B, CSmMode::EActionInput::Weapon);
								Player.StaminaMax = C_StaminaWith1Weapon;
								Player.StaminaGain = C_StaminaWith1Weapon;
								Player.SpeedPower = C_SpeedWith1Weapon;
								SecondaryWeapon = 3;
							}
							default: //basic
							{
								ActionBind(Player, CSmMode::EActionSlot::Slot_B, CSmMode::EActionInput::None);
								SetPlayerWeapon(Player, CSmMode::EWeapon::Rocket, False);
								SetPlayerAmmoMax(Player, CSmMode::EWeapon::Rocket, C_RocketsAmmo);
								Player.StaminaMax = C_StaminaWith1Weapon;
								Player.StaminaGain = C_StaminaWith1Weapon;
								Player.SpeedPower = C_SpeedWith1Weapon;
								Player.AmmoGain = 1.0;
								SecondaryWeapon = 1;
							}
						}
						G_SecondaryWeapons[Player.Login] = SecondaryWeapon;
						declare netwrite Integer[Text] Net_SecondaryWeapons for UI;
						Net_SecondaryWeapons = G_SecondaryWeapons;
					}
					else
					{
						SetPlayerWeapon(Player, CSmMode::EWeapon::Rocket, False);
						SetPlayerAmmoMax(Player, CSmMode::EWeapon::Rocket, C_RocketsAmmo);
						Player.StaminaMax = C_StaminaWith1Weapon;
						Player.StaminaGain = C_StaminaWith1Weapon;
						Player.SpeedPower = C_SpeedWith1Weapon;
						Player.AmmoGain = 1.0;
						SecondaryWeapon = 1;
					}
					Player.Armor = SpawnArmor;
					Player.ArmorMax = SpawnArmor;
				}
				else log(Now^">Wrong map, missing Spawn2");
			}
		}
	}		
}

// Timer management
if (G_RoundTime > 0) 
{
	// End of the round
	if (Now == EndTime) 
	{
		foreach (Player in Players)
		{
			declare SpawnTicket for Player = 0;
			SpawnTicket = 0;
			declare SpawnArmor for Player = 100;
			SpawnArmor = 0;
		}
		SM::UnspawnAllPlayers();
		Message::CleanBigMessages();
		Message::SendBigMessage(TextLib::Compose(_("Time limit reached!")), 4000, 0);
		Layers::Update("Progression", UpdateLayerProgression(0));
		LT_HidePlayersLists();
		declare AllPoints1 = 0;
		declare AllPoints2 = 0;
		foreach(Player in Players)
		{
			switch(Player.CurrentClan)
			{
				case 1: AllPoints1 += Player.Score.RoundPoints;
				case 2: AllPoints2 += Player.Score.RoundPoints;
			}	
		}	
		if(AllPoints1 > AllPoints2)
		{
			Victory::SetRoundWinnerIfNoWinner(1);
			RoundClanWinner = 1;
		}
		else if(AllPoints2 > AllPoints1)
		{
			Victory::SetRoundWinnerIfNoWinner(2);
			RoundClanWinner = 2;
		}
		else if(S_FinalRoundExceptDraw && MB_SectionRoundNb == S_MapPointsLimit*2+1)
		{
			declare ran = MathLib::Rand(1, 2);
			Victory::SetRoundWinnerIfNoWinner(ran);
		}
		else
		{
			Victory::SetRoundDrawIfNoWinner();
			RoundClanWinner = 0;
		}	
		MB_StopRound = True;
	}
}

// Poles management
foreach (LandmarkGauge in MapLandmarks_Gauge) 
{
	if(LandmarkGauge.Sector != Null)
	{
		if(LandmarkGauge.Tag == "Zone")
		{
			if (LandmarkGauge.Sector.PlayersIds.count > 0) 
			{
				foreach (PlayerId in LandmarkGauge.Sector.PlayersIds) 
				{
					declare Player <=> Players[PlayerId];
					if (FirstOnGoal != NullId && !LandmarkGauge.Sector.PlayersIds.exists(FirstOnGoal) && LandmarkGauge.Gauge.ValueReal != 0.) FirstOnGoal = NullId;
					if (FirstOnGoal == NullId) FirstOnGoal = PlayerId;
					PlayerCountB[Player.CurrentClan] += 1;
				}
			}
		}	
		if(LandmarkGauge.Tag == "Supply1")
		{
			if (LandmarkGauge.Sector.PlayersIds.count > 0) 
			{
				foreach (PlayerId in LandmarkGauge.Sector.PlayersIds) 
				{
					declare Player <=> Players[PlayerId];
					if (FirstOnGoal != NullId && !LandmarkGauge.Sector.PlayersIds.exists(FirstOnGoal) && LandmarkGauge.Gauge.ValueReal != 0.) FirstOnGoal = NullId;
					if (FirstOnGoal == NullId) FirstOnGoal = PlayerId;
					PlayerCountA[Player.CurrentClan] += 1;
				}
			}
		}
		if(LandmarkGauge.Tag == "Supply2")
		{
			if (LandmarkGauge.Sector.PlayersIds.count > 0) 
			{
				foreach (PlayerId in LandmarkGauge.Sector.PlayersIds) 
				{
					declare Player <=> Players[PlayerId];
					if (FirstOnGoal != NullId && !LandmarkGauge.Sector.PlayersIds.exists(FirstOnGoal) && LandmarkGauge.Gauge.ValueReal != 0.) FirstOnGoal = NullId;
					if (FirstOnGoal == NullId) FirstOnGoal = PlayerId;
					PlayerCountC[Player.CurrentClan] += 1;
				}
			}
		}					
	}
}

foreach(Landmark in MapLandmarks)
{
	if(Landmark.Sector != Null)
	{
		if(Landmark.Tag == "Supply1")
		{
			if((PlayerCountA[1] > 0 || PlayerCountA[2] > 0) && Landmark.Gauge.Value > 0.)
			{
				// Opposing
				if (PlayerCountA[3-Landmark.Gauge.Clan] > PlayerCountA[Landmark.Gauge.Clan]) 
				{
					Landmark.Gauge.Speed = -1 - PlayerCountA[3-Landmark.Gauge.Clan] + PlayerCountA[Landmark.Gauge.Clan];
				} 
				// Draw
				else {
					Landmark.Gauge.Speed = 0;
				}
			}
			else Landmark.Gauge.Speed = 0;
			// Captured
			if (Landmark.Gauge.ValueReal == 0. && !G_DecaptureAnnouncment[1]) 
			{
				declare Integer TeamNb;
				if(LT_IsAfterHalfTime()) TeamNb = 1;
				else TeamNb = 0;
				AnnounceEnergyLoss(TeamNb, 1);
				Landmark.Gauge.Clan = 0;
				Landmark.Gauge.ValueReal = 0.;
				G_ZoneClanList[1] = 0;
				Landmark.Gate.ManualClosed = False;
			}			
		}
		if(Landmark.Tag == "Supply2")
		{
			if((PlayerCountC[1] > 0 || PlayerCountC[2] > 0) && Landmark.Gauge.Value > 0.)
			{
				// Opposing
				if (PlayerCountC[3-Landmark.Gauge.Clan] > PlayerCountC[Landmark.Gauge.Clan]) 
				{
					Landmark.Gauge.Speed = -1 - PlayerCountC[3-Landmark.Gauge.Clan] + PlayerCountC[Landmark.Gauge.Clan];
				} 
				// Draw
				else Landmark.Gauge.Speed = 0;
			}
			else Landmark.Gauge.Speed = 0;
			// Captured
			if (Landmark.Gauge.ValueReal == 0. && !G_DecaptureAnnouncment[2]) 
			{
				declare Integer TeamNb;
				if(LT_IsAfterHalfTime()) TeamNb = 0;
				else TeamNb = 1;
				AnnounceEnergyLoss(TeamNb, 2);
				Landmark.Gauge.Clan = 0;
				Landmark.Gauge.ValueReal = 0.;
				G_ZoneClanList[3] = 0;
				Landmark.Gate.ManualClosed = False;
			}	
		}
		if(Landmark.Tag == "Zone")
		{
			if(PlayerCountB[1] > 0 || PlayerCountB[2] > 0)
			{
				if (Landmark.Gauge.Clan == 0) 
				{
					if (PlayerCountB[1] > PlayerCountB[2]) Landmark.Gauge.Clan = 1;
					else if (PlayerCountB[2] > PlayerCountB[1]) Landmark.Gauge.Clan = 2;
				}
				// Capturing
				if (PlayerCountB[Landmark.Gauge.Clan] > PlayerCountB[3-Landmark.Gauge.Clan] && !Landmark.Gauge.Captured) 
					Landmark.Gauge.Speed = 2 + PlayerCountB[Landmark.Gauge.Clan] - PlayerCountB[3-Landmark.Gauge.Clan];
				// Opposing
				else if (PlayerCountB[3-Landmark.Gauge.Clan] > PlayerCountB[Landmark.Gauge.Clan]) 
				{
					Landmark.Gauge.Speed = -1 - PlayerCountB[3-Landmark.Gauge.Clan] + PlayerCountB[Landmark.Gauge.Clan];
					if (Landmark.Gauge.Value == 0.)
					{
						UpdateMarker();
						Landmark.Gauge.Clan = 3-Landmark.Gauge.Clan;
						G_ZoneClanList[2] = 0;
					}	
				} 
				// Draw
				else Landmark.Gauge.Speed = 0;
			} 
			// Regeneration
			else if(Landmark.Gauge.Clan != 0 && G_ZoneClanList[2] == Landmark.Gauge.Clan && Landmark.Gauge.ValueReal <= 1.)
				Landmark.Gauge.Speed = 1;
			else Landmark.Gauge.Speed = 0;
			// Captured
			if (Landmark.Gauge.Value >= Landmark.Gauge.Max && Landmark.Gauge.Clan != G_ZoneClanList[2]) 
			{
				// Give bonus to timer and manage only once
				if (G_RoundTime > 0 && G_RoundTimeBonus > 0)
				{
					TempGoalNb += 1;
					if(TempGoalNb == 1)
					{
						EndTime += (G_RoundTimeBonus*1000);
						G_ZoneClanList[2] = Landmark.Gauge.Clan;
						UpdateMarker();
					}	
				}	
				
				Landmark.Gauge.Captured = True;

				UpdateBasesColors();
				if(Landmark.Sector.PlayersIds.count > 0)
				{
					foreach (PlayerId in Landmark.Sector.PlayersIds) 
					{
						if (Players.existskey(PlayerId) && Players[PlayerId].Score != Null) 
						{
							declare Player <=> Players[PlayerId];
							Player.Armor += 200;
							Score::AddPoints(Player, 3);
						}
					}
				}
				if (Players.existskey(FirstOnGoal)) 
				{
					if(G_ZoneClanList[2] > 0)
					{
						UIManager.UIAll.SendNotice(
						TextLib::Compose(_("$<%1$> captured Middle Zone"), Teams[G_ZoneClanList[2]-1].ColorizedName), 
						CUIConfig::ENoticeLevel::Default , Null, 
						CUIConfig::EAvatarVariant::Default, 
						CUIConfig::EUISound::Capture, 0
						);
						Message::CleanBigMessages();
		
						foreach(Player in Players)
						{
							declare MSG = "";
							declare MSG2 = "";
							switch(Player.User.Language)
							{
								case "pl":
								{
									MSG = TextLib::Compose(_("$AAAŚrodkowa Strefa$g przejęta przez $<%1$>!"), Teams[G_ZoneClanList[2]-1].ColorizedName);
									MSG2 = "Darmowe odradzanie aktywne.";
								}
								default:
								{
									MSG = TextLib::Compose(_("$AAAMiddle Zone$g is controlled by $<%1$>!"), Teams[G_ZoneClanList[2]-1].ColorizedName);
									MSG2 = "Free spawn tickets enabled.";
								}	
							} 
							Message::SendBigMessage(Player, MSG, 3500, 0);
							Message::SendStatusMessage(Player, MSG2, 3500, 0);
						}	
						foreach(Spectator in Spectators)
						{
							declare MSG = "";
							declare MSG2 = "";
							switch(Spectator.User.Language)
							{
								case "pl":
								{
									MSG = TextLib::Compose(_("$AAAŚrodkowa Strefa$g przejęta przez $<%1$>!"), Teams[G_ZoneClanList[2]-1].ColorizedName);
									MSG2 = "Darmowe odradzanie aktywne.";
								}
								default:
								{
									MSG = TextLib::Compose(_("$AAAMiddle Zone$g is controlled by $<%1$>!"), Teams[G_ZoneClanList[2]-1].ColorizedName);
									MSG2 = "Free spawn tickets enabled.";
								}
							} 
							Message::SendBigMessage(Spectator, MSG, 4000, 0);
							Message::SendStatusMessage(Spectator, MSG2, 4000, 0);
						}
					}
				}
			}	
		}
	}
}


if(G_LastProgressUpdate + 750 < Now)
{
	G_LastProgressUpdate = Now;
	Layers::Update("Progression", UpdateLayerProgression(0));
	Layers::Update("HUD", UpdateLayerHUD());
	G_PlayersAlive = [1 => 0, 2 => 0];
	
	foreach(Player in Players)
	{
		if(Player.Armor > 0) G_PlayersAlive[Player.CurrentClan] += 1;
	}	
	if(LT_IsAfterHalfTime())
	{
		if(G_ZoneClanList[1] == 0 && G_PlayersAlive[2] <= 0)
		{
			Victory::SetRoundWinnerIfNoWinner(1);
			RoundClanWinner = 1;
			MB_StopRound = True;
			LT_AnnounceEliminationMessage(1, 0);
		}
		else if(G_ZoneClanList[3] == 0 && G_PlayersAlive[1] <= 0)
		{
			Victory::SetRoundWinnerIfNoWinner(2);
			RoundClanWinner = 2;
			MB_StopRound = True;
			LT_AnnounceEliminationMessage(0, 0);
		}
	}
	else
	{
		if(G_ZoneClanList[1] == 0 && G_PlayersAlive[1] <= 0)
		{
			Victory::SetRoundWinnerIfNoWinner(2);
			RoundClanWinner = 2;
			MB_StopRound = True;
			LT_AnnounceEliminationMessage(0, 0);
		}
		else if(G_ZoneClanList[3] == 0 && G_PlayersAlive[2] <= 0)
		{
			Victory::SetRoundWinnerIfNoWinner(1);
			RoundClanWinner = 1;
			MB_StopRound = True;
			LT_AnnounceEliminationMessage(1, 0);
		}
	}
}	

// Spawn objects
SpawnWeaponItems();	

// Events
foreach (Event in PendingEvents) 
{
	// On player touches object
	if (Event.Type == CSmModeEvent::EType::OnPlayerTouchesObject)
	{
		if (Event.Player == Null) Discard(Event);
		else if (Event.Player != Null && Event.Player.SpawnStatus != CSmPlayer::ESpawnStatus::Spawned) Discard(Event);
		else 
		{
			PickUpObject(Event.Player, Event.Object);
			PassOn(Event);
		}
	}
	// On action event
	else if (Event.Type == CSmModeEvent::EType::OnActionEvent) 
	{
		if (Event.Player == Null) Discard(Event);
		else 
		{
			SwitchWeapon(Event.Player, Event.ActionInput);
			PassOn(Event);
		}		
	}
	// On player request action change
	/*else if (Event.Type == CSmModeEvent::EType::OnPlayerRequestActionChange) {
		if (Event.Player == Null) Discard(Event);
		else {
			CycleWeapon(Event.Player, Event.ActionChange);
			PassOn(Event);
		}
	}*/
	// Armor empty
	else if (Event.Type == CSmModeEvent::EType::OnArmorEmpty && Event.Victim != Null) 
	{
		if (Event.Victim.Armor > 100)
		{
			declare SpawnArmor for Event.Victim = 100;
			SpawnArmor = Event.Victim.Armor - 100;
			declare SpawnTicket for Event.Victim = 0;
			SpawnTicket = 1;
		}
		else
		{
			declare SpawnTicket for Event.Victim = 0;
			if(G_InstantRespawns[Event.Victim.CurrentClan])
			{
				SpawnTicket = 1;
				if(G_ZoneClanList[2] != Event.Victim.CurrentClan)
				{
					declare Number = G_CheckpointDuration * S_TicketReduction * 10;
					foreach(MLGate in MapLandmarks)
					{
						if(LT_IsAfterHalfTime())
						{
							switch(Event.Victim.CurrentClan)
							{
								case 1:
								{
									if(MLGate.Tag == "Supply2")
									{
										if(MLGate.Gauge.Value > Number) MLGate.Gauge.Value -= Number;
										else 
										{
											MLGate.Gauge.ValueReal = 0.;
											AnnounceEnergyLoss(0, 2);
											MLGate.Gauge.Clan = 0;
											G_ZoneClanList[3] = 0;
											MLGate.Gate.ManualClosed = False;
										}	
									}	
								}
								case 2:
								{
									if(MLGate.Tag == "Supply1")
									{
										if(MLGate.Gauge.Value > Number) MLGate.Gauge.Value -= Number;
										else 
										{
											MLGate.Gauge.ValueReal = 0.;
											AnnounceEnergyLoss(1, 1);
											MLGate.Gauge.Clan = 0;
											G_ZoneClanList[1] = 0;
											MLGate.Gate.ManualClosed = False;
										}	
									}	
								}
							}
						}
						else
						{
							switch(Event.Victim.CurrentClan)
							{
								case 1:
								{
									if(MLGate.Tag == "Supply1")
									{
										if(MLGate.Gauge.Value > Number) MLGate.Gauge.Value -= Number;
										else 
										{
											MLGate.Gauge.ValueReal = 0.;
											AnnounceEnergyLoss(0, 1);
											MLGate.Gauge.Clan = 0;
											G_ZoneClanList[1] = 0;
											MLGate.Gate.ManualClosed = False;
										}	
									}
								}
								case 2:
								{
									if(MLGate.Tag == "Supply2")
									{
										if(MLGate.Gauge.Value > Number) MLGate.Gauge.Value -= Number;
										else 
										{
											MLGate.Gauge.ValueReal = 0.;
											G_InstantRespawns[MLGate.Gauge.Clan] = False;
											AnnounceEnergyLoss(1, 2);
											MLGate.Gauge.Clan = 0;
											G_ZoneClanList[3] = 0;
										}	
									}
								}
							}
						}
					}
				}	
			}
			else SpawnTicket = 0;
			if (G_PlayersAlive[Event.Victim.CurrentClan] > 1) 
			{
				//Remove primary weapon after elimination
				ActionBind(Event.Victim, CSmMode::EActionSlot::Slot_A, CSmMode::EActionInput::None);
				SetPlayerAmmoMax(Event.Victim, CSmMode::EWeapon::Laser, 0);
				SetPlayerAmmoMax(Event.Victim, CSmMode::EWeapon::Nucleus, 0);
				Event.Victim.AmmoGain = 0.;
				declare UI <=> UIManager.GetUI(Event.Victim);
				if (UI != Null) 
				{
					declare netwrite Net_PrimaryWeapon for UI = 0;
					Net_PrimaryWeapon = 0;
				}
				foreach(Player in Players)
				{
					declare UI <=> UIManager.GetUI(Player);
					if (UI != Null) 
					{
						declare netwrite Integer[Text] Net_PrimaryWeapons for UI;
						Net_PrimaryWeapons[Event.Victim.Login] = 0;
					}
				}
				declare PLeft = G_PlayersAlive[Event.Victim.CurrentClan]-1;
				if(G_InstantRespawns[Event.Victim.CurrentClan]) continue;
				LT_AnnounceEliminationMessage(Event.Victim.CurrentClan-1, PLeft);	
			}
			else if(G_InstantRespawns[Event.Victim.CurrentClan])
			{
				declare SpawnTicket for Event.Victim = 0;
				SpawnTicket = 1;
			}
		}	
		XmlRpc::OnArmorEmpty(Event);
		PassOn(Event);
	}
	// Damage
	else if(Event.Type == CSmModeEvent::EType::OnHit && Event.Victim != Null) 
	{
		// Discard friendly fire
		if (Event.Shooter != Null && Event.Shooter.CurrentClan == Event.Victim.CurrentClan) {
			Discard(Event);
		} 
		else 
		{
			if(Event.WeaponNum == GetWeaponNum(CSmMode::EWeapon::Laser))
			{
				declare UI <=> UIManager.GetUI(Event.Shooter);
				if(UI != Null)
				{
					declare Distance = MathLib::Distance(Event.Shooter.Position, Event.Victim.Position);
					LT_AnnounceHitDistance(Distance, Event.Shooter);
				}
				Event.Damage = 200;
				Event.ShooterPoints = 2;
			}		
			if (Event.Shooter != Event.Victim)
			{
				declare UI <=> UIManager.GetUI(Event.Shooter);
				if (UI != Null) 
				{
					Score::AddPoints(Event.Shooter, Event.Damage/100);
					---HeadshotFunctions---
					---AnnounceHeadshot---
				}
				/*if(Event.Victim.Armor - Event.Damage <= 0)
				{
				}	*/
			}	
			//declare SpawnArmor for Event.Victim = 0;
			//SpawnArmor = Event.Victim.Armor - Event.Damage; 

			XmlRpc::OnHit(Event);
			PassOn(Event);
		}
	}
	// Action Maker Events
	else if(Event.Type == CSmModeEvent::EType::OnActionCustomEvent)
	{
		if(Event.Shooter == Null || Event.Victim == Null) Discard(Event);
		// Discard friendly fire
		if (Event.Param1 == "damage" && Event.Victim != Null && Event.Shooter != Null && Event.Shooter.CurrentClan == Event.Victim.CurrentClan) Discard(Event);
		else if(Event.Param1 == "damage" && Event.Victim != Null && Event.Shooter != Null && Event.Victim != Event.Shooter) 
		{
			declare Damage = TextLib::ToInteger(Event.Param2[0]);
           	declare Points = Damage / 100;
			declare UI <=> UIManager.GetUI(Event.Shooter);
			if (UI != Null) 
			{
				---HeadshotFunctions---
				---ActionMakerAnnounceHeadshot---
			}
            RemovePlayerArmor(Event.Victim, Damage, Event.Shooter, Points);
            Score::AddPoints(Event.Shooter, Points);
            PassOn(Event);
        }  
	}
	// On near miss
	else if(Event.Type == CSmModeEvent::EType::OnNearMiss && Event.Victim != Null) 
	{
		---OnNearMiss---
	}
	// Give Up
	else if (Event.Type == CSmModeEvent::EType::OnPlayerRequestRespawn && Event.Player != Null) 
	{
		declare Message = "";
		declare SpawnArmor for Event.Player = 100;
		SpawnArmor = Event.Player.Armor - 100;
		declare SpawnTicket for Event.Player = 0;
		if(SpawnArmor >= 100) SpawnTicket = 1;
		else if(G_InstantRespawns[Event.Player.CurrentClan])
		{
			SpawnTicket = 1;
			if(G_ZoneClanList[2] != Event.Player.CurrentClan)
			{
				declare Number = G_CheckpointDuration * S_TicketReduction * 10;
				foreach(MLGate in MapLandmarks)
				{
					if(LT_IsAfterHalfTime())
					{
						switch(Event.Player.CurrentClan)
						{
							case 1:
							{
								if(MLGate.Tag == "Supply2")
								{
									if(MLGate.Gauge.Value > Number) MLGate.Gauge.Value -= Number;
									else 
									{
										MLGate.Gauge.ValueReal = 0.;
										G_InstantRespawns[MLGate.Gauge.Clan] = False;
										AnnounceEnergyLoss(0, 2);
										MLGate.Gauge.Clan = 0;
										G_ZoneClanList[3] = 0;
										MLGate.Gate.ManualClosed = False;
									}	
								}	
							}
							case 2:
							{
								if(MLGate.Tag == "Supply1")
								{
									if(MLGate.Gauge.Value > Number) MLGate.Gauge.Value -= Number;
									else 
									{
										MLGate.Gauge.ValueReal = 0.;
										G_InstantRespawns[MLGate.Gauge.Clan] = False;
										AnnounceEnergyLoss(1, 1);
										MLGate.Gauge.Clan = 0;
										G_ZoneClanList[1] = 0;
										MLGate.Gate.ManualClosed = False;
									}
								}	
							}
						}
					}
					else
					{
						switch(Event.Player.CurrentClan)
						{
							case 1:
							{
								if(MLGate.Tag == "Supply1")
								{
									if(MLGate.Gauge.Value > Number) MLGate.Gauge.Value -= Number;
									else 
									{
										MLGate.Gauge.ValueReal = 0.;
										G_InstantRespawns[MLGate.Gauge.Clan] = False;
										AnnounceEnergyLoss(0, 1);
										MLGate.Gauge.Clan = 0;
										G_ZoneClanList[1] = 0;
										MLGate.Gate.ManualClosed = False;
									}	
								}
							}
							case 2:
							{
								if(MLGate.Tag == "Supply2")
								{
									if(MLGate.Gauge.Value > Number) MLGate.Gauge.Value -= Number;
									else 
									{
										MLGate.Gauge.ValueReal = 0.;
										G_InstantRespawns[MLGate.Gauge.Clan] = False;
										AnnounceEnergyLoss(1, 2);
										MLGate.Gauge.Clan = 0;
										G_ZoneClanList[3] = 0;
										MLGate.Gate.ManualClosed = False;
									}	
								}
							}
						}
					}
				}
			}	
		}
		else SpawnTicket = 0;
		//Remove primary weapon after elimination
		ActionBind(Event.Player, CSmMode::EActionSlot::Slot_A, CSmMode::EActionInput::None);
		SetPlayerAmmoMax(Event.Player, CSmMode::EWeapon::Laser, 0);
		SetPlayerAmmoMax(Event.Player, CSmMode::EWeapon::Nucleus, 0);
		Event.Player.AmmoGain = 0.;
		declare UI <=> UIManager.GetUI(Event.Player);
		if (UI != Null) 
		{
			declare netwrite Net_PrimaryWeapon for UI = 0;
			Net_PrimaryWeapon = 0;
		}
		foreach(Player in Players)
		{
			declare UI <=> UIManager.GetUI(Player);
			if (UI != Null) 
			{
				declare netwrite Integer[Text] Net_PrimaryWeapons for UI;
				Net_PrimaryWeapons[Event.Player.Login] = 0;
			}
		}
		if (G_PlayersAlive[Event.Player.CurrentClan] > 1) 
		{
			declare PLeft = G_PlayersAlive[Event.Player.CurrentClan];
			if(G_InstantRespawns[Event.Player.CurrentClan]) continue;
			LT_AnnounceEliminationMessage(Event.Player.CurrentClan-1, PLeft);
	 	}
		else if(G_InstantRespawns[Event.Player.CurrentClan])
		{
			declare SpawnTicket for Event.Player = 0;
			SpawnTicket = 1;
		}
		XmlRpc::OnPlayerRequestRespawn(Event);
		PassOn(Event);
	} 
	// Goal Captured
	else if (Event.Type == CSmModeEvent::EType::OnCapture && Event.Landmark != Null) Discard(Event);
	// Other events
	else PassOn(Event);
}
***

***EndRound***
***
LT_HidePlayersLists();
Layers::Detach("Markers");
Layers::Update("Progression", UpdateLayerProgression(0));
// Search for MVP
foreach(Player in Players)
{
	if(Player.Score.RoundPoints > BestRoundScore && Player.Score.RoundPoints > 0)
	{
		BestRoundScore = Player.Score.RoundPoints;
		MVP = Player;
	}	
}
if(MVP != Null && RoundClanWinner != 0)
{
	declare CurrentMVP for MVP.Score = 0;
	CurrentMVP += 1;
	ST2::SetColValue("ST_MVP", MVP.Score, "$fc0"^TextLib::ToText(CurrentMVP));
}	
Sound::PlaySound("file://Media/Sounds/FireFight/roundend.ogg", -5., 400);
MiniMap::Detach();
MB_Sleep(1500);
SM::UnspawnAllPlayers();
MB_Sleep(1000);
UIManager.UIAll.UISequence = CUIConfig::EUISequence::EndRound;
UIManager.UIAll.MarkersXML = "";
Victory::RoundEnd();
EndTime = -1;
if(RoundClanWinner > 0) G_ClansMapPoints[RoundClanWinner] += 1;
Message::CleanAllMessages();
Layers::Update("Progression", UpdateLayerProgression(1));
LT_DetachPlayersLists();
Layers::Detach("HUD");
if(MB_SectionRoundNb % 3 == 0) DisplayNotice();
LT_UpdateHeader(G_ClansMapPoints[1], G_ClansMapPoints[2]);
if(RoundClanWinner > 0 && MVP != Null) Message::SendStatusMessage(TextLib::Compose(_("$fc0MVP:$g $<%1$>"), MVP.Name), 6500, 0, CUIConfig::EUISound::Silence, 1);
LT_AnnounceRoundWin(RoundClanWinner);
UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::ForcedVisible;
MB_Sleep(4000);
Score::RoundEnd();
if(MB_SectionRoundNb == G_MapPointsLimit*2)
{
	if(G_ClansMapPoints[1] > G_ClansMapPoints[2])
	{
		ClanMapWinner = 1;
		MB_StopMap = True;
	}
	else if(G_ClansMapPoints[2] > G_ClansMapPoints[1])
	{
		ClanMapWinner = 2;
		MB_StopMap = True;
	}
	else
	{
		if(!S_FinalRoundExceptDraw)
		{
			ClanMapWinner = 0;
			MB_StopMap = True;
		}
		else
		{
			G_MapPointsLimit = G_ClansMapPoints[1]+1;
		}
	}
}
if(G_ClansMapPoints[1] > G_MapPointsLimit)
{
	ClanMapWinner = 1;
	MB_StopMap = True;
}
else if(G_ClansMapPoints[2] > G_MapPointsLimit)
{
	ClanMapWinner = 2;
	MB_StopMap = True;
}
if(MB_SectionRoundNb == G_MapPointsLimit)
{
	---AnnounceHalfTime---
}
else if(MB_SectionRoundNb == G_MapPointsLimit*2 && S_FinalRoundExceptDraw && ClanMapWinner == 0)
{
	---AnnounceFinalRound---
}
MB_Sleep(4500);
UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::Normal;
Message::CleanAllMessages();
if(PlayersNbTotal < 2) WaitForPlayers();
***

***EndMap***
***
/*foreach (Score in Scores) 
{
	declare PrevPoints for Score = 0;
	PrevPoints = Score.Points;
	declare CurrentMVP for Score = 0;
	Score.LadderMatchScoreValue = MathLib::ToReal(Score.Points + (CurrentMVP*2));
	// Winner
	if (Score.LadderClan == ClanMapWinner) {
		Score.Points = 4;
	}
	// Looser
	else if (Score.LadderClan == 3 - ClanMapWinner) {
		Score.Points = 2;
	}
	// Other
	else {
		Score.Points = 0;
		Score.LadderMatchScoreValue = 0.;
	}
}
Ladder_SetResultsVersion(1);
Score::MatchEnd(True);
foreach (Score in Scores) {
	declare PrevPoints for Score = 0;
	Score.Points = PrevPoints;
}*/

foreach (Player in Players) {
	if(Player.CurrentClan == ClanMapWinner && Player.Score != Null) {
		declare LadderBonus for Player.Score = 0;
		declare CurrentMVP for Player.Score = 0;
		LadderBonus += CurrentMVP*7;
	}
	else if(Player.CurrentClan != ClanMapWinner && Player.Score != Null) {
		declare LadderBonus for Player.Score = 0;
		declare CurrentMVP for Player.Score = 0;
		LadderBonus -= 40 - (CurrentMVP*3);
	}
}
foreach (Score in Scores) {
	declare LadderBonus for Score = 0;
	Score.Points += LadderBonus;
}
Score::MatchEnd();
foreach (Score in Scores) {
	declare LadderBonus for Score = 0;
	Score.Points -= LadderBonus;
	//Score.RoundPoints = LadderBonus;
}
ObjectDestroyAll();
Victory::MatchEnd();
Layers::Detach("Progression");
Message::SendStatusMessage(TextLib::Compose(_("Map result: %1 %2 - %3 %4"),Teams[0].ColorizedName,TextLib::ToText(G_ClansMapPoints[1]),TextLib::ToText(G_ClansMapPoints[2]),Teams[1].ColorizedName), 6000, 0, CUIConfig::EUISound::EndRound, 0);
if (ClanMapWinner > 0) Message::SendBigMessage(TextLib::Compose(_("%1 wins the map!"), Teams[ClanMapWinner - 1].ColorizedName), 6000, 0);
else Message::SendBigMessage(TextLib::Compose(_("|Match|Draw")), 6000, 0, CUIConfig::EUISound::Silence, 0);
UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::ForcedVisible;
UIManager.UIAll.UISequence = CUIConfig::EUISequence::Outro;
MB_Sleep(6000);
UIManager.UIAll.UISequence = CUIConfig::EUISequence::Podium;
MB_Sleep(6000);
UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::Normal;
LT_VoteMap(ClanMapWinner);
Message::CleanAllMessages();
***

***EndServer***
***
Layers::Destroy("Progression");
Layers::Destroy("RulesReminder");
//Layers::Destroy("SpawnScreenMap");
LT_DestroyLoadoutsLayers();
CustomUI::Unload();
Sound::Unload();
Layers::Destroy("Markers");
SpawnScreen::DestroyRules();
Layers::Clean();
***

Void InitGoals() 
{
	G_NbPolesB	= 0;
	foreach (LandmarkGauge in MapLandmarks_Gauge) 
	{
		if(LandmarkGauge.Sector != Null)
		{
			if(LandmarkGauge.Tag == "Zone") G_NbPolesB +=1;
		}
	}		
	
	foreach (Landmark in MapLandmarks) 
	{
		if(Landmark.Sector != Null)
		{
			if(Landmark.Tag == "Zone")
			{
				declare Summary = (G_PoleCaptureDuration-1) + G_NbPolesB;
				Landmark.Gauge.Max		= Summary * 3000;
				Landmark.Gauge.Value	= 0;
				Landmark.Gauge.Speed	= 0;
				Landmark.Gauge.Clan	= 0;
				Landmark.Gauge.Captured= False;
			}
			if(Landmark.Tag == "Supply1")
			{
				Landmark.Gauge.Max		= G_CheckpointDuration * 1000;
				Landmark.Gauge.Value	= Landmark.Gauge.Max;
				Landmark.Gauge.Speed	= 0;
				Landmark.Gate.Automatic = False;
				Landmark.Gate.ManualClosed = True;
				if(LT_IsAfterHalfTime()) Landmark.Gauge.Clan	= 2;
				else Landmark.Gauge.Clan = 1;
				Landmark.Gauge.Captured= True;
			}
			if(Landmark.Tag == "Supply2")
			{
				Landmark.Gauge.Max		= G_CheckpointDuration * 1000;
				Landmark.Gauge.Value	= Landmark.Gauge.Max;
				Landmark.Gauge.Speed	= 0;
				Landmark.Gate.Automatic = False;
				Landmark.Gate.ManualClosed = True;
				if(LT_IsAfterHalfTime()) Landmark.Gauge.Clan	= 1;
				else Landmark.Gauge.Clan = 2;
				Landmark.Gauge.Captured= True;
			}
		}	
	}
}

Void InitSpawns()
{
	// Init spawn
	G_SpawnList.clear();
	G_SpawnList1.clear();
	G_SpawnList2.clear();
	declare Integer I = 0;
	foreach (LandmarkPlayerSpawn in MapLandmarks_PlayerSpawn)
	{
		if (LandmarkPlayerSpawn.Tag == "Spawn1") 
		{
			G_SpawnList1.add(LandmarkPlayerSpawn.Id);
			G_SpawnList[I] <=> LandmarkPlayerSpawn;
			I+=1;
		}
		else if (LandmarkPlayerSpawn.Tag == "Spawn2")
		{
			G_SpawnList2.add(LandmarkPlayerSpawn.Id);
			G_SpawnList[I] <=> LandmarkPlayerSpawn;
			I+=1;
		}		
	}	
}

Void UpdateBasesColors() {
	foreach (Base in MapBases) {
		Base.Clan = 0;
		Base.IsActive = True;
	}
	
	declare UpdatedBases = Ident[];
	
	foreach (Spawn in MapLandmarks_PlayerSpawn) 
	{
		if (Spawn.Base == Null) continue;
		
		if(LT_IsAfterHalfTime())
		{
			switch(Spawn.Tag)
			{
				case "Spawn1": Spawn.Base.Clan = 2;
				case "Spawn2": Spawn.Base.Clan = 1;
			}	
		}
		else
		{
			switch(Spawn.Tag)
			{
				case "Spawn1": Spawn.Base.Clan = 1;
				case "Spawn2": Spawn.Base.Clan = 2;
			}
		}
		Spawn.Base.IsActive = True;
		UpdatedBases.add(Spawn.Base.Id);
	}
	
	foreach (Pole in MapLandmarks_Gauge)
	{
		declare Clan = 0;
		if (Pole.Gauge.Clan == 1 || Pole.Gauge.Clan == 2) Clan = Pole.Gauge.Clan;
		
		if (Pole.Base != Null) {
			if (!UpdatedBases.exists(Pole.Base.Id)) {
				Pole.Base.Clan = Clan;
				UpdatedBases.add(Pole.Base.Id);
			} else if (Pole.Base.Clan != Clan) {
				Pole.Base.Clan = 0;
			}
		}
	}
}

Void SpawnWeaponItems() {
	foreach (MapLandmark in MapLandmarks_ObjectAnchor) {
		declare ObjectAnchor <=> MapLandmark.ObjectAnchor;
		if (ObjectAnchor == Null) continue;
		
		declare ObjectSpawned for MapLandmark = False;
		declare ObjectNextSpawn for MapLandmark = Now;
		if (ObjectSpawned) continue;
		if (ObjectNextSpawn > Now) continue;
		
		declare CSmObject Object;
		switch (MapLandmark.Tag) {
			case C_Object["Laser"]			: Object = ObjectCreate(G_ObjectId[C_Object["Laser"]]);
			case C_Object["PlasmaGun"]		: Object = ObjectCreate(G_ObjectId[C_Object["PlasmaGun"]]);
			case C_Object["Grenades"]		: Object = ObjectCreate(G_ObjectId[C_Object["Grenades"]]);
			case C_Object["Nucleus"]		: Object = ObjectCreate(G_ObjectId[C_Object["Nucleus"]]);
			case C_Object["Shotgun"]		: Object = ObjectCreate(G_ObjectId[C_Object["Shotgun"]]);
			case C_Object["BlowBomb"]		: Object = ObjectCreate(G_ObjectId[C_Object["BlowBomb"]]);
		}
		if (Object != Null) {
			declare AnchorId for Object = NullId;
			declare Tag for Object = MapLandmark.Tag;
			AnchorId = MapLandmark.Id;
			Tag = MapLandmark.Tag;
			ObjectSpawned = True;
			Object.SetAnchor(ObjectAnchor);
		}
	}
}

Void PickUpWeapon(CSmPlayer _Player, Text _Weapon) 
{
	declare PrimaryWeapon for _Player = 1;
	switch (_Weapon) 
	{
		case "Laser":
		{
			SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Laser, 1);
			SetPlayerAmmo(_Player, CSmMode::EWeapon::Laser, 1);
			SetPlayerWeapon(_Player, CSmMode::EWeapon::Laser, False);
			ActionBind(_Player, CSmMode::EActionSlot::Slot_A, CSmMode::EActionInput::None);
			ActionBind(_Player, CSmMode::EActionSlot::Slot_B, CSmMode::EActionInput::None);
			_Player.AmmoGain = 0.85;
			PrimaryWeapon = 1;
		}
		case "PlasmaGun":
		{
			SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Laser, 0);
			SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Nucleus, 0);
			SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Arrow, 0);
			ActionLoad(_Player, CSmMode::EActionSlot::Slot_A, G_CustomPlasmaGun);
			ActionBind(_Player, CSmMode::EActionSlot::Slot_A, CSmMode::EActionInput::Weapon);
			PrimaryWeapon = 2;
		}
		case "Grenades":
		{
			SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Laser, 0);
			SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Nucleus, 0);
			SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Arrow, 0);
			ActionLoad(_Player, CSmMode::EActionSlot::Slot_A, G_CustomGrenades);
			ActionBind(_Player, CSmMode::EActionSlot::Slot_A, CSmMode::EActionInput::Weapon);
			PrimaryWeapon = 3;
		}
		case "Nucleus":
		{
			SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Nucleus, 2);
			SetPlayerAmmo(_Player, CSmMode::EWeapon::Nucleus, 1);
			SetPlayerWeapon(_Player, CSmMode::EWeapon::Nucleus, False);
			_Player.AmmoGain = 0.65;
			ActionBind(_Player, CSmMode::EActionSlot::Slot_A, CSmMode::EActionInput::None);
			ActionBind(_Player, CSmMode::EActionSlot::Slot_B, CSmMode::EActionInput::None);
			PrimaryWeapon = 4;
		}
		case "Shotgun":
		{
			SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Laser, 0);
			SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Nucleus, 0);
			SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Arrow, 0);
			ActionLoad(_Player, CSmMode::EActionSlot::Slot_A, G_CustomShotgun);
			ActionBind(_Player, CSmMode::EActionSlot::Slot_A, CSmMode::EActionInput::Weapon);
			PrimaryWeapon = 5;
		}
		case "BlowBomb":
		{
			SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Laser, 0);
			SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Nucleus, 0);
			SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Arrow, 0);
			ActionLoad(_Player, CSmMode::EActionSlot::Slot_A, G_CustomBlowBomb);
			ActionBind(_Player, CSmMode::EActionSlot::Slot_A, CSmMode::EActionInput::Weapon);
			PrimaryWeapon = 6;
		}
		default: return;
	}	
	_Player.StaminaMax = C_StaminaWith2Weapons;
	_Player.StaminaGain = C_StaminaWith2Weapons;
	_Player.SpeedPower = C_SpeedWith2Weapons;
	declare PUI <=> UIManager.GetUI(_Player);
	if(PUI != Null)
	{
		declare netwrite Net_PrimaryWeapon for PUI = 0;
		Net_PrimaryWeapon = PrimaryWeapon;
	}	
	foreach(Player in Players)
	{
		declare UI <=> UIManager.GetUI(Player);
		if (UI != Null) 
		{ 
			declare netwrite Integer[Text] Net_PrimaryWeapons for UI;
			Net_PrimaryWeapons[_Player.Login] = PrimaryWeapon;
		}
	}		

	UIManager.UIAll.SendNotice(
		TextLib::Compose(_("|Player picked up item|$<%1$> picked up %2"), _Player.Name, _Weapon), 
		CUIConfig::ENoticeLevel::Default , Null, 
		CUIConfig::EAvatarVariant::Happy, 
		CUIConfig::EUISound::Silence, 0
	);
}

Void PickUpObject(CSmPlayer _Player, CSmObject _Object) {
	if (_Player == Null || _Object == Null) return;
	
	declare Tag for _Object = "";
	declare AnchorId for _Object = NullId;
	
	if (!MapLandmarks_ObjectAnchor.existskey(AnchorId)) return;
	declare MapLandmark <=> MapLandmarks_ObjectAnchor[AnchorId];
	declare ObjectSpawned for MapLandmark = False;
	declare ObjectNextSpawn for MapLandmark = Now;
	ObjectSpawned = False;
	if(MB_CurrentSection == "WarmUp") ObjectNextSpawn = Now + 5000;
	else
	{
		if (S_ItemSpawnTime > 5) ObjectNextSpawn = Now + (S_ItemSpawnTime*1000);
		else ObjectNextSpawn = Now + 5000;
	}
	
	switch (Tag) 
	{
		case C_Object["Laser"]: PickUpWeapon(_Player, Tag);
		case C_Object["PlasmaGun"]: PickUpWeapon(_Player, Tag);
		case C_Object["Grenades"]: PickUpWeapon(_Player, Tag);
		case C_Object["Nucleus"]: PickUpWeapon(_Player, Tag);
		case C_Object["Shotgun"]: PickUpWeapon(_Player, Tag);
		case C_Object["BlowBomb"]: PickUpWeapon(_Player, Tag);
	}
	
	_Object.SetPlayer(_Player);
	ObjectDestroy(_Object);
}

Void SwitchWeapon(CSmPlayer _Player, CSmModeEvent::EActionInput _Input) {
	declare PrimaryWeapon for _Player = 1;
	declare SecondaryWeapon for _Player = 1;
	declare CurrentWeaponSlot for _Player = 2;
	
	switch (_Input) {
		// Primary weapon
		case CSmModeEvent::EActionInput::Activable1: 
		{
			switch(PrimaryWeapon)
			{
				case 1:
				{
					SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Laser, 1);
					SetPlayerWeapon(_Player, CSmMode::EWeapon::Laser, False);
					ActionLoad(_Player, CSmMode::EActionSlot::Slot_A, NullId);
					ActionBind(_Player, CSmMode::EActionSlot::Slot_A, CSmMode::EActionInput::None);
					ActionBind(_Player, CSmMode::EActionSlot::Slot_B, CSmMode::EActionInput::None);
					_Player.AmmoGain = 0.85;
				}
				case 2:
				{
					SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Laser, 0);
					SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Nucleus, 0);
					SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Arrow, 0);
					ActionLoad(_Player, CSmMode::EActionSlot::Slot_A, G_CustomPlasmaGun);
					ActionBind(_Player, CSmMode::EActionSlot::Slot_A, CSmMode::EActionInput::Weapon);
					_Player.AmmoGain = 1.;
				}
				case 3:
				{
					SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Laser, 0);
					SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Nucleus, 0);
					SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Arrow, 0);
					ActionLoad(_Player, CSmMode::EActionSlot::Slot_A, G_CustomGrenades);
					ActionBind(_Player, CSmMode::EActionSlot::Slot_A, CSmMode::EActionInput::Weapon);
					_Player.AmmoGain = 1.;
				}
				case 4:
				{
					SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Nucleus, 2);
					SetPlayerWeapon(_Player, CSmMode::EWeapon::Nucleus, False);
					ActionLoad(_Player, CSmMode::EActionSlot::Slot_A, NullId);
					ActionBind(_Player, CSmMode::EActionSlot::Slot_A, CSmMode::EActionInput::None);
					ActionBind(_Player, CSmMode::EActionSlot::Slot_B, CSmMode::EActionInput::None);
					_Player.AmmoGain = 0.65;
				}
				case 5:
				{
					SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Laser, 0);
					SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Nucleus, 0);
					SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Arrow, 0);
					ActionLoad(_Player, CSmMode::EActionSlot::Slot_A, G_CustomShotgun);
					ActionBind(_Player, CSmMode::EActionSlot::Slot_A, CSmMode::EActionInput::Weapon);
					_Player.AmmoGain = 1.;
				}
				case 6:
				{
					SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Laser, 0);
					SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Nucleus, 0);
					SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Arrow, 0);
					ActionLoad(_Player, CSmMode::EActionSlot::Slot_A, G_CustomBlowBomb);
					ActionBind(_Player, CSmMode::EActionSlot::Slot_A, CSmMode::EActionInput::Weapon);
					_Player.AmmoGain = 1.;
				}
				default:
				{
					switch(SecondaryWeapon)
					{
						case 1:
						{
							SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Rocket, 4);
							SetPlayerWeapon(_Player, CSmMode::EWeapon::Rocket, False);
							//ActionLoad(_Player, CSmMode::EActionSlot::Slot_A, NullId);
							ActionBind(_Player, CSmMode::EActionSlot::Slot_A, CSmMode::EActionInput::None);
							ActionBind(_Player, CSmMode::EActionSlot::Slot_B, CSmMode::EActionInput::None);
							_Player.AmmoGain = 1.;
						}
						case 2:
						{
							SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Rocket, 0);
							//ActionLoad(_Player, CSmMode::EActionSlot::Slot_A, NullId);
							ActionLoad(_Player, CSmMode::EActionSlot::Slot_B, G_CustomBounceRocket);
							ActionBind(_Player, CSmMode::EActionSlot::Slot_A, CSmMode::EActionInput::None);
							ActionBind(_Player, CSmMode::EActionSlot::Slot_B, CSmMode::EActionInput::Weapon);
							_Player.AmmoGain = 1.;
						}
						case 3:
						{
							SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Rocket, 0);
							//ActionLoad(_Player, CSmMode::EActionSlot::Slot_A, NullId);
							ActionLoad(_Player, CSmMode::EActionSlot::Slot_B, G_CustomElectricPistol);
							ActionBind(_Player, CSmMode::EActionSlot::Slot_A, CSmMode::EActionInput::None);
							ActionBind(_Player, CSmMode::EActionSlot::Slot_B, CSmMode::EActionInput::Weapon);
							_Player.AmmoGain = 1.;
						}
					}	
				}
			}
			CurrentWeaponSlot = 1;
		}
		// Secondary weapon
		case CSmModeEvent::EActionInput::Activable2: 
		{
			switch(SecondaryWeapon)
			{
				case 1:
				{
					SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Rocket, 4);
					SetPlayerWeapon(_Player, CSmMode::EWeapon::Rocket, False);
					//SetPlayerAmmo(_Player, CSmMode::EWeapon::Laser, 0);
					//SetPlayerAmmo(_Player, CSmMode::EWeapon::Nucleus, 0);
					//ActionLoad(_Player, CSmMode::EActionSlot::Slot_A, NullId);
					ActionBind(_Player, CSmMode::EActionSlot::Slot_A, CSmMode::EActionInput::None);
					ActionBind(_Player, CSmMode::EActionSlot::Slot_B, CSmMode::EActionInput::None);
					_Player.AmmoGain = 1.;
				}
				case 2:
				{
					SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Rocket, 0);
					//SetPlayerAmmo(_Player, CSmMode::EWeapon::Laser, 0);
					//SetPlayerAmmo(_Player, CSmMode::EWeapon::Nucleus, 0);
					SetPlayerWeapon(_Player, CSmMode::EWeapon::Rocket, False);
					//ActionLoad(_Player, CSmMode::EActionSlot::Slot_A, NullId);
					ActionLoad(_Player, CSmMode::EActionSlot::Slot_B, G_CustomBounceRocket);
					ActionBind(_Player, CSmMode::EActionSlot::Slot_A, CSmMode::EActionInput::None);
					ActionBind(_Player, CSmMode::EActionSlot::Slot_B, CSmMode::EActionInput::Weapon);
					_Player.AmmoGain = 1.;
				}
				case 3:
				{
					SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Rocket, 0);
					//SetPlayerAmmo(_Player, CSmMode::EWeapon::Laser, 0);
					//SetPlayerAmmo(_Player, CSmMode::EWeapon::Nucleus, 0);
					SetPlayerWeapon(_Player, CSmMode::EWeapon::Rocket, False);
					//ActionLoad(_Player, CSmMode::EActionSlot::Slot_A, NullId);
					ActionLoad(_Player, CSmMode::EActionSlot::Slot_B, G_CustomElectricPistol);
					ActionBind(_Player, CSmMode::EActionSlot::Slot_A, CSmMode::EActionInput::None);
					ActionBind(_Player, CSmMode::EActionSlot::Slot_B, CSmMode::EActionInput::Weapon);
					_Player.AmmoGain = 1.;
				}
			}	
			CurrentWeaponSlot = 2;
		}
	}
}

Void DisplayNotice()
{
	foreach (Player in Players) 
	{
		declare UI <=> UIManager.GetUI(Player);
		if (UI == Null) continue;
		declare rand = MathLib::Rand(1,6);
		
		declare Text[Integer] MSG;
		declare Prefix = "$f90$s>>";
		switch(Player.User.Language)
		{
			case "pl":
			{
				MSG[1] = "Śledź maniaflash $h[maniaflash?flashpoint]flashpoint$h by uzyskać informacje o aktualizacjach";
				MSG[2] = "Tryb został stworzony przez ToRRent'a";
				MSG[3] = "Wciśnij F8 by zmodyfikować interfejs";
				MSG[4] = "Kazdy respawn kosztuje energie chyba że posiadasz srodkowa strefe, wtedy spawn jest darmowy";
				MSG[5] = "Jeżeli masz sugestie co do rozwoju trybu, napisz $l[http://forum.maniaplanet.com/viewtopic.php?f=10&t=28177&start=0]tutaj$l";
				MSG[6] = "Zbierz przedmiot znajdujący się na mapie by zdobyć broń główną.";
				MSG[7] = "Naciśnij M by zobaczyć/schwoać mapę pełnoekranową";
			}
			case "fr": 
			{
				MSG[1] = "Abonne-toi au Maniaflash $h[maniaflash?flashpoint]flashpoint$h pour avoir les informations concernant les mises-à-jour et les rendez-vous";
				MSG[2] = "Mode de jeu créé par ToRRent";
				MSG[3] = "Appuie sur F8 pour personnaliser l'interface";
				MSG[4] = "Each Spawn ticket costs energy, If you have middle zone, spawning are free";
				MSG[5] = "Pour toute suggestion concernant le mode de jeu, merci d'aller $l[http://forum.maniaplanet.com/viewtopic.php?f=10&t=28177&start=0]ici$l";
				MSG[6] = "Collect weapon item located on map to get primary weapon.";
				MSG[7] = "Appuie sur M pour montrer/cacher la mini-map en plein écran";
			}
			case "it": 
			{
				MSG[1] = "Segui maniaflash $h[maniaflash?flashpoint]flashpoint$h per ot tenere le informazioni sul tema di aggiornamenti e riunioni";
				MSG[2] = "Il modo è stato creato grazie a ToRRent'a";
				MSG[3] = "Digiti F8 per modificare l’interfaccia";
				MSG[4] = "Each Spawn ticket costs energy, If you have middle zone, spawning are free";
				MSG[5] = "Se hai suggestioni rispetti allo sviluppo del modo, scrivi $l[http://forum.maniaplanet.com/viewtopic.php?f=10&t=28177&start=0]qui$l";
				MSG[6] = "Collect weapon item located on map to get primary weapon.";
				MSG[7] = "Digiti M per vedere/nascondere la mappa su tutto lo schermo";
			}
			case "de": 
			{
				MSG[1] = "Abonniere den ManiaFlash $h[maniaflash?flashpoint]flashpoint$h um Informationen über Aktualisierungen und Treffen zu erhalten";
				MSG[2] = "Spielmodus erstellt durch ToRRent";
				MSG[3] = "Drücke F8 um die Oberfläche anzupassen";
				MSG[4] = "Each Spawn ticket costs energy, If you have middle zone, spawning are free";
				MSG[5] = "Verbesserungsvorschläge bitte $l[http://forum.maniaplanet.com/viewtopic.php?f=10&t=28177&start=0]hier$l";
				MSG[6] = "Collect weapon item located on map to get primary weapon.";
				MSG[7] = "Minimaps anzeigen/verbergen durch Drücken von M im Vollbildmodus";
			}
			default:
			{
				MSG[1] = "Follow maniaflash $h[maniaflash?flashpoint]flashpoint$h to get informations about updates and meetings";
				MSG[2] = "Game mode was created by ToRRent";
				MSG[3] = "Press F8 to customize interface";
				MSG[4] = "Each Spawn ticket costs energy, If you have middle zone, spawning are free";
				MSG[5] = "If you have suggestion about gamemode, go $l[http://forum.maniaplanet.com/viewtopic.php?f=10&t=28177&start=0]here$l";
				MSG[6] = "Collect weapon item located on map to get primary weapon.";
				MSG[7] = "Press M to show/hide full screen map";
			}
		}

		switch(rand)
		{
			case 1: UI.SendChat(Prefix^MSG[1]);
			case 2: UI.SendChat(Prefix^MSG[2]);
			case 3: UI.SendChat(Prefix^MSG[3]);
			case 4: UI.SendChat(Prefix^MSG[4]);
			case 5: UI.SendChat(Prefix^MSG[5]);
			case 6: UI.SendChat(Prefix^MSG[6]);
		}
	}	
}

Text UpdateLayerHUD()
{	
	return """
<frame hidden="1" id="Frame_Overlay">
	<label posn="-65 -70 1" text="1: -" textsize="1" halign="left" id="Label_Primary"/>
	<label posn="-65 -74 1" text="2: -" textsize="1" halign="left" id="Label_Secondary"/>
</frame>
<script><!--	
main()
{
	declare Frame_Overlay <=> (Page.GetFirstChild("Frame_Overlay") as CMlFrame);
	declare Label_Primary <=> (Page.GetFirstChild("Label_Primary") as CMlLabel);
	declare Label_Secondary <=> (Page.GetFirstChild("Label_Secondary") as CMlLabel);
	while(True)
	{
		yield;
		if(InputPlayer == Null) continue;
		if(InputPlayer.Armor > 0)
		{
			Frame_Overlay.Visible = True;
			declare netread Net_PrimaryWeapon for UI = 0;
			switch(Net_PrimaryWeapon)
			{
				case 1: Label_Primary.Value = "1: Laser";
				case 2: Label_Primary.Value = "1: Plasma Gun";
				case 3: Label_Primary.Value = "1: Grenades";
				case 4: Label_Primary.Value = "1: Nucleus";
				case 5: Label_Primary.Value = "1: Shotgun";
				case 6: Label_Primary.Value = "1: BlowBomb";
				default: Label_Primary.Value = "1: -";
			}
			declare netread Integer[Text] Net_SecondaryWeapons for UI;
			if(Net_SecondaryWeapons.existskey(InputPlayer.Login))
			{
				switch(Net_SecondaryWeapons[InputPlayer.Login])
				{
					case 1: Label_Secondary.Value = "2: Rockets";
					case 2: Label_Secondary.Value = "2: Bouncing Rockets";
					case 3: Label_Secondary.Value = "2: Electric Pistol";
					default: Label_Secondary.Value = "2: -";
				}
			}
			else Label_Secondary.Value = "2: -";
		}
		else Frame_Overlay.Visible = False;		
	}
}
--></script>
	""";
}

Text UpdateLayerMarkers(Integer _Goals)
{
	declare ScreenRatio		= 9./16.;
	declare MarkerHeight	= 8;
	declare MarkerWidth		= MarkerHeight * ScreenRatio;
	declare ImgGoal			= "file://Media/Manialinks/ShootMania/Common/goal.dds";
	declare MLText 			= "";
	declare MarkerColor		= "";

	MLText = """
<script><!--
main() 
{
	declare GoalBArray = CMlFrame[Integer];
	declare I = 1;
	for(I, 1, {{{_Goals}}}) GoalBArray[I] = (Page.GetFirstChild("Goal_B"^I) as CMlFrame);
}
--></script>
""";
	declare Index = 1;
	for(Index, 1, _Goals)
	{
		if(G_ZoneClanList[2] == 0) MarkerColor = "DDD";
		else MarkerColor = TextLib::SubString(Teams[G_ZoneClanList[2]-1].ColorText, 1, 3);
		MLText ^= """
			<frame id="Goal_B{{{Index}}}" hidden="1">
				<quad sizen="{{{MarkerWidth}}} {{{MarkerHeight}}}" valign="center" halign="center" autoscale="False" image="{{{ImgGoal}}}" colorize="{{{MarkerColor}}}"/>
			</frame>
		""";
	}
	/*foreach(Player in Players)
	{
		MarkerColor = TextLib::SubString(Teams[Player.CurrentClan-1].ColorText, 1, 3);
		MLText ^= """
		<frame id="Player_{{{Player.Login}}}">
			<quad sizen="{{{MarkerWidth}}} {{{MarkerHeight}}}" valign="center" halign="center" autoscale="False" image="{{{ImgPlayer}}}" colorize="{{{MarkerColor}}}"/>
		</frame>
		""";
	}*/

	return MLText;		
}

Void UpdateMarker()
{
	UIManager.UIAll.MarkersXML = "";
	declare A = 0;
	declare B = 0;
	declare C = 0;
	
	foreach(Player in Players)
	{
		declare UI <=> UIManager.GetUI(Player);
		if (UI == Null) continue;
		declare PlayerManialink for Player = "";
		PlayerManialink = "";
		
		foreach (Goal in MapLandmarks) 
		{
			declare PosX = Goal.Position.X;
			declare PosY = Goal.Position.Y + 4;
			declare PosZ = Goal.Position.Z;
			if (Goal.Tag == "Supply1") 
			{
				A+=1;
				if(Player.CurrentClan == G_ZoneClanList[1]) PlayerManialink ^= """<marker label="Protect" pos="{{{PosX}}} {{{PosY}}} {{{PosZ}}}" hudvisibility="Always" minimapvisibility="Never" />""";
				else if(Player.CurrentClan != G_ZoneClanList[1] && G_ZoneClanList[1] > 0) PlayerManialink ^= """<marker label="Decapture" pos="{{{PosX}}} {{{PosY}}} {{{PosZ}}}" hudvisibility="Always" minimapvisibility="Never" />""";
			}
			else if (Goal.Tag == "Supply2") 
			{
				C+=1;
				if(Player.CurrentClan == G_ZoneClanList[3]) PlayerManialink ^= """<marker label="Protect" pos="{{{PosX}}} {{{PosY}}} {{{PosZ}}}" hudvisibility="Always" minimapvisibility="Never" />""";
				else if(Player.CurrentClan != G_ZoneClanList[3] && G_ZoneClanList[1] > 0) PlayerManialink ^= """<marker label="Decapture" pos="{{{PosX}}} {{{PosY}}} {{{PosZ}}}" hudvisibility="Always" minimapvisibility="Never" />""";
			}
			else if (Goal.Tag == "Zone") 
			{
				B+=1;
				PlayerManialink ^= """<marker manialinkframeid="Goal_B{{{B}}}" pos="{{{PosX}}} {{{PosY-3}}} {{{PosZ}}}" hudvisibility="Always" minimapvisibility="WhenInFrame" />""";
			}
		}
		foreach (MapLandmark in MapLandmarks_ObjectAnchor) 
		{
			declare PosX = MapLandmark.Position.X;
			declare PosY = MapLandmark.Position.Y+1;
			declare PosZ = MapLandmark.Position.Z;
			declare ImagePath = C_ImgModeDir^"/IconWeapon"^MapLandmark.Tag^".dds";
			PlayerManialink ^= """
			<marker imageurl="{{{ImagePath}}}" pos="{{{PosX}}} {{{PosY}}} {{{PosZ}}}" hudvisibility="Always" distmax="{{{G_ObjectDetector}}}" minimapvisibility="WhenInFrame" />
			""";
		}
	}
	/*foreach (Player in Players)
	{
		declare ImagePath = "file://Media/Manialinks/Common/Pointer.dds";
		declare TeamColor = TextLib::SubString(Teams[Player.CurrentClan-1].ColorText, 1, 3);
		ManiaLink ^= """
			<marker playerlogin="{{{Player.Login}}}" imageurl="{{{ImagePath}}}" color="{{{TeamColor}}}" isturning="false" hudvisibility="Never" minimapvisibility="WhenInFrame" />
		""";
	}*/
	Layers::Update("Markers", UpdateLayerMarkers(B));
	//UIManager.UIAll.MarkersXML = ManiaLink;
	foreach(Player in Players)
	{
		declare UI <=> UIManager.GetUI(Player);
		if (UI == Null) continue;
		declare PlayerManialink for Player = "";
		UI.MarkersXML = PlayerManialink;
	}	
}

Text UpdateLayerRulesReminder() {
	declare Text HighlightColor		= "fA0";
	
	declare Text TitleText 			= TextLib::Compose(_("Welcome to %1!"), "Flashpoint");
	declare Text Close				= _("Close");
	
	return """
<dico>
   <language id="en">
    	<rule1>- Reduce enemy gate energy to disable reinforcements and eliminate all enemies.</rule1>
    	<rule2>- Capture middle zone to respawn after dead without losing gate energy.</rule2>
    	<rule3>- Search for weapon items on map to get primary weapon.</rule3>
    	<rule4>- Controlled zone can be stolen by the opposing team.</rule4>
   </language>
   <language id="pl">
    	<rule1>- Zredukuj energie bramy rywali by zablokowac naplyw posilkow i wyeliminowac wszystkich.</rule1>
    	<rule2>- Zdobądz srodkowa strefe by odradzac sie bez straty energii</rule2>
    	<rule3>- Zdobądź bonus na mapie by mieć 2 bronie.</rule3>
    	<rule4>- Rywale mogą przechwycić twoje strefy terytorialne.</rule4>
   </language>
</dico>
<frame id="RulesReminderMainFrame" hidden="true" posn="0 13 100" >
	<quad posn="0 25 0" sizen="162 70" bgcolor="FFFA" image="{{{C_ImgModeDir}}}/WelcomeBg.dds" halign="center" valign="center"/>
	<label posn="-71 46 1" sizen="86 5" text="{{{TitleText}}}" textsize="4" textcolor="fA0" style="TextValueSmallSm"/>
	<label posn="-73 39 1" sizen="146 26" textid="rule1"/>
	<label posn="-73 33 1" sizen="146 26" textid="rule2"/>
	<label posn="-73 27 1" sizen="146 26" textid="rule3"/>
	<label posn="-73 21 1" sizen="146 26" textid="rule4"/>
	<label posn="0 12 1" halign="center" text="{{{TextLib::Compose(_("Press '$<%1F1$>' to close this window."), "$"^HighlightColor)}}}" textsize="3" />
</frame>
<script><!--
	while(InputPlayer == Null) yield;
	
	if(InputPlayer.User.LadderPoints > 3000) {
		return;
	}

	declare RulesReminderMainFrame 	<=> (Page.GetFirstChild("RulesReminderMainFrame") as CMlFrame);
	
	while(True) {
		yield;
		
		if(IsSpectatorMode) {
			RulesReminderMainFrame.Hide();
			continue;
		} else {
			RulesReminderMainFrame.Show();
		}
		
		foreach(Event in PendingEvents) {
			switch(Event.Type){
				case CMlEvent::Type::KeyPress: {
					if(Event.CharPressed == "2424832" ) { // F1
						RulesReminderMainFrame.Hide();
						return; // End of this behavior
					}
				}
			}
		}
	}
--></script>""";
}

// Update Progression layer
Text UpdateLayerProgression(Integer _Show)
{
	declare Integer ZoneA;
	declare Text ClanColorA;
	declare Integer ZoneB;
	declare Real RZoneB;
	declare Integer ClanB;
	declare Text ClanColorB;
	declare Integer ZoneC;
	declare Text ClanColorC;
	foreach(LandmarkGauge in MapLandmarks_Gauge) 
	{
		if (LandmarkGauge.Tag == "Zone")
		{
			ZoneB = MathLib::NearestInteger(LandmarkGauge.Gauge.ValueReal * 100.);
			RZoneB = LandmarkGauge.Gauge.ValueReal;
			ClanB = LandmarkGauge.Gauge.Clan;
			if(G_ZoneClanList[2] == 0) ClanColorB = "$FFF";
			else ClanColorB = Teams[G_ZoneClanList[2]-1].ColorText;
		}
		if (LandmarkGauge.Tag == "Supply1") 
		{
			if(LandmarkGauge.Gauge.ValueReal * 100. > 0 && LandmarkGauge.Gauge.ValueReal * 100. < 1) ZoneA = 1;
			else ZoneA = MathLib::NearestInteger(LandmarkGauge.Gauge.ValueReal * 100.);
			if(G_ZoneClanList[1] == 0) ClanColorA = "333";
			else ClanColorA = TextLib::ColorToText(Teams[G_ZoneClanList[1]-1].ColorPrimary);
			
			/*if(G_ZoneClanList[1] == 0) ClanColorA = "DDD";
			else ClanColorA = Teams[G_ZoneClanList[1]-1].ColorText;*/
		}
		if (LandmarkGauge.Tag == "Supply2") 
		{
			if(LandmarkGauge.Gauge.ValueReal * 100. > 0 && LandmarkGauge.Gauge.ValueReal * 100. < 1) ZoneC = 1;
			else ZoneC = MathLib::NearestInteger(LandmarkGauge.Gauge.ValueReal * 100.);
			if(G_ZoneClanList[3] == 0) ClanColorC = "333";
			else ClanColorC = TextLib::ColorToText(Teams[G_ZoneClanList[3]-1].ColorPrimary);
		}	
	}
	declare Text ManiaLink = "";
	ManiaLink = """
<manialink version="1" name="Flashpoint:Progression Layer">
<frame posn="0 0 0" id="Frame_Progression" hidden="{{{_Show}}}">
	<quad posn="-69 91.5 0" sizen="45 10.8" style="UiSMSpectatorScoreBig" substyle="HandleLeft" modulatecolor="{{{ClanColorA}}}"/>
	<label posn="-48 89 0" sizen="16 5" text="$s{{{ZoneA}}}%" style="TextTitle3" textsize="3"/>

	<label posn="0 -57 1" halign="center" valign="center" textsize="2" textemboss="1" text="{{{TextLib::Compose(_("%1Middle Zone$g"), ClanColorB)}}}" style="TextTitle3" sizen="50 7"/>
	<gauge posn="0 -63 1" sizen="50 9" halign="center" valign="center" style="EnergyBar" ratio="{{{RZoneB}}}" clan="{{{ClanB}}}" drawbg="1" drawblockbg="1"/>

	<quad posn="69 91.5 0" sizen="45 10.8" style="UiSMSpectatorScoreBig" substyle="HandleRight" halign="right" modulatecolor="{{{ClanColorC}}}"/>
	<label posn="48 89 0" sizen="16 5" text="$s{{{ZoneC}}}%" style="TextTitle3" textsize="3" halign="right"/>
</frame>
</manialink>
""";
	return ManiaLink;
}

Void AnnounceEnergyLoss(Integer _ClanNb, Integer _Zone)
{
	if(G_DecaptureAnnouncment[_Zone] || !G_InstantRespawns[_ClanNb+1]) return;
	// Give bonus to timer and manage only once
	if (G_RoundTime > 0 && G_RoundTimeBonus > 0)
	{
		EndTime += (G_RoundTimeBonus*1000);
		UpdateMarker();
	}
	UpdateBasesColors();
	G_DecaptureAnnouncment[_Zone] = True;
	G_InstantRespawns[_ClanNb+1] = False;
	UIManager.UIAll.SendNotice(TextLib::Compose(_("$<%1$> Lost energy supply"), Teams[_ClanNb].ColorizedName), CUIConfig::ENoticeLevel::Default , Null, CUIConfig::EAvatarVariant::Default, CUIConfig::EUISound::Capture, 0);
	Message::CleanBigMessages();
	foreach(Player in Players)
	{
		declare MSG = "";
		declare MSG2 = "";
		switch(Player.User.Language)
		{
			case "pl":
			{
				MSG = TextLib::Compose(_("$<%1$> stracili energię."), Teams[_ClanNb].ColorizedName);
				MSG2 = "Natychmiastowe odradzania zablokowane.";
			}	
			default:
			{
				MSG = TextLib::Compose(_("$<%1$> lost energy supply."), Teams[_ClanNb].ColorizedName);
				MSG2 = "Instant respawns disabled.";
			}	
		}		 
		Message::SendBigMessage(Player, MSG, 4000, 0);
		Message::SendStatusMessage(Player, MSG2, 4000, 0);
	}	
	foreach(Spectator in Spectators)
	{
		declare MSG = "";
		declare MSG2 = "";
		switch(Spectator.User.Language)
		{
			case "pl":
			{
				MSG = TextLib::Compose(_("$<%1$> stracili energię."), Teams[_ClanNb].ColorizedName);
				MSG2 = "Natychmiastowe odradzania zablokowane.";
			}
			default:
			{
				MSG = TextLib::Compose(_("$<%1$> lost energy supply."), Teams[_ClanNb].ColorizedName);
				MSG2 = "Instant respawns disabled.";
			}
		} 
		Message::SendBigMessage(Spectator, MSG, 4000, 0);
		Message::SendStatusMessage(Spectator, MSG2, 4000, 0);
	}
}

Void WaitForPlayers()
{
	---WaitForPlayers---
}

Void SelectClasses(Integer _TimeToChoose)
{
	---SelectClasses---
}